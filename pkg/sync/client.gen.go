// Package sync provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package sync

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/faetools/client"
)

// operation paths

const (
	opPathListDocumentFormat             = "./v1/Services/%s/Documents"
	opPathCreateDocumentFormat           = "./v1/Services/%s/Documents"
	opPathListDocumentPermissionFormat   = "./v1/Services/%s/Documents/%s/Permissions"
	opPathDeleteDocumentPermissionFormat = "./v1/Services/%s/Documents/%s/Permissions/%s"
	opPathFetchDocumentPermissionFormat  = "./v1/Services/%s/Documents/%s/Permissions/%s"
	opPathUpdateDocumentPermissionFormat = "./v1/Services/%s/Documents/%s/Permissions/%s"
	opPathDeleteDocumentFormat           = "./v1/Services/%s/Documents/%s"
	opPathFetchDocumentFormat            = "./v1/Services/%s/Documents/%s"
	opPathUpdateDocumentFormat           = "./v1/Services/%s/Documents/%s"
	opPathListSyncListFormat             = "./v1/Services/%s/Lists"
	opPathCreateSyncListFormat           = "./v1/Services/%s/Lists"
	opPathListSyncListItemFormat         = "./v1/Services/%s/Lists/%s/Items"
	opPathCreateSyncListItemFormat       = "./v1/Services/%s/Lists/%s/Items"
	opPathDeleteSyncListItemFormat       = "./v1/Services/%s/Lists/%s/Items/%s"
	opPathFetchSyncListItemFormat        = "./v1/Services/%s/Lists/%s/Items/%s"
	opPathUpdateSyncListItemFormat       = "./v1/Services/%s/Lists/%s/Items/%s"
	opPathListSyncListPermissionFormat   = "./v1/Services/%s/Lists/%s/Permissions"
	opPathDeleteSyncListPermissionFormat = "./v1/Services/%s/Lists/%s/Permissions/%s"
	opPathFetchSyncListPermissionFormat  = "./v1/Services/%s/Lists/%s/Permissions/%s"
	opPathUpdateSyncListPermissionFormat = "./v1/Services/%s/Lists/%s/Permissions/%s"
	opPathDeleteSyncListFormat           = "./v1/Services/%s/Lists/%s"
	opPathFetchSyncListFormat            = "./v1/Services/%s/Lists/%s"
	opPathUpdateSyncListFormat           = "./v1/Services/%s/Lists/%s"
	opPathListSyncMapFormat              = "./v1/Services/%s/Maps"
	opPathCreateSyncMapFormat            = "./v1/Services/%s/Maps"
	opPathListSyncMapItemFormat          = "./v1/Services/%s/Maps/%s/Items"
	opPathCreateSyncMapItemFormat        = "./v1/Services/%s/Maps/%s/Items"
	opPathDeleteSyncMapItemFormat        = "./v1/Services/%s/Maps/%s/Items/%s"
	opPathFetchSyncMapItemFormat         = "./v1/Services/%s/Maps/%s/Items/%s"
	opPathUpdateSyncMapItemFormat        = "./v1/Services/%s/Maps/%s/Items/%s"
	opPathListSyncMapPermissionFormat    = "./v1/Services/%s/Maps/%s/Permissions"
	opPathDeleteSyncMapPermissionFormat  = "./v1/Services/%s/Maps/%s/Permissions/%s"
	opPathFetchSyncMapPermissionFormat   = "./v1/Services/%s/Maps/%s/Permissions/%s"
	opPathUpdateSyncMapPermissionFormat  = "./v1/Services/%s/Maps/%s/Permissions/%s"
	opPathDeleteSyncMapFormat            = "./v1/Services/%s/Maps/%s"
	opPathFetchSyncMapFormat             = "./v1/Services/%s/Maps/%s"
	opPathUpdateSyncMapFormat            = "./v1/Services/%s/Maps/%s"
	opPathListSyncStreamFormat           = "./v1/Services/%s/Streams"
	opPathCreateSyncStreamFormat         = "./v1/Services/%s/Streams"
	opPathDeleteSyncStreamFormat         = "./v1/Services/%s/Streams/%s"
	opPathFetchSyncStreamFormat          = "./v1/Services/%s/Streams/%s"
	opPathUpdateSyncStreamFormat         = "./v1/Services/%s/Streams/%s"
	opPathCreateStreamMessageFormat      = "./v1/Services/%s/Streams/%s/Messages"
	opPathDeleteServiceFormat            = "./v1/Services/%s"
	opPathFetchServiceFormat             = "./v1/Services/%s"
	opPathUpdateServiceFormat            = "./v1/Services/%s"
)

var (
	opPathListService   = client.MustParseURL("./v1/Services")
	opPathCreateService = client.MustParseURL("./v1/Services")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// ListService request
	ListService(ctx context.Context, params *ListServiceParams, reqEditors ...client.RequestEditorFn) (*ListServiceResponse, error)

	// CreateService request with any body
	CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceResponse, error)

	// ListDocument request
	ListDocument(ctx context.Context, serviceSid string, params *ListDocumentParams, reqEditors ...client.RequestEditorFn) (*ListDocumentResponse, error)

	// CreateDocument request with any body
	CreateDocumentWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateDocumentResponse, error)

	// ListDocumentPermission request
	ListDocumentPermission(ctx context.Context, serviceSid string, documentSid string, params *ListDocumentPermissionParams, reqEditors ...client.RequestEditorFn) (*ListDocumentPermissionResponse, error)

	// DeleteDocumentPermission request
	DeleteDocumentPermission(ctx context.Context, serviceSid string, documentSid string, identity string, reqEditors ...client.RequestEditorFn) (*DeleteDocumentPermissionResponse, error)

	// FetchDocumentPermission request
	FetchDocumentPermission(ctx context.Context, serviceSid string, documentSid string, identity string, reqEditors ...client.RequestEditorFn) (*FetchDocumentPermissionResponse, error)

	// UpdateDocumentPermission request with any body
	UpdateDocumentPermissionWithBody(ctx context.Context, serviceSid string, documentSid string, identity string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateDocumentPermissionResponse, error)

	// DeleteDocument request
	DeleteDocument(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteDocumentResponse, error)

	// FetchDocument request
	FetchDocument(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchDocumentResponse, error)

	// UpdateDocument request with any body
	UpdateDocumentWithBody(ctx context.Context, serviceSid string, sid string, params *UpdateDocumentParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateDocumentResponse, error)

	// ListSyncList request
	ListSyncList(ctx context.Context, serviceSid string, params *ListSyncListParams, reqEditors ...client.RequestEditorFn) (*ListSyncListResponse, error)

	// CreateSyncList request with any body
	CreateSyncListWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSyncListResponse, error)

	// ListSyncListItem request
	ListSyncListItem(ctx context.Context, serviceSid string, listSid string, params *ListSyncListItemParams, reqEditors ...client.RequestEditorFn) (*ListSyncListItemResponse, error)

	// CreateSyncListItem request with any body
	CreateSyncListItemWithBody(ctx context.Context, serviceSid string, listSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSyncListItemResponse, error)

	// DeleteSyncListItem request
	DeleteSyncListItem(ctx context.Context, serviceSid string, listSid string, index int, params *DeleteSyncListItemParams, reqEditors ...client.RequestEditorFn) (*DeleteSyncListItemResponse, error)

	// FetchSyncListItem request
	FetchSyncListItem(ctx context.Context, serviceSid string, listSid string, index int, reqEditors ...client.RequestEditorFn) (*FetchSyncListItemResponse, error)

	// UpdateSyncListItem request with any body
	UpdateSyncListItemWithBody(ctx context.Context, serviceSid string, listSid string, index int, params *UpdateSyncListItemParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSyncListItemResponse, error)

	// ListSyncListPermission request
	ListSyncListPermission(ctx context.Context, serviceSid string, listSid string, params *ListSyncListPermissionParams, reqEditors ...client.RequestEditorFn) (*ListSyncListPermissionResponse, error)

	// DeleteSyncListPermission request
	DeleteSyncListPermission(ctx context.Context, serviceSid string, listSid string, identity string, reqEditors ...client.RequestEditorFn) (*DeleteSyncListPermissionResponse, error)

	// FetchSyncListPermission request
	FetchSyncListPermission(ctx context.Context, serviceSid string, listSid string, identity string, reqEditors ...client.RequestEditorFn) (*FetchSyncListPermissionResponse, error)

	// UpdateSyncListPermission request with any body
	UpdateSyncListPermissionWithBody(ctx context.Context, serviceSid string, listSid string, identity string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSyncListPermissionResponse, error)

	// DeleteSyncList request
	DeleteSyncList(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSyncListResponse, error)

	// FetchSyncList request
	FetchSyncList(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSyncListResponse, error)

	// UpdateSyncList request with any body
	UpdateSyncListWithBody(ctx context.Context, serviceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSyncListResponse, error)

	// ListSyncMap request
	ListSyncMap(ctx context.Context, serviceSid string, params *ListSyncMapParams, reqEditors ...client.RequestEditorFn) (*ListSyncMapResponse, error)

	// CreateSyncMap request with any body
	CreateSyncMapWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSyncMapResponse, error)

	// ListSyncMapItem request
	ListSyncMapItem(ctx context.Context, serviceSid string, mapSid string, params *ListSyncMapItemParams, reqEditors ...client.RequestEditorFn) (*ListSyncMapItemResponse, error)

	// CreateSyncMapItem request with any body
	CreateSyncMapItemWithBody(ctx context.Context, serviceSid string, mapSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSyncMapItemResponse, error)

	// DeleteSyncMapItem request
	DeleteSyncMapItem(ctx context.Context, serviceSid string, mapSid string, key string, params *DeleteSyncMapItemParams, reqEditors ...client.RequestEditorFn) (*DeleteSyncMapItemResponse, error)

	// FetchSyncMapItem request
	FetchSyncMapItem(ctx context.Context, serviceSid string, mapSid string, key string, reqEditors ...client.RequestEditorFn) (*FetchSyncMapItemResponse, error)

	// UpdateSyncMapItem request with any body
	UpdateSyncMapItemWithBody(ctx context.Context, serviceSid string, mapSid string, key string, params *UpdateSyncMapItemParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSyncMapItemResponse, error)

	// ListSyncMapPermission request
	ListSyncMapPermission(ctx context.Context, serviceSid string, mapSid string, params *ListSyncMapPermissionParams, reqEditors ...client.RequestEditorFn) (*ListSyncMapPermissionResponse, error)

	// DeleteSyncMapPermission request
	DeleteSyncMapPermission(ctx context.Context, serviceSid string, mapSid string, identity string, reqEditors ...client.RequestEditorFn) (*DeleteSyncMapPermissionResponse, error)

	// FetchSyncMapPermission request
	FetchSyncMapPermission(ctx context.Context, serviceSid string, mapSid string, identity string, reqEditors ...client.RequestEditorFn) (*FetchSyncMapPermissionResponse, error)

	// UpdateSyncMapPermission request with any body
	UpdateSyncMapPermissionWithBody(ctx context.Context, serviceSid string, mapSid string, identity string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSyncMapPermissionResponse, error)

	// DeleteSyncMap request
	DeleteSyncMap(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSyncMapResponse, error)

	// FetchSyncMap request
	FetchSyncMap(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSyncMapResponse, error)

	// UpdateSyncMap request with any body
	UpdateSyncMapWithBody(ctx context.Context, serviceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSyncMapResponse, error)

	// ListSyncStream request
	ListSyncStream(ctx context.Context, serviceSid string, params *ListSyncStreamParams, reqEditors ...client.RequestEditorFn) (*ListSyncStreamResponse, error)

	// CreateSyncStream request with any body
	CreateSyncStreamWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSyncStreamResponse, error)

	// DeleteSyncStream request
	DeleteSyncStream(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSyncStreamResponse, error)

	// FetchSyncStream request
	FetchSyncStream(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSyncStreamResponse, error)

	// UpdateSyncStream request with any body
	UpdateSyncStreamWithBody(ctx context.Context, serviceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSyncStreamResponse, error)

	// CreateStreamMessage request with any body
	CreateStreamMessageWithBody(ctx context.Context, serviceSid string, streamSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateStreamMessageResponse, error)

	// DeleteService request
	DeleteService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteServiceResponse, error)

	// FetchService request
	FetchService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceResponse, error)

	// UpdateService request with any body
	UpdateServiceWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// ListService: GET /v1/Services

type ListServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Services *[]SyncV1Service `json:"services,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListServiceRequest generates requests for ListService
func newListServiceRequest(baseURL *url.URL, params *ListServiceParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListService)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListService returns a parsed response.
// GET /v1/Services
func (c *Client) ListService(ctx context.Context, params *ListServiceParams, reqEditors ...client.RequestEditorFn) (*ListServiceResponse, error) {
	req, err := newListServiceRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Services *[]SyncV1Service `json:"services,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateService: POST /v1/Services

type CreateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SyncV1Service
}

// Status returns HTTPResponse.Status
func (r CreateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateServiceRequestWithBody generates requests for CreateService with any type of body
func newCreateServiceRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateService)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateServiceWithBody returns a parsed response.
// POST /v1/Services
func (c *Client) CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceResponse, error) {
	req, err := newCreateServiceRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncV1Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListDocument: GET /v1/Services/{ServiceSid}/Documents

type ListDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Documents *[]SyncV1ServiceDocument `json:"documents,omitempty"`
		Meta      *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListDocumentRequest generates requests for ListDocument
func newListDocumentRequest(baseURL *url.URL, serviceSid string, params *ListDocumentParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListDocumentFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListDocument returns a parsed response.
// GET /v1/Services/{ServiceSid}/Documents
func (c *Client) ListDocument(ctx context.Context, serviceSid string, params *ListDocumentParams, reqEditors ...client.RequestEditorFn) (*ListDocumentResponse, error) {
	req, err := newListDocumentRequest(c.BaseURL, serviceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Documents *[]SyncV1ServiceDocument `json:"documents,omitempty"`
			Meta      *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateDocument: POST /v1/Services/{ServiceSid}/Documents

type CreateDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SyncV1ServiceDocument
}

// Status returns HTTPResponse.Status
func (r CreateDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateDocumentRequestWithBody generates requests for CreateDocument with any type of body
func newCreateDocumentRequestWithBody(baseURL *url.URL, serviceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateDocumentFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateDocumentWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/Documents
func (c *Client) CreateDocumentWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateDocumentResponse, error) {
	req, err := newCreateDocumentRequestWithBody(c.BaseURL, serviceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncV1ServiceDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListDocumentPermission: GET /v1/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions

type ListDocumentPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Permissions *[]SyncV1ServiceDocumentDocumentPermission `json:"permissions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDocumentPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDocumentPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListDocumentPermissionRequest generates requests for ListDocumentPermission
func newListDocumentPermissionRequest(baseURL *url.URL, serviceSid string, documentSid string, params *ListDocumentPermissionParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DocumentSid", documentSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListDocumentPermissionFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListDocumentPermission returns a parsed response.
// GET /v1/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions
func (c *Client) ListDocumentPermission(ctx context.Context, serviceSid string, documentSid string, params *ListDocumentPermissionParams, reqEditors ...client.RequestEditorFn) (*ListDocumentPermissionResponse, error) {
	req, err := newListDocumentPermissionRequest(c.BaseURL, serviceSid, documentSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListDocumentPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Permissions *[]SyncV1ServiceDocumentDocumentPermission `json:"permissions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteDocumentPermission: DELETE /v1/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions/{Identity}

type DeleteDocumentPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDocumentPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDocumentPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteDocumentPermissionRequest generates requests for DeleteDocumentPermission
func newDeleteDocumentPermissionRequest(baseURL *url.URL, serviceSid string, documentSid string, identity string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DocumentSid", documentSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteDocumentPermissionFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteDocumentPermission returns a parsed response.
// DELETE /v1/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions/{Identity}
func (c *Client) DeleteDocumentPermission(ctx context.Context, serviceSid string, documentSid string, identity string, reqEditors ...client.RequestEditorFn) (*DeleteDocumentPermissionResponse, error) {
	req, err := newDeleteDocumentPermissionRequest(c.BaseURL, serviceSid, documentSid, identity)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteDocumentPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchDocumentPermission: GET /v1/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions/{Identity}

type FetchDocumentPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncV1ServiceDocumentDocumentPermission
}

// Status returns HTTPResponse.Status
func (r FetchDocumentPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchDocumentPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchDocumentPermissionRequest generates requests for FetchDocumentPermission
func newFetchDocumentPermissionRequest(baseURL *url.URL, serviceSid string, documentSid string, identity string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DocumentSid", documentSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchDocumentPermissionFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchDocumentPermission returns a parsed response.
// GET /v1/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions/{Identity}
func (c *Client) FetchDocumentPermission(ctx context.Context, serviceSid string, documentSid string, identity string, reqEditors ...client.RequestEditorFn) (*FetchDocumentPermissionResponse, error) {
	req, err := newFetchDocumentPermissionRequest(c.BaseURL, serviceSid, documentSid, identity)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchDocumentPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncV1ServiceDocumentDocumentPermission
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateDocumentPermission: POST /v1/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions/{Identity}

type UpdateDocumentPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncV1ServiceDocumentDocumentPermission
}

// Status returns HTTPResponse.Status
func (r UpdateDocumentPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDocumentPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateDocumentPermissionRequestWithBody generates requests for UpdateDocumentPermission with any type of body
func newUpdateDocumentPermissionRequestWithBody(baseURL *url.URL, serviceSid string, documentSid string, identity string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DocumentSid", documentSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateDocumentPermissionFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateDocumentPermissionWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/Documents/{DocumentSid}/Permissions/{Identity}
func (c *Client) UpdateDocumentPermissionWithBody(ctx context.Context, serviceSid string, documentSid string, identity string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateDocumentPermissionResponse, error) {
	req, err := newUpdateDocumentPermissionRequestWithBody(c.BaseURL, serviceSid, documentSid, identity, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateDocumentPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncV1ServiceDocumentDocumentPermission
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteDocument: DELETE /v1/Services/{ServiceSid}/Documents/{Sid}

type DeleteDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteDocumentRequest generates requests for DeleteDocument
func newDeleteDocumentRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteDocumentFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteDocument returns a parsed response.
// DELETE /v1/Services/{ServiceSid}/Documents/{Sid}
func (c *Client) DeleteDocument(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteDocumentResponse, error) {
	req, err := newDeleteDocumentRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchDocument: GET /v1/Services/{ServiceSid}/Documents/{Sid}

type FetchDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncV1ServiceDocument
}

// Status returns HTTPResponse.Status
func (r FetchDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchDocumentRequest generates requests for FetchDocument
func newFetchDocumentRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchDocumentFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchDocument returns a parsed response.
// GET /v1/Services/{ServiceSid}/Documents/{Sid}
func (c *Client) FetchDocument(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchDocumentResponse, error) {
	req, err := newFetchDocumentRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncV1ServiceDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateDocument: POST /v1/Services/{ServiceSid}/Documents/{Sid}

type UpdateDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncV1ServiceDocument
}

// Status returns HTTPResponse.Status
func (r UpdateDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateDocumentRequestWithBody generates requests for UpdateDocument with any type of body
func newUpdateDocumentRequestWithBody(baseURL *url.URL, serviceSid string, sid string, params *UpdateDocumentParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateDocumentFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.IfMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-Match", headerParam0)
	}

	return req, nil
}

// UpdateDocumentWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/Documents/{Sid}
func (c *Client) UpdateDocumentWithBody(ctx context.Context, serviceSid string, sid string, params *UpdateDocumentParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateDocumentResponse, error) {
	req, err := newUpdateDocumentRequestWithBody(c.BaseURL, serviceSid, sid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncV1ServiceDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSyncList: GET /v1/Services/{ServiceSid}/Lists

type ListSyncListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Lists *[]SyncV1ServiceSyncList `json:"lists,omitempty"`
		Meta  *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSyncListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSyncListRequest generates requests for ListSyncList
func newListSyncListRequest(baseURL *url.URL, serviceSid string, params *ListSyncListParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSyncListFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSyncList returns a parsed response.
// GET /v1/Services/{ServiceSid}/Lists
func (c *Client) ListSyncList(ctx context.Context, serviceSid string, params *ListSyncListParams, reqEditors ...client.RequestEditorFn) (*ListSyncListResponse, error) {
	req, err := newListSyncListRequest(c.BaseURL, serviceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSyncListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Lists *[]SyncV1ServiceSyncList `json:"lists,omitempty"`
			Meta  *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSyncList: POST /v1/Services/{ServiceSid}/Lists

type CreateSyncListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SyncV1ServiceSyncList
}

// Status returns HTTPResponse.Status
func (r CreateSyncListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSyncListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSyncListRequestWithBody generates requests for CreateSyncList with any type of body
func newCreateSyncListRequestWithBody(baseURL *url.URL, serviceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSyncListFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSyncListWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/Lists
func (c *Client) CreateSyncListWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSyncListResponse, error) {
	req, err := newCreateSyncListRequestWithBody(c.BaseURL, serviceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSyncListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncV1ServiceSyncList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListSyncListItem: GET /v1/Services/{ServiceSid}/Lists/{ListSid}/Items

type ListSyncListItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items *[]SyncV1ServiceSyncListSyncListItem `json:"items,omitempty"`
		Meta  *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSyncListItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncListItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSyncListItemRequest generates requests for ListSyncListItem
func newListSyncListItemRequest(baseURL *url.URL, serviceSid string, listSid string, params *ListSyncListItemParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ListSid", listSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSyncListItemFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Order != nil {
		if err := client.AddQueryParam(q, "Order", *params.Order); err != nil {
			return nil, err
		}
	}

	if params.From != nil {
		if err := client.AddQueryParam(q, "From", *params.From); err != nil {
			return nil, err
		}
	}

	if params.Bounds != nil {
		if err := client.AddQueryParam(q, "Bounds", *params.Bounds); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSyncListItem returns a parsed response.
// GET /v1/Services/{ServiceSid}/Lists/{ListSid}/Items
func (c *Client) ListSyncListItem(ctx context.Context, serviceSid string, listSid string, params *ListSyncListItemParams, reqEditors ...client.RequestEditorFn) (*ListSyncListItemResponse, error) {
	req, err := newListSyncListItemRequest(c.BaseURL, serviceSid, listSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSyncListItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items *[]SyncV1ServiceSyncListSyncListItem `json:"items,omitempty"`
			Meta  *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSyncListItem: POST /v1/Services/{ServiceSid}/Lists/{ListSid}/Items

type CreateSyncListItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SyncV1ServiceSyncListSyncListItem
}

// Status returns HTTPResponse.Status
func (r CreateSyncListItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSyncListItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSyncListItemRequestWithBody generates requests for CreateSyncListItem with any type of body
func newCreateSyncListItemRequestWithBody(baseURL *url.URL, serviceSid string, listSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ListSid", listSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSyncListItemFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSyncListItemWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/Lists/{ListSid}/Items
func (c *Client) CreateSyncListItemWithBody(ctx context.Context, serviceSid string, listSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSyncListItemResponse, error) {
	req, err := newCreateSyncListItemRequestWithBody(c.BaseURL, serviceSid, listSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSyncListItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncV1ServiceSyncListSyncListItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteSyncListItem: DELETE /v1/Services/{ServiceSid}/Lists/{ListSid}/Items/{Index}

type DeleteSyncListItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSyncListItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSyncListItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSyncListItemRequest generates requests for DeleteSyncListItem
func newDeleteSyncListItemRequest(baseURL *url.URL, serviceSid string, listSid string, index int, params *DeleteSyncListItemParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ListSid", listSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Index", index)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSyncListItemFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.IfMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-Match", headerParam0)
	}

	return req, nil
}

// DeleteSyncListItem returns a parsed response.
// DELETE /v1/Services/{ServiceSid}/Lists/{ListSid}/Items/{Index}
func (c *Client) DeleteSyncListItem(ctx context.Context, serviceSid string, listSid string, index int, params *DeleteSyncListItemParams, reqEditors ...client.RequestEditorFn) (*DeleteSyncListItemResponse, error) {
	req, err := newDeleteSyncListItemRequest(c.BaseURL, serviceSid, listSid, index, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSyncListItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSyncListItem: GET /v1/Services/{ServiceSid}/Lists/{ListSid}/Items/{Index}

type FetchSyncListItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncV1ServiceSyncListSyncListItem
}

// Status returns HTTPResponse.Status
func (r FetchSyncListItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSyncListItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSyncListItemRequest generates requests for FetchSyncListItem
func newFetchSyncListItemRequest(baseURL *url.URL, serviceSid string, listSid string, index int) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ListSid", listSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Index", index)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSyncListItemFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSyncListItem returns a parsed response.
// GET /v1/Services/{ServiceSid}/Lists/{ListSid}/Items/{Index}
func (c *Client) FetchSyncListItem(ctx context.Context, serviceSid string, listSid string, index int, reqEditors ...client.RequestEditorFn) (*FetchSyncListItemResponse, error) {
	req, err := newFetchSyncListItemRequest(c.BaseURL, serviceSid, listSid, index)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSyncListItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncV1ServiceSyncListSyncListItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSyncListItem: POST /v1/Services/{ServiceSid}/Lists/{ListSid}/Items/{Index}

type UpdateSyncListItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncV1ServiceSyncListSyncListItem
}

// Status returns HTTPResponse.Status
func (r UpdateSyncListItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncListItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSyncListItemRequestWithBody generates requests for UpdateSyncListItem with any type of body
func newUpdateSyncListItemRequestWithBody(baseURL *url.URL, serviceSid string, listSid string, index int, params *UpdateSyncListItemParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ListSid", listSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Index", index)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSyncListItemFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.IfMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-Match", headerParam0)
	}

	return req, nil
}

// UpdateSyncListItemWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/Lists/{ListSid}/Items/{Index}
func (c *Client) UpdateSyncListItemWithBody(ctx context.Context, serviceSid string, listSid string, index int, params *UpdateSyncListItemParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSyncListItemResponse, error) {
	req, err := newUpdateSyncListItemRequestWithBody(c.BaseURL, serviceSid, listSid, index, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSyncListItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncV1ServiceSyncListSyncListItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSyncListPermission: GET /v1/Services/{ServiceSid}/Lists/{ListSid}/Permissions

type ListSyncListPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Permissions *[]SyncV1ServiceSyncListSyncListPermission `json:"permissions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSyncListPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncListPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSyncListPermissionRequest generates requests for ListSyncListPermission
func newListSyncListPermissionRequest(baseURL *url.URL, serviceSid string, listSid string, params *ListSyncListPermissionParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ListSid", listSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSyncListPermissionFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSyncListPermission returns a parsed response.
// GET /v1/Services/{ServiceSid}/Lists/{ListSid}/Permissions
func (c *Client) ListSyncListPermission(ctx context.Context, serviceSid string, listSid string, params *ListSyncListPermissionParams, reqEditors ...client.RequestEditorFn) (*ListSyncListPermissionResponse, error) {
	req, err := newListSyncListPermissionRequest(c.BaseURL, serviceSid, listSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSyncListPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Permissions *[]SyncV1ServiceSyncListSyncListPermission `json:"permissions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteSyncListPermission: DELETE /v1/Services/{ServiceSid}/Lists/{ListSid}/Permissions/{Identity}

type DeleteSyncListPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSyncListPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSyncListPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSyncListPermissionRequest generates requests for DeleteSyncListPermission
func newDeleteSyncListPermissionRequest(baseURL *url.URL, serviceSid string, listSid string, identity string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ListSid", listSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSyncListPermissionFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSyncListPermission returns a parsed response.
// DELETE /v1/Services/{ServiceSid}/Lists/{ListSid}/Permissions/{Identity}
func (c *Client) DeleteSyncListPermission(ctx context.Context, serviceSid string, listSid string, identity string, reqEditors ...client.RequestEditorFn) (*DeleteSyncListPermissionResponse, error) {
	req, err := newDeleteSyncListPermissionRequest(c.BaseURL, serviceSid, listSid, identity)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSyncListPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSyncListPermission: GET /v1/Services/{ServiceSid}/Lists/{ListSid}/Permissions/{Identity}

type FetchSyncListPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncV1ServiceSyncListSyncListPermission
}

// Status returns HTTPResponse.Status
func (r FetchSyncListPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSyncListPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSyncListPermissionRequest generates requests for FetchSyncListPermission
func newFetchSyncListPermissionRequest(baseURL *url.URL, serviceSid string, listSid string, identity string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ListSid", listSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSyncListPermissionFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSyncListPermission returns a parsed response.
// GET /v1/Services/{ServiceSid}/Lists/{ListSid}/Permissions/{Identity}
func (c *Client) FetchSyncListPermission(ctx context.Context, serviceSid string, listSid string, identity string, reqEditors ...client.RequestEditorFn) (*FetchSyncListPermissionResponse, error) {
	req, err := newFetchSyncListPermissionRequest(c.BaseURL, serviceSid, listSid, identity)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSyncListPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncV1ServiceSyncListSyncListPermission
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSyncListPermission: POST /v1/Services/{ServiceSid}/Lists/{ListSid}/Permissions/{Identity}

type UpdateSyncListPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncV1ServiceSyncListSyncListPermission
}

// Status returns HTTPResponse.Status
func (r UpdateSyncListPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncListPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSyncListPermissionRequestWithBody generates requests for UpdateSyncListPermission with any type of body
func newUpdateSyncListPermissionRequestWithBody(baseURL *url.URL, serviceSid string, listSid string, identity string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ListSid", listSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSyncListPermissionFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSyncListPermissionWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/Lists/{ListSid}/Permissions/{Identity}
func (c *Client) UpdateSyncListPermissionWithBody(ctx context.Context, serviceSid string, listSid string, identity string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSyncListPermissionResponse, error) {
	req, err := newUpdateSyncListPermissionRequestWithBody(c.BaseURL, serviceSid, listSid, identity, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSyncListPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncV1ServiceSyncListSyncListPermission
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteSyncList: DELETE /v1/Services/{ServiceSid}/Lists/{Sid}

type DeleteSyncListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSyncListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSyncListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSyncListRequest generates requests for DeleteSyncList
func newDeleteSyncListRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSyncListFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSyncList returns a parsed response.
// DELETE /v1/Services/{ServiceSid}/Lists/{Sid}
func (c *Client) DeleteSyncList(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSyncListResponse, error) {
	req, err := newDeleteSyncListRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSyncListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSyncList: GET /v1/Services/{ServiceSid}/Lists/{Sid}

type FetchSyncListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncV1ServiceSyncList
}

// Status returns HTTPResponse.Status
func (r FetchSyncListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSyncListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSyncListRequest generates requests for FetchSyncList
func newFetchSyncListRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSyncListFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSyncList returns a parsed response.
// GET /v1/Services/{ServiceSid}/Lists/{Sid}
func (c *Client) FetchSyncList(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSyncListResponse, error) {
	req, err := newFetchSyncListRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSyncListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncV1ServiceSyncList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSyncList: POST /v1/Services/{ServiceSid}/Lists/{Sid}

type UpdateSyncListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncV1ServiceSyncList
}

// Status returns HTTPResponse.Status
func (r UpdateSyncListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSyncListRequestWithBody generates requests for UpdateSyncList with any type of body
func newUpdateSyncListRequestWithBody(baseURL *url.URL, serviceSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSyncListFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSyncListWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/Lists/{Sid}
func (c *Client) UpdateSyncListWithBody(ctx context.Context, serviceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSyncListResponse, error) {
	req, err := newUpdateSyncListRequestWithBody(c.BaseURL, serviceSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSyncListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncV1ServiceSyncList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSyncMap: GET /v1/Services/{ServiceSid}/Maps

type ListSyncMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Maps *[]SyncV1ServiceSyncMap `json:"maps,omitempty"`
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSyncMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSyncMapRequest generates requests for ListSyncMap
func newListSyncMapRequest(baseURL *url.URL, serviceSid string, params *ListSyncMapParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSyncMapFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSyncMap returns a parsed response.
// GET /v1/Services/{ServiceSid}/Maps
func (c *Client) ListSyncMap(ctx context.Context, serviceSid string, params *ListSyncMapParams, reqEditors ...client.RequestEditorFn) (*ListSyncMapResponse, error) {
	req, err := newListSyncMapRequest(c.BaseURL, serviceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSyncMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Maps *[]SyncV1ServiceSyncMap `json:"maps,omitempty"`
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSyncMap: POST /v1/Services/{ServiceSid}/Maps

type CreateSyncMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SyncV1ServiceSyncMap
}

// Status returns HTTPResponse.Status
func (r CreateSyncMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSyncMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSyncMapRequestWithBody generates requests for CreateSyncMap with any type of body
func newCreateSyncMapRequestWithBody(baseURL *url.URL, serviceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSyncMapFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSyncMapWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/Maps
func (c *Client) CreateSyncMapWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSyncMapResponse, error) {
	req, err := newCreateSyncMapRequestWithBody(c.BaseURL, serviceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSyncMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncV1ServiceSyncMap
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListSyncMapItem: GET /v1/Services/{ServiceSid}/Maps/{MapSid}/Items

type ListSyncMapItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items *[]SyncV1ServiceSyncMapSyncMapItem `json:"items,omitempty"`
		Meta  *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSyncMapItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncMapItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSyncMapItemRequest generates requests for ListSyncMapItem
func newListSyncMapItemRequest(baseURL *url.URL, serviceSid string, mapSid string, params *ListSyncMapItemParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("MapSid", mapSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSyncMapItemFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Order != nil {
		if err := client.AddQueryParam(q, "Order", *params.Order); err != nil {
			return nil, err
		}
	}

	if params.From != nil {
		if err := client.AddQueryParam(q, "From", *params.From); err != nil {
			return nil, err
		}
	}

	if params.Bounds != nil {
		if err := client.AddQueryParam(q, "Bounds", *params.Bounds); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSyncMapItem returns a parsed response.
// GET /v1/Services/{ServiceSid}/Maps/{MapSid}/Items
func (c *Client) ListSyncMapItem(ctx context.Context, serviceSid string, mapSid string, params *ListSyncMapItemParams, reqEditors ...client.RequestEditorFn) (*ListSyncMapItemResponse, error) {
	req, err := newListSyncMapItemRequest(c.BaseURL, serviceSid, mapSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSyncMapItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items *[]SyncV1ServiceSyncMapSyncMapItem `json:"items,omitempty"`
			Meta  *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSyncMapItem: POST /v1/Services/{ServiceSid}/Maps/{MapSid}/Items

type CreateSyncMapItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SyncV1ServiceSyncMapSyncMapItem
}

// Status returns HTTPResponse.Status
func (r CreateSyncMapItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSyncMapItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSyncMapItemRequestWithBody generates requests for CreateSyncMapItem with any type of body
func newCreateSyncMapItemRequestWithBody(baseURL *url.URL, serviceSid string, mapSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("MapSid", mapSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSyncMapItemFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSyncMapItemWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/Maps/{MapSid}/Items
func (c *Client) CreateSyncMapItemWithBody(ctx context.Context, serviceSid string, mapSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSyncMapItemResponse, error) {
	req, err := newCreateSyncMapItemRequestWithBody(c.BaseURL, serviceSid, mapSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSyncMapItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncV1ServiceSyncMapSyncMapItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteSyncMapItem: DELETE /v1/Services/{ServiceSid}/Maps/{MapSid}/Items/{Key}

type DeleteSyncMapItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSyncMapItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSyncMapItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSyncMapItemRequest generates requests for DeleteSyncMapItem
func newDeleteSyncMapItemRequest(baseURL *url.URL, serviceSid string, mapSid string, key string, params *DeleteSyncMapItemParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("MapSid", mapSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Key", key)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSyncMapItemFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.IfMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-Match", headerParam0)
	}

	return req, nil
}

// DeleteSyncMapItem returns a parsed response.
// DELETE /v1/Services/{ServiceSid}/Maps/{MapSid}/Items/{Key}
func (c *Client) DeleteSyncMapItem(ctx context.Context, serviceSid string, mapSid string, key string, params *DeleteSyncMapItemParams, reqEditors ...client.RequestEditorFn) (*DeleteSyncMapItemResponse, error) {
	req, err := newDeleteSyncMapItemRequest(c.BaseURL, serviceSid, mapSid, key, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSyncMapItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSyncMapItem: GET /v1/Services/{ServiceSid}/Maps/{MapSid}/Items/{Key}

type FetchSyncMapItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncV1ServiceSyncMapSyncMapItem
}

// Status returns HTTPResponse.Status
func (r FetchSyncMapItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSyncMapItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSyncMapItemRequest generates requests for FetchSyncMapItem
func newFetchSyncMapItemRequest(baseURL *url.URL, serviceSid string, mapSid string, key string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("MapSid", mapSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Key", key)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSyncMapItemFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSyncMapItem returns a parsed response.
// GET /v1/Services/{ServiceSid}/Maps/{MapSid}/Items/{Key}
func (c *Client) FetchSyncMapItem(ctx context.Context, serviceSid string, mapSid string, key string, reqEditors ...client.RequestEditorFn) (*FetchSyncMapItemResponse, error) {
	req, err := newFetchSyncMapItemRequest(c.BaseURL, serviceSid, mapSid, key)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSyncMapItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncV1ServiceSyncMapSyncMapItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSyncMapItem: POST /v1/Services/{ServiceSid}/Maps/{MapSid}/Items/{Key}

type UpdateSyncMapItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncV1ServiceSyncMapSyncMapItem
}

// Status returns HTTPResponse.Status
func (r UpdateSyncMapItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncMapItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSyncMapItemRequestWithBody generates requests for UpdateSyncMapItem with any type of body
func newUpdateSyncMapItemRequestWithBody(baseURL *url.URL, serviceSid string, mapSid string, key string, params *UpdateSyncMapItemParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("MapSid", mapSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Key", key)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSyncMapItemFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.IfMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-Match", headerParam0)
	}

	return req, nil
}

// UpdateSyncMapItemWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/Maps/{MapSid}/Items/{Key}
func (c *Client) UpdateSyncMapItemWithBody(ctx context.Context, serviceSid string, mapSid string, key string, params *UpdateSyncMapItemParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSyncMapItemResponse, error) {
	req, err := newUpdateSyncMapItemRequestWithBody(c.BaseURL, serviceSid, mapSid, key, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSyncMapItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncV1ServiceSyncMapSyncMapItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSyncMapPermission: GET /v1/Services/{ServiceSid}/Maps/{MapSid}/Permissions

type ListSyncMapPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Permissions *[]SyncV1ServiceSyncMapSyncMapPermission `json:"permissions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSyncMapPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncMapPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSyncMapPermissionRequest generates requests for ListSyncMapPermission
func newListSyncMapPermissionRequest(baseURL *url.URL, serviceSid string, mapSid string, params *ListSyncMapPermissionParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("MapSid", mapSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSyncMapPermissionFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSyncMapPermission returns a parsed response.
// GET /v1/Services/{ServiceSid}/Maps/{MapSid}/Permissions
func (c *Client) ListSyncMapPermission(ctx context.Context, serviceSid string, mapSid string, params *ListSyncMapPermissionParams, reqEditors ...client.RequestEditorFn) (*ListSyncMapPermissionResponse, error) {
	req, err := newListSyncMapPermissionRequest(c.BaseURL, serviceSid, mapSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSyncMapPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Permissions *[]SyncV1ServiceSyncMapSyncMapPermission `json:"permissions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteSyncMapPermission: DELETE /v1/Services/{ServiceSid}/Maps/{MapSid}/Permissions/{Identity}

type DeleteSyncMapPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSyncMapPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSyncMapPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSyncMapPermissionRequest generates requests for DeleteSyncMapPermission
func newDeleteSyncMapPermissionRequest(baseURL *url.URL, serviceSid string, mapSid string, identity string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("MapSid", mapSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSyncMapPermissionFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSyncMapPermission returns a parsed response.
// DELETE /v1/Services/{ServiceSid}/Maps/{MapSid}/Permissions/{Identity}
func (c *Client) DeleteSyncMapPermission(ctx context.Context, serviceSid string, mapSid string, identity string, reqEditors ...client.RequestEditorFn) (*DeleteSyncMapPermissionResponse, error) {
	req, err := newDeleteSyncMapPermissionRequest(c.BaseURL, serviceSid, mapSid, identity)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSyncMapPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSyncMapPermission: GET /v1/Services/{ServiceSid}/Maps/{MapSid}/Permissions/{Identity}

type FetchSyncMapPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncV1ServiceSyncMapSyncMapPermission
}

// Status returns HTTPResponse.Status
func (r FetchSyncMapPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSyncMapPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSyncMapPermissionRequest generates requests for FetchSyncMapPermission
func newFetchSyncMapPermissionRequest(baseURL *url.URL, serviceSid string, mapSid string, identity string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("MapSid", mapSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSyncMapPermissionFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSyncMapPermission returns a parsed response.
// GET /v1/Services/{ServiceSid}/Maps/{MapSid}/Permissions/{Identity}
func (c *Client) FetchSyncMapPermission(ctx context.Context, serviceSid string, mapSid string, identity string, reqEditors ...client.RequestEditorFn) (*FetchSyncMapPermissionResponse, error) {
	req, err := newFetchSyncMapPermissionRequest(c.BaseURL, serviceSid, mapSid, identity)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSyncMapPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncV1ServiceSyncMapSyncMapPermission
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSyncMapPermission: POST /v1/Services/{ServiceSid}/Maps/{MapSid}/Permissions/{Identity}

type UpdateSyncMapPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncV1ServiceSyncMapSyncMapPermission
}

// Status returns HTTPResponse.Status
func (r UpdateSyncMapPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncMapPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSyncMapPermissionRequestWithBody generates requests for UpdateSyncMapPermission with any type of body
func newUpdateSyncMapPermissionRequestWithBody(baseURL *url.URL, serviceSid string, mapSid string, identity string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("MapSid", mapSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSyncMapPermissionFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSyncMapPermissionWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/Maps/{MapSid}/Permissions/{Identity}
func (c *Client) UpdateSyncMapPermissionWithBody(ctx context.Context, serviceSid string, mapSid string, identity string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSyncMapPermissionResponse, error) {
	req, err := newUpdateSyncMapPermissionRequestWithBody(c.BaseURL, serviceSid, mapSid, identity, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSyncMapPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncV1ServiceSyncMapSyncMapPermission
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteSyncMap: DELETE /v1/Services/{ServiceSid}/Maps/{Sid}

type DeleteSyncMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSyncMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSyncMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSyncMapRequest generates requests for DeleteSyncMap
func newDeleteSyncMapRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSyncMapFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSyncMap returns a parsed response.
// DELETE /v1/Services/{ServiceSid}/Maps/{Sid}
func (c *Client) DeleteSyncMap(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSyncMapResponse, error) {
	req, err := newDeleteSyncMapRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSyncMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSyncMap: GET /v1/Services/{ServiceSid}/Maps/{Sid}

type FetchSyncMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncV1ServiceSyncMap
}

// Status returns HTTPResponse.Status
func (r FetchSyncMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSyncMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSyncMapRequest generates requests for FetchSyncMap
func newFetchSyncMapRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSyncMapFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSyncMap returns a parsed response.
// GET /v1/Services/{ServiceSid}/Maps/{Sid}
func (c *Client) FetchSyncMap(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSyncMapResponse, error) {
	req, err := newFetchSyncMapRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSyncMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncV1ServiceSyncMap
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSyncMap: POST /v1/Services/{ServiceSid}/Maps/{Sid}

type UpdateSyncMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncV1ServiceSyncMap
}

// Status returns HTTPResponse.Status
func (r UpdateSyncMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSyncMapRequestWithBody generates requests for UpdateSyncMap with any type of body
func newUpdateSyncMapRequestWithBody(baseURL *url.URL, serviceSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSyncMapFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSyncMapWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/Maps/{Sid}
func (c *Client) UpdateSyncMapWithBody(ctx context.Context, serviceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSyncMapResponse, error) {
	req, err := newUpdateSyncMapRequestWithBody(c.BaseURL, serviceSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSyncMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncV1ServiceSyncMap
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSyncStream: GET /v1/Services/{ServiceSid}/Streams

type ListSyncStreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Streams *[]SyncV1ServiceSyncStream `json:"streams,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSyncStreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSyncStreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSyncStreamRequest generates requests for ListSyncStream
func newListSyncStreamRequest(baseURL *url.URL, serviceSid string, params *ListSyncStreamParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSyncStreamFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSyncStream returns a parsed response.
// GET /v1/Services/{ServiceSid}/Streams
func (c *Client) ListSyncStream(ctx context.Context, serviceSid string, params *ListSyncStreamParams, reqEditors ...client.RequestEditorFn) (*ListSyncStreamResponse, error) {
	req, err := newListSyncStreamRequest(c.BaseURL, serviceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSyncStreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Streams *[]SyncV1ServiceSyncStream `json:"streams,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSyncStream: POST /v1/Services/{ServiceSid}/Streams

type CreateSyncStreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SyncV1ServiceSyncStream
}

// Status returns HTTPResponse.Status
func (r CreateSyncStreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSyncStreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSyncStreamRequestWithBody generates requests for CreateSyncStream with any type of body
func newCreateSyncStreamRequestWithBody(baseURL *url.URL, serviceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSyncStreamFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSyncStreamWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/Streams
func (c *Client) CreateSyncStreamWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSyncStreamResponse, error) {
	req, err := newCreateSyncStreamRequestWithBody(c.BaseURL, serviceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSyncStreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncV1ServiceSyncStream
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteSyncStream: DELETE /v1/Services/{ServiceSid}/Streams/{Sid}

type DeleteSyncStreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSyncStreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSyncStreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSyncStreamRequest generates requests for DeleteSyncStream
func newDeleteSyncStreamRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSyncStreamFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSyncStream returns a parsed response.
// DELETE /v1/Services/{ServiceSid}/Streams/{Sid}
func (c *Client) DeleteSyncStream(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSyncStreamResponse, error) {
	req, err := newDeleteSyncStreamRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSyncStreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSyncStream: GET /v1/Services/{ServiceSid}/Streams/{Sid}

type FetchSyncStreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncV1ServiceSyncStream
}

// Status returns HTTPResponse.Status
func (r FetchSyncStreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSyncStreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSyncStreamRequest generates requests for FetchSyncStream
func newFetchSyncStreamRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSyncStreamFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSyncStream returns a parsed response.
// GET /v1/Services/{ServiceSid}/Streams/{Sid}
func (c *Client) FetchSyncStream(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSyncStreamResponse, error) {
	req, err := newFetchSyncStreamRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSyncStreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncV1ServiceSyncStream
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSyncStream: POST /v1/Services/{ServiceSid}/Streams/{Sid}

type UpdateSyncStreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncV1ServiceSyncStream
}

// Status returns HTTPResponse.Status
func (r UpdateSyncStreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSyncStreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSyncStreamRequestWithBody generates requests for UpdateSyncStream with any type of body
func newUpdateSyncStreamRequestWithBody(baseURL *url.URL, serviceSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSyncStreamFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSyncStreamWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/Streams/{Sid}
func (c *Client) UpdateSyncStreamWithBody(ctx context.Context, serviceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSyncStreamResponse, error) {
	req, err := newUpdateSyncStreamRequestWithBody(c.BaseURL, serviceSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSyncStreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncV1ServiceSyncStream
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateStreamMessage: POST /v1/Services/{ServiceSid}/Streams/{StreamSid}/Messages

type CreateStreamMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SyncV1ServiceSyncStreamStreamMessage
}

// Status returns HTTPResponse.Status
func (r CreateStreamMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStreamMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateStreamMessageRequestWithBody generates requests for CreateStreamMessage with any type of body
func newCreateStreamMessageRequestWithBody(baseURL *url.URL, serviceSid string, streamSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("StreamSid", streamSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateStreamMessageFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateStreamMessageWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/Streams/{StreamSid}/Messages
func (c *Client) CreateStreamMessageWithBody(ctx context.Context, serviceSid string, streamSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateStreamMessageResponse, error) {
	req, err := newCreateStreamMessageRequestWithBody(c.BaseURL, serviceSid, streamSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateStreamMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SyncV1ServiceSyncStreamStreamMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteService: DELETE /v1/Services/{Sid}

type DeleteServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteServiceRequest generates requests for DeleteService
func newDeleteServiceRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteServiceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteService returns a parsed response.
// DELETE /v1/Services/{Sid}
func (c *Client) DeleteService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteServiceResponse, error) {
	req, err := newDeleteServiceRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchService: GET /v1/Services/{Sid}

type FetchServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncV1Service
}

// Status returns HTTPResponse.Status
func (r FetchServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchServiceRequest generates requests for FetchService
func newFetchServiceRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchServiceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchService returns a parsed response.
// GET /v1/Services/{Sid}
func (c *Client) FetchService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceResponse, error) {
	req, err := newFetchServiceRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncV1Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateService: POST /v1/Services/{Sid}

type UpdateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyncV1Service
}

// Status returns HTTPResponse.Status
func (r UpdateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateServiceRequestWithBody generates requests for UpdateService with any type of body
func newUpdateServiceRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateServiceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateServiceWithBody returns a parsed response.
// POST /v1/Services/{Sid}
func (c *Client) UpdateServiceWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceResponse, error) {
	req, err := newUpdateServiceRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyncV1Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
