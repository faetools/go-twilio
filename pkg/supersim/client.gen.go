// Package supersim provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package supersim

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/faetools/client"
)

// operation paths

const (
	opPathFetchCommandFormat                      = "./v1/Commands/%s"
	opPathFetchEsimProfileFormat                  = "./v1/ESimProfiles/%s"
	opPathFetchFleetFormat                        = "./v1/Fleets/%s"
	opPathUpdateFleetFormat                       = "./v1/Fleets/%s"
	opPathFetchIpCommandFormat                    = "./v1/IpCommands/%s"
	opPathListNetworkAccessProfileNetworkFormat   = "./v1/NetworkAccessProfiles/%s/Networks"
	opPathCreateNetworkAccessProfileNetworkFormat = "./v1/NetworkAccessProfiles/%s/Networks"
	opPathDeleteNetworkAccessProfileNetworkFormat = "./v1/NetworkAccessProfiles/%s/Networks/%s"
	opPathFetchNetworkAccessProfileNetworkFormat  = "./v1/NetworkAccessProfiles/%s/Networks/%s"
	opPathFetchNetworkAccessProfileFormat         = "./v1/NetworkAccessProfiles/%s"
	opPathUpdateNetworkAccessProfileFormat        = "./v1/NetworkAccessProfiles/%s"
	opPathFetchNetworkFormat                      = "./v1/Networks/%s"
	opPathFetchSimFormat                          = "./v1/Sims/%s"
	opPathUpdateSimFormat                         = "./v1/Sims/%s"
	opPathListBillingPeriodFormat                 = "./v1/Sims/%s/BillingPeriods"
	opPathFetchSmsCommandFormat                   = "./v1/SmsCommands/%s"
)

var (
	opPathListCommand                = client.MustParseURL("./v1/Commands")
	opPathCreateCommand              = client.MustParseURL("./v1/Commands")
	opPathListEsimProfile            = client.MustParseURL("./v1/ESimProfiles")
	opPathCreateEsimProfile          = client.MustParseURL("./v1/ESimProfiles")
	opPathListFleet                  = client.MustParseURL("./v1/Fleets")
	opPathCreateFleet                = client.MustParseURL("./v1/Fleets")
	opPathListIpCommand              = client.MustParseURL("./v1/IpCommands")
	opPathCreateIpCommand            = client.MustParseURL("./v1/IpCommands")
	opPathListNetworkAccessProfile   = client.MustParseURL("./v1/NetworkAccessProfiles")
	opPathCreateNetworkAccessProfile = client.MustParseURL("./v1/NetworkAccessProfiles")
	opPathListNetwork                = client.MustParseURL("./v1/Networks")
	opPathListSim                    = client.MustParseURL("./v1/Sims")
	opPathCreateSim                  = client.MustParseURL("./v1/Sims")
	opPathListSmsCommand             = client.MustParseURL("./v1/SmsCommands")
	opPathCreateSmsCommand           = client.MustParseURL("./v1/SmsCommands")
	opPathListUsageRecord            = client.MustParseURL("./v1/UsageRecords")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// ListCommand request
	ListCommand(ctx context.Context, params *ListCommandParams, reqEditors ...client.RequestEditorFn) (*ListCommandResponse, error)

	// CreateCommand request with any body
	CreateCommandWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCommandResponse, error)

	// FetchCommand request
	FetchCommand(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchCommandResponse, error)

	// ListEsimProfile request
	ListEsimProfile(ctx context.Context, params *ListEsimProfileParams, reqEditors ...client.RequestEditorFn) (*ListEsimProfileResponse, error)

	// CreateEsimProfile request with any body
	CreateEsimProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateEsimProfileResponse, error)

	// FetchEsimProfile request
	FetchEsimProfile(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchEsimProfileResponse, error)

	// ListFleet request
	ListFleet(ctx context.Context, params *ListFleetParams, reqEditors ...client.RequestEditorFn) (*ListFleetResponse, error)

	// CreateFleet request with any body
	CreateFleetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateFleetResponse, error)

	// FetchFleet request
	FetchFleet(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchFleetResponse, error)

	// UpdateFleet request with any body
	UpdateFleetWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateFleetResponse, error)

	// ListIpCommand request
	ListIpCommand(ctx context.Context, params *ListIpCommandParams, reqEditors ...client.RequestEditorFn) (*ListIpCommandResponse, error)

	// CreateIpCommand request with any body
	CreateIpCommandWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateIpCommandResponse, error)

	// FetchIpCommand request
	FetchIpCommand(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchIpCommandResponse, error)

	// ListNetworkAccessProfile request
	ListNetworkAccessProfile(ctx context.Context, params *ListNetworkAccessProfileParams, reqEditors ...client.RequestEditorFn) (*ListNetworkAccessProfileResponse, error)

	// CreateNetworkAccessProfile request with any body
	CreateNetworkAccessProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateNetworkAccessProfileResponse, error)

	// ListNetworkAccessProfileNetwork request
	ListNetworkAccessProfileNetwork(ctx context.Context, networkAccessProfileSid string, params *ListNetworkAccessProfileNetworkParams, reqEditors ...client.RequestEditorFn) (*ListNetworkAccessProfileNetworkResponse, error)

	// CreateNetworkAccessProfileNetwork request with any body
	CreateNetworkAccessProfileNetworkWithBody(ctx context.Context, networkAccessProfileSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateNetworkAccessProfileNetworkResponse, error)

	// DeleteNetworkAccessProfileNetwork request
	DeleteNetworkAccessProfileNetwork(ctx context.Context, networkAccessProfileSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteNetworkAccessProfileNetworkResponse, error)

	// FetchNetworkAccessProfileNetwork request
	FetchNetworkAccessProfileNetwork(ctx context.Context, networkAccessProfileSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchNetworkAccessProfileNetworkResponse, error)

	// FetchNetworkAccessProfile request
	FetchNetworkAccessProfile(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchNetworkAccessProfileResponse, error)

	// UpdateNetworkAccessProfile request with any body
	UpdateNetworkAccessProfileWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateNetworkAccessProfileResponse, error)

	// ListNetwork request
	ListNetwork(ctx context.Context, params *ListNetworkParams, reqEditors ...client.RequestEditorFn) (*ListNetworkResponse, error)

	// FetchNetwork request
	FetchNetwork(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchNetworkResponse, error)

	// ListSim request
	ListSim(ctx context.Context, params *ListSimParams, reqEditors ...client.RequestEditorFn) (*ListSimResponse, error)

	// CreateSim request with any body
	CreateSimWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSimResponse, error)

	// FetchSim request
	FetchSim(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchSimResponse, error)

	// UpdateSim request with any body
	UpdateSimWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSimResponse, error)

	// ListBillingPeriod request
	ListBillingPeriod(ctx context.Context, simSid string, params *ListBillingPeriodParams, reqEditors ...client.RequestEditorFn) (*ListBillingPeriodResponse, error)

	// ListSmsCommand request
	ListSmsCommand(ctx context.Context, params *ListSmsCommandParams, reqEditors ...client.RequestEditorFn) (*ListSmsCommandResponse, error)

	// CreateSmsCommand request with any body
	CreateSmsCommandWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSmsCommandResponse, error)

	// FetchSmsCommand request
	FetchSmsCommand(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchSmsCommandResponse, error)

	// ListUsageRecord request
	ListUsageRecord(ctx context.Context, params *ListUsageRecordParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// ListCommand: GET /v1/Commands

type ListCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Commands *[]SupersimV1Command `json:"commands,omitempty"`
		Meta     *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListCommandRequest generates requests for ListCommand
func newListCommandRequest(baseURL *url.URL, params *ListCommandParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListCommand)

	q := queryURL.Query()

	if params.Sim != nil {
		if err := client.AddQueryParam(q, "Sim", *params.Sim); err != nil {
			return nil, err
		}
	}

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.Direction != nil {
		if err := client.AddQueryParam(q, "Direction", *params.Direction); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListCommand returns a parsed response.
// GET /v1/Commands
func (c *Client) ListCommand(ctx context.Context, params *ListCommandParams, reqEditors ...client.RequestEditorFn) (*ListCommandResponse, error) {
	req, err := newListCommandRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Commands *[]SupersimV1Command `json:"commands,omitempty"`
			Meta     *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateCommand: POST /v1/Commands

type CreateCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SupersimV1Command
}

// Status returns HTTPResponse.Status
func (r CreateCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateCommandRequestWithBody generates requests for CreateCommand with any type of body
func newCreateCommandRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateCommand)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateCommandWithBody returns a parsed response.
// POST /v1/Commands
func (c *Client) CreateCommandWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCommandResponse, error) {
	req, err := newCreateCommandRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SupersimV1Command
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// FetchCommand: GET /v1/Commands/{Sid}

type FetchCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupersimV1Command
}

// Status returns HTTPResponse.Status
func (r FetchCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchCommandRequest generates requests for FetchCommand
func newFetchCommandRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchCommandFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchCommand returns a parsed response.
// GET /v1/Commands/{Sid}
func (c *Client) FetchCommand(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchCommandResponse, error) {
	req, err := newFetchCommandRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupersimV1Command
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListEsimProfile: GET /v1/ESimProfiles

type ListEsimProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		EsimProfiles *[]SupersimV1EsimProfile `json:"esim_profiles,omitempty"`
		Meta         *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListEsimProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEsimProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListEsimProfileRequest generates requests for ListEsimProfile
func newListEsimProfileRequest(baseURL *url.URL, params *ListEsimProfileParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListEsimProfile)

	q := queryURL.Query()

	if params.Eid != nil {
		if err := client.AddQueryParam(q, "Eid", *params.Eid); err != nil {
			return nil, err
		}
	}

	if params.SimSid != nil {
		if err := client.AddQueryParam(q, "SimSid", *params.SimSid); err != nil {
			return nil, err
		}
	}

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListEsimProfile returns a parsed response.
// GET /v1/ESimProfiles
func (c *Client) ListEsimProfile(ctx context.Context, params *ListEsimProfileParams, reqEditors ...client.RequestEditorFn) (*ListEsimProfileResponse, error) {
	req, err := newListEsimProfileRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListEsimProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			EsimProfiles *[]SupersimV1EsimProfile `json:"esim_profiles,omitempty"`
			Meta         *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateEsimProfile: POST /v1/ESimProfiles

type CreateEsimProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SupersimV1EsimProfile
}

// Status returns HTTPResponse.Status
func (r CreateEsimProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEsimProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateEsimProfileRequestWithBody generates requests for CreateEsimProfile with any type of body
func newCreateEsimProfileRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateEsimProfile)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateEsimProfileWithBody returns a parsed response.
// POST /v1/ESimProfiles
func (c *Client) CreateEsimProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateEsimProfileResponse, error) {
	req, err := newCreateEsimProfileRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateEsimProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SupersimV1EsimProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// FetchEsimProfile: GET /v1/ESimProfiles/{Sid}

type FetchEsimProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupersimV1EsimProfile
}

// Status returns HTTPResponse.Status
func (r FetchEsimProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchEsimProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchEsimProfileRequest generates requests for FetchEsimProfile
func newFetchEsimProfileRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchEsimProfileFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchEsimProfile returns a parsed response.
// GET /v1/ESimProfiles/{Sid}
func (c *Client) FetchEsimProfile(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchEsimProfileResponse, error) {
	req, err := newFetchEsimProfileRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchEsimProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupersimV1EsimProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListFleet: GET /v1/Fleets

type ListFleetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Fleets *[]SupersimV1Fleet `json:"fleets,omitempty"`
		Meta   *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListFleetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFleetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListFleetRequest generates requests for ListFleet
func newListFleetRequest(baseURL *url.URL, params *ListFleetParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListFleet)

	q := queryURL.Query()

	if params.NetworkAccessProfile != nil {
		if err := client.AddQueryParam(q, "NetworkAccessProfile", *params.NetworkAccessProfile); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListFleet returns a parsed response.
// GET /v1/Fleets
func (c *Client) ListFleet(ctx context.Context, params *ListFleetParams, reqEditors ...client.RequestEditorFn) (*ListFleetResponse, error) {
	req, err := newListFleetRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListFleetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Fleets *[]SupersimV1Fleet `json:"fleets,omitempty"`
			Meta   *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateFleet: POST /v1/Fleets

type CreateFleetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SupersimV1Fleet
}

// Status returns HTTPResponse.Status
func (r CreateFleetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFleetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateFleetRequestWithBody generates requests for CreateFleet with any type of body
func newCreateFleetRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateFleet)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateFleetWithBody returns a parsed response.
// POST /v1/Fleets
func (c *Client) CreateFleetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateFleetResponse, error) {
	req, err := newCreateFleetRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateFleetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SupersimV1Fleet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// FetchFleet: GET /v1/Fleets/{Sid}

type FetchFleetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupersimV1Fleet
}

// Status returns HTTPResponse.Status
func (r FetchFleetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchFleetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchFleetRequest generates requests for FetchFleet
func newFetchFleetRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchFleetFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchFleet returns a parsed response.
// GET /v1/Fleets/{Sid}
func (c *Client) FetchFleet(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchFleetResponse, error) {
	req, err := newFetchFleetRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchFleetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupersimV1Fleet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateFleet: POST /v1/Fleets/{Sid}

type UpdateFleetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupersimV1Fleet
}

// Status returns HTTPResponse.Status
func (r UpdateFleetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFleetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateFleetRequestWithBody generates requests for UpdateFleet with any type of body
func newUpdateFleetRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateFleetFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateFleetWithBody returns a parsed response.
// POST /v1/Fleets/{Sid}
func (c *Client) UpdateFleetWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateFleetResponse, error) {
	req, err := newUpdateFleetRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateFleetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupersimV1Fleet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListIpCommand: GET /v1/IpCommands

type ListIpCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IpCommands *[]SupersimV1IpCommand `json:"ip_commands,omitempty"`
		Meta       *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListIpCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIpCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListIpCommandRequest generates requests for ListIpCommand
func newListIpCommandRequest(baseURL *url.URL, params *ListIpCommandParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListIpCommand)

	q := queryURL.Query()

	if params.Sim != nil {
		if err := client.AddQueryParam(q, "Sim", *params.Sim); err != nil {
			return nil, err
		}
	}

	if params.SimIccid != nil {
		if err := client.AddQueryParam(q, "SimIccid", *params.SimIccid); err != nil {
			return nil, err
		}
	}

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.Direction != nil {
		if err := client.AddQueryParam(q, "Direction", *params.Direction); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListIpCommand returns a parsed response.
// GET /v1/IpCommands
func (c *Client) ListIpCommand(ctx context.Context, params *ListIpCommandParams, reqEditors ...client.RequestEditorFn) (*ListIpCommandResponse, error) {
	req, err := newListIpCommandRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListIpCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IpCommands *[]SupersimV1IpCommand `json:"ip_commands,omitempty"`
			Meta       *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateIpCommand: POST /v1/IpCommands

type CreateIpCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SupersimV1IpCommand
}

// Status returns HTTPResponse.Status
func (r CreateIpCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIpCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateIpCommandRequestWithBody generates requests for CreateIpCommand with any type of body
func newCreateIpCommandRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateIpCommand)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateIpCommandWithBody returns a parsed response.
// POST /v1/IpCommands
func (c *Client) CreateIpCommandWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateIpCommandResponse, error) {
	req, err := newCreateIpCommandRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateIpCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SupersimV1IpCommand
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// FetchIpCommand: GET /v1/IpCommands/{Sid}

type FetchIpCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupersimV1IpCommand
}

// Status returns HTTPResponse.Status
func (r FetchIpCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchIpCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchIpCommandRequest generates requests for FetchIpCommand
func newFetchIpCommandRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchIpCommandFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchIpCommand returns a parsed response.
// GET /v1/IpCommands/{Sid}
func (c *Client) FetchIpCommand(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchIpCommandResponse, error) {
	req, err := newFetchIpCommandRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchIpCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupersimV1IpCommand
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListNetworkAccessProfile: GET /v1/NetworkAccessProfiles

type ListNetworkAccessProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		NetworkAccessProfiles *[]SupersimV1NetworkAccessProfile `json:"network_access_profiles,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListNetworkAccessProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNetworkAccessProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListNetworkAccessProfileRequest generates requests for ListNetworkAccessProfile
func newListNetworkAccessProfileRequest(baseURL *url.URL, params *ListNetworkAccessProfileParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListNetworkAccessProfile)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListNetworkAccessProfile returns a parsed response.
// GET /v1/NetworkAccessProfiles
func (c *Client) ListNetworkAccessProfile(ctx context.Context, params *ListNetworkAccessProfileParams, reqEditors ...client.RequestEditorFn) (*ListNetworkAccessProfileResponse, error) {
	req, err := newListNetworkAccessProfileRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListNetworkAccessProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			NetworkAccessProfiles *[]SupersimV1NetworkAccessProfile `json:"network_access_profiles,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateNetworkAccessProfile: POST /v1/NetworkAccessProfiles

type CreateNetworkAccessProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SupersimV1NetworkAccessProfile
}

// Status returns HTTPResponse.Status
func (r CreateNetworkAccessProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNetworkAccessProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateNetworkAccessProfileRequestWithBody generates requests for CreateNetworkAccessProfile with any type of body
func newCreateNetworkAccessProfileRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateNetworkAccessProfile)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateNetworkAccessProfileWithBody returns a parsed response.
// POST /v1/NetworkAccessProfiles
func (c *Client) CreateNetworkAccessProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateNetworkAccessProfileResponse, error) {
	req, err := newCreateNetworkAccessProfileRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateNetworkAccessProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SupersimV1NetworkAccessProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListNetworkAccessProfileNetwork: GET /v1/NetworkAccessProfiles/{NetworkAccessProfileSid}/Networks

type ListNetworkAccessProfileNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Networks *[]SupersimV1NetworkAccessProfileNetworkAccessProfileNetwork `json:"networks,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListNetworkAccessProfileNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNetworkAccessProfileNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListNetworkAccessProfileNetworkRequest generates requests for ListNetworkAccessProfileNetwork
func newListNetworkAccessProfileNetworkRequest(baseURL *url.URL, networkAccessProfileSid string, params *ListNetworkAccessProfileNetworkParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("NetworkAccessProfileSid", networkAccessProfileSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListNetworkAccessProfileNetworkFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListNetworkAccessProfileNetwork returns a parsed response.
// GET /v1/NetworkAccessProfiles/{NetworkAccessProfileSid}/Networks
func (c *Client) ListNetworkAccessProfileNetwork(ctx context.Context, networkAccessProfileSid string, params *ListNetworkAccessProfileNetworkParams, reqEditors ...client.RequestEditorFn) (*ListNetworkAccessProfileNetworkResponse, error) {
	req, err := newListNetworkAccessProfileNetworkRequest(c.BaseURL, networkAccessProfileSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListNetworkAccessProfileNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Networks *[]SupersimV1NetworkAccessProfileNetworkAccessProfileNetwork `json:"networks,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateNetworkAccessProfileNetwork: POST /v1/NetworkAccessProfiles/{NetworkAccessProfileSid}/Networks

type CreateNetworkAccessProfileNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SupersimV1NetworkAccessProfileNetworkAccessProfileNetwork
}

// Status returns HTTPResponse.Status
func (r CreateNetworkAccessProfileNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNetworkAccessProfileNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateNetworkAccessProfileNetworkRequestWithBody generates requests for CreateNetworkAccessProfileNetwork with any type of body
func newCreateNetworkAccessProfileNetworkRequestWithBody(baseURL *url.URL, networkAccessProfileSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("NetworkAccessProfileSid", networkAccessProfileSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateNetworkAccessProfileNetworkFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateNetworkAccessProfileNetworkWithBody returns a parsed response.
// POST /v1/NetworkAccessProfiles/{NetworkAccessProfileSid}/Networks
func (c *Client) CreateNetworkAccessProfileNetworkWithBody(ctx context.Context, networkAccessProfileSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateNetworkAccessProfileNetworkResponse, error) {
	req, err := newCreateNetworkAccessProfileNetworkRequestWithBody(c.BaseURL, networkAccessProfileSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateNetworkAccessProfileNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SupersimV1NetworkAccessProfileNetworkAccessProfileNetwork
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteNetworkAccessProfileNetwork: DELETE /v1/NetworkAccessProfiles/{NetworkAccessProfileSid}/Networks/{Sid}

type DeleteNetworkAccessProfileNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteNetworkAccessProfileNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNetworkAccessProfileNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteNetworkAccessProfileNetworkRequest generates requests for DeleteNetworkAccessProfileNetwork
func newDeleteNetworkAccessProfileNetworkRequest(baseURL *url.URL, networkAccessProfileSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("NetworkAccessProfileSid", networkAccessProfileSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteNetworkAccessProfileNetworkFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteNetworkAccessProfileNetwork returns a parsed response.
// DELETE /v1/NetworkAccessProfiles/{NetworkAccessProfileSid}/Networks/{Sid}
func (c *Client) DeleteNetworkAccessProfileNetwork(ctx context.Context, networkAccessProfileSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteNetworkAccessProfileNetworkResponse, error) {
	req, err := newDeleteNetworkAccessProfileNetworkRequest(c.BaseURL, networkAccessProfileSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteNetworkAccessProfileNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchNetworkAccessProfileNetwork: GET /v1/NetworkAccessProfiles/{NetworkAccessProfileSid}/Networks/{Sid}

type FetchNetworkAccessProfileNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupersimV1NetworkAccessProfileNetworkAccessProfileNetwork
}

// Status returns HTTPResponse.Status
func (r FetchNetworkAccessProfileNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchNetworkAccessProfileNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchNetworkAccessProfileNetworkRequest generates requests for FetchNetworkAccessProfileNetwork
func newFetchNetworkAccessProfileNetworkRequest(baseURL *url.URL, networkAccessProfileSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("NetworkAccessProfileSid", networkAccessProfileSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchNetworkAccessProfileNetworkFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchNetworkAccessProfileNetwork returns a parsed response.
// GET /v1/NetworkAccessProfiles/{NetworkAccessProfileSid}/Networks/{Sid}
func (c *Client) FetchNetworkAccessProfileNetwork(ctx context.Context, networkAccessProfileSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchNetworkAccessProfileNetworkResponse, error) {
	req, err := newFetchNetworkAccessProfileNetworkRequest(c.BaseURL, networkAccessProfileSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchNetworkAccessProfileNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupersimV1NetworkAccessProfileNetworkAccessProfileNetwork
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchNetworkAccessProfile: GET /v1/NetworkAccessProfiles/{Sid}

type FetchNetworkAccessProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupersimV1NetworkAccessProfile
}

// Status returns HTTPResponse.Status
func (r FetchNetworkAccessProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchNetworkAccessProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchNetworkAccessProfileRequest generates requests for FetchNetworkAccessProfile
func newFetchNetworkAccessProfileRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchNetworkAccessProfileFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchNetworkAccessProfile returns a parsed response.
// GET /v1/NetworkAccessProfiles/{Sid}
func (c *Client) FetchNetworkAccessProfile(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchNetworkAccessProfileResponse, error) {
	req, err := newFetchNetworkAccessProfileRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchNetworkAccessProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupersimV1NetworkAccessProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateNetworkAccessProfile: POST /v1/NetworkAccessProfiles/{Sid}

type UpdateNetworkAccessProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupersimV1NetworkAccessProfile
}

// Status returns HTTPResponse.Status
func (r UpdateNetworkAccessProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNetworkAccessProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateNetworkAccessProfileRequestWithBody generates requests for UpdateNetworkAccessProfile with any type of body
func newUpdateNetworkAccessProfileRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateNetworkAccessProfileFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateNetworkAccessProfileWithBody returns a parsed response.
// POST /v1/NetworkAccessProfiles/{Sid}
func (c *Client) UpdateNetworkAccessProfileWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateNetworkAccessProfileResponse, error) {
	req, err := newUpdateNetworkAccessProfileRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateNetworkAccessProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupersimV1NetworkAccessProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListNetwork: GET /v1/Networks

type ListNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Networks *[]SupersimV1Network `json:"networks,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListNetworkRequest generates requests for ListNetwork
func newListNetworkRequest(baseURL *url.URL, params *ListNetworkParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListNetwork)

	q := queryURL.Query()

	if params.IsoCountry != nil {
		if err := client.AddQueryParam(q, "IsoCountry", *params.IsoCountry); err != nil {
			return nil, err
		}
	}

	if params.Mcc != nil {
		if err := client.AddQueryParam(q, "Mcc", *params.Mcc); err != nil {
			return nil, err
		}
	}

	if params.Mnc != nil {
		if err := client.AddQueryParam(q, "Mnc", *params.Mnc); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListNetwork returns a parsed response.
// GET /v1/Networks
func (c *Client) ListNetwork(ctx context.Context, params *ListNetworkParams, reqEditors ...client.RequestEditorFn) (*ListNetworkResponse, error) {
	req, err := newListNetworkRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Networks *[]SupersimV1Network `json:"networks,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchNetwork: GET /v1/Networks/{Sid}

type FetchNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupersimV1Network
}

// Status returns HTTPResponse.Status
func (r FetchNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchNetworkRequest generates requests for FetchNetwork
func newFetchNetworkRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchNetworkFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchNetwork returns a parsed response.
// GET /v1/Networks/{Sid}
func (c *Client) FetchNetwork(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchNetworkResponse, error) {
	req, err := newFetchNetworkRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupersimV1Network
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSim: GET /v1/Sims

type ListSimResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Sims *[]SupersimV1Sim `json:"sims,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSimResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSimResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSimRequest generates requests for ListSim
func newListSimRequest(baseURL *url.URL, params *ListSimParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListSim)

	q := queryURL.Query()

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.Fleet != nil {
		if err := client.AddQueryParam(q, "Fleet", *params.Fleet); err != nil {
			return nil, err
		}
	}

	if params.Iccid != nil {
		if err := client.AddQueryParam(q, "Iccid", *params.Iccid); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSim returns a parsed response.
// GET /v1/Sims
func (c *Client) ListSim(ctx context.Context, params *ListSimParams, reqEditors ...client.RequestEditorFn) (*ListSimResponse, error) {
	req, err := newListSimRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSimResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Sims *[]SupersimV1Sim `json:"sims,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSim: POST /v1/Sims

type CreateSimResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SupersimV1Sim
}

// Status returns HTTPResponse.Status
func (r CreateSimResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSimResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSimRequestWithBody generates requests for CreateSim with any type of body
func newCreateSimRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateSim)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSimWithBody returns a parsed response.
// POST /v1/Sims
func (c *Client) CreateSimWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSimResponse, error) {
	req, err := newCreateSimRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSimResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SupersimV1Sim
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// FetchSim: GET /v1/Sims/{Sid}

type FetchSimResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupersimV1Sim
}

// Status returns HTTPResponse.Status
func (r FetchSimResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSimResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSimRequest generates requests for FetchSim
func newFetchSimRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSimFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSim returns a parsed response.
// GET /v1/Sims/{Sid}
func (c *Client) FetchSim(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchSimResponse, error) {
	req, err := newFetchSimRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSimResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupersimV1Sim
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSim: POST /v1/Sims/{Sid}

type UpdateSimResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupersimV1Sim
	JSON202      *SupersimV1Sim
}

// Status returns HTTPResponse.Status
func (r UpdateSimResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSimResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSimRequestWithBody generates requests for UpdateSim with any type of body
func newUpdateSimRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSimFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSimWithBody returns a parsed response.
// POST /v1/Sims/{Sid}
func (c *Client) UpdateSimWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSimResponse, error) {
	req, err := newUpdateSimRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSimResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupersimV1Sim
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SupersimV1Sim
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ListBillingPeriod: GET /v1/Sims/{SimSid}/BillingPeriods

type ListBillingPeriodResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		BillingPeriods *[]SupersimV1SimBillingPeriod `json:"billing_periods,omitempty"`
		Meta           *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListBillingPeriodResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBillingPeriodResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListBillingPeriodRequest generates requests for ListBillingPeriod
func newListBillingPeriodRequest(baseURL *url.URL, simSid string, params *ListBillingPeriodParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("SimSid", simSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListBillingPeriodFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListBillingPeriod returns a parsed response.
// GET /v1/Sims/{SimSid}/BillingPeriods
func (c *Client) ListBillingPeriod(ctx context.Context, simSid string, params *ListBillingPeriodParams, reqEditors ...client.RequestEditorFn) (*ListBillingPeriodResponse, error) {
	req, err := newListBillingPeriodRequest(c.BaseURL, simSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListBillingPeriodResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			BillingPeriods *[]SupersimV1SimBillingPeriod `json:"billing_periods,omitempty"`
			Meta           *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSmsCommand: GET /v1/SmsCommands

type ListSmsCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		SmsCommands *[]SupersimV1SmsCommand `json:"sms_commands,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSmsCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSmsCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSmsCommandRequest generates requests for ListSmsCommand
func newListSmsCommandRequest(baseURL *url.URL, params *ListSmsCommandParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListSmsCommand)

	q := queryURL.Query()

	if params.Sim != nil {
		if err := client.AddQueryParam(q, "Sim", *params.Sim); err != nil {
			return nil, err
		}
	}

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.Direction != nil {
		if err := client.AddQueryParam(q, "Direction", *params.Direction); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSmsCommand returns a parsed response.
// GET /v1/SmsCommands
func (c *Client) ListSmsCommand(ctx context.Context, params *ListSmsCommandParams, reqEditors ...client.RequestEditorFn) (*ListSmsCommandResponse, error) {
	req, err := newListSmsCommandRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSmsCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			SmsCommands *[]SupersimV1SmsCommand `json:"sms_commands,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSmsCommand: POST /v1/SmsCommands

type CreateSmsCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SupersimV1SmsCommand
}

// Status returns HTTPResponse.Status
func (r CreateSmsCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSmsCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSmsCommandRequestWithBody generates requests for CreateSmsCommand with any type of body
func newCreateSmsCommandRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateSmsCommand)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSmsCommandWithBody returns a parsed response.
// POST /v1/SmsCommands
func (c *Client) CreateSmsCommandWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSmsCommandResponse, error) {
	req, err := newCreateSmsCommandRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSmsCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SupersimV1SmsCommand
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// FetchSmsCommand: GET /v1/SmsCommands/{Sid}

type FetchSmsCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupersimV1SmsCommand
}

// Status returns HTTPResponse.Status
func (r FetchSmsCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSmsCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSmsCommandRequest generates requests for FetchSmsCommand
func newFetchSmsCommandRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSmsCommandFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSmsCommand returns a parsed response.
// GET /v1/SmsCommands/{Sid}
func (c *Client) FetchSmsCommand(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchSmsCommandResponse, error) {
	req, err := newFetchSmsCommandRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSmsCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupersimV1SmsCommand
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListUsageRecord: GET /v1/UsageRecords

type ListUsageRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		UsageRecords *[]SupersimV1UsageRecord `json:"usage_records,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUsageRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsageRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListUsageRecordRequest generates requests for ListUsageRecord
func newListUsageRecordRequest(baseURL *url.URL, params *ListUsageRecordParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListUsageRecord)

	q := queryURL.Query()

	if params.Sim != nil {
		if err := client.AddQueryParam(q, "Sim", *params.Sim); err != nil {
			return nil, err
		}
	}

	if params.Fleet != nil {
		if err := client.AddQueryParam(q, "Fleet", *params.Fleet); err != nil {
			return nil, err
		}
	}

	if params.Network != nil {
		if err := client.AddQueryParam(q, "Network", *params.Network); err != nil {
			return nil, err
		}
	}

	if params.IsoCountry != nil {
		if err := client.AddQueryParam(q, "IsoCountry", *params.IsoCountry); err != nil {
			return nil, err
		}
	}

	if params.Group != nil {
		if err := client.AddQueryParam(q, "Group", *params.Group); err != nil {
			return nil, err
		}
	}

	if params.Granularity != nil {
		if err := client.AddQueryParam(q, "Granularity", *params.Granularity); err != nil {
			return nil, err
		}
	}

	if params.StartTime != nil {
		if err := client.AddQueryParam(q, "StartTime", *params.StartTime); err != nil {
			return nil, err
		}
	}

	if params.EndTime != nil {
		if err := client.AddQueryParam(q, "EndTime", *params.EndTime); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListUsageRecord returns a parsed response.
// GET /v1/UsageRecords
func (c *Client) ListUsageRecord(ctx context.Context, params *ListUsageRecordParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordResponse, error) {
	req, err := newListUsageRecordRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListUsageRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			UsageRecords *[]SupersimV1UsageRecord `json:"usage_records,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
