// Package studio provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package studio

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/faetools/client"
)

// operation paths

const (
	opPathListExecutionFormat             = "./v2/Flows/%s/Executions"
	opPathCreateExecutionFormat           = "./v2/Flows/%s/Executions"
	opPathFetchExecutionContextFormat     = "./v2/Flows/%s/Executions/%s/Context"
	opPathListExecutionStepFormat         = "./v2/Flows/%s/Executions/%s/Steps"
	opPathFetchExecutionStepFormat        = "./v2/Flows/%s/Executions/%s/Steps/%s"
	opPathFetchExecutionStepContextFormat = "./v2/Flows/%s/Executions/%s/Steps/%s/Context"
	opPathDeleteExecutionFormat           = "./v2/Flows/%s/Executions/%s"
	opPathFetchExecutionFormat            = "./v2/Flows/%s/Executions/%s"
	opPathUpdateExecutionFormat           = "./v2/Flows/%s/Executions/%s"
	opPathDeleteFlowFormat                = "./v2/Flows/%s"
	opPathFetchFlowFormat                 = "./v2/Flows/%s"
	opPathUpdateFlowFormat                = "./v2/Flows/%s"
	opPathListFlowRevisionFormat          = "./v2/Flows/%s/Revisions"
	opPathFetchFlowRevisionFormat         = "./v2/Flows/%s/Revisions/%s"
	opPathFetchTestUserFormat             = "./v2/Flows/%s/TestUsers"
	opPathUpdateTestUserFormat            = "./v2/Flows/%s/TestUsers"
)

var (
	opPathListFlow           = client.MustParseURL("./v2/Flows")
	opPathCreateFlow         = client.MustParseURL("./v2/Flows")
	opPathUpdateFlowValidate = client.MustParseURL("./v2/Flows/Validate")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// ListFlow request
	ListFlow(ctx context.Context, params *ListFlowParams, reqEditors ...client.RequestEditorFn) (*ListFlowResponse, error)

	// CreateFlow request with any body
	CreateFlowWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateFlowResponse, error)

	// UpdateFlowValidate request with any body
	UpdateFlowValidateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateFlowValidateResponse, error)

	// ListExecution request
	ListExecution(ctx context.Context, flowSid string, params *ListExecutionParams, reqEditors ...client.RequestEditorFn) (*ListExecutionResponse, error)

	// CreateExecution request with any body
	CreateExecutionWithBody(ctx context.Context, flowSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateExecutionResponse, error)

	// FetchExecutionContext request
	FetchExecutionContext(ctx context.Context, flowSid string, executionSid string, reqEditors ...client.RequestEditorFn) (*FetchExecutionContextResponse, error)

	// ListExecutionStep request
	ListExecutionStep(ctx context.Context, flowSid string, executionSid string, params *ListExecutionStepParams, reqEditors ...client.RequestEditorFn) (*ListExecutionStepResponse, error)

	// FetchExecutionStep request
	FetchExecutionStep(ctx context.Context, flowSid string, executionSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchExecutionStepResponse, error)

	// FetchExecutionStepContext request
	FetchExecutionStepContext(ctx context.Context, flowSid string, executionSid string, stepSid string, reqEditors ...client.RequestEditorFn) (*FetchExecutionStepContextResponse, error)

	// DeleteExecution request
	DeleteExecution(ctx context.Context, flowSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteExecutionResponse, error)

	// FetchExecution request
	FetchExecution(ctx context.Context, flowSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchExecutionResponse, error)

	// UpdateExecution request with any body
	UpdateExecutionWithBody(ctx context.Context, flowSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateExecutionResponse, error)

	// DeleteFlow request
	DeleteFlow(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteFlowResponse, error)

	// FetchFlow request
	FetchFlow(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchFlowResponse, error)

	// UpdateFlow request with any body
	UpdateFlowWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateFlowResponse, error)

	// ListFlowRevision request
	ListFlowRevision(ctx context.Context, sid string, params *ListFlowRevisionParams, reqEditors ...client.RequestEditorFn) (*ListFlowRevisionResponse, error)

	// FetchFlowRevision request
	FetchFlowRevision(ctx context.Context, sid string, revision string, reqEditors ...client.RequestEditorFn) (*FetchFlowRevisionResponse, error)

	// FetchTestUser request
	FetchTestUser(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchTestUserResponse, error)

	// UpdateTestUser request with any body
	UpdateTestUserWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateTestUserResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// ListFlow: GET /v2/Flows

type ListFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Flows *[]StudioV2Flow `json:"flows,omitempty"`
		Meta  *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListFlowRequest generates requests for ListFlow
func newListFlowRequest(baseURL *url.URL, params *ListFlowParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListFlow)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListFlow returns a parsed response.
// GET /v2/Flows
func (c *Client) ListFlow(ctx context.Context, params *ListFlowParams, reqEditors ...client.RequestEditorFn) (*ListFlowResponse, error) {
	req, err := newListFlowRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Flows *[]StudioV2Flow `json:"flows,omitempty"`
			Meta  *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateFlow: POST /v2/Flows

type CreateFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *StudioV2Flow
}

// Status returns HTTPResponse.Status
func (r CreateFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateFlowRequestWithBody generates requests for CreateFlow with any type of body
func newCreateFlowRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateFlow)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateFlowWithBody returns a parsed response.
// POST /v2/Flows
func (c *Client) CreateFlowWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateFlowResponse, error) {
	req, err := newCreateFlowRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest StudioV2Flow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// UpdateFlowValidate: POST /v2/Flows/Validate

type UpdateFlowValidateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StudioV2FlowValidate
}

// Status returns HTTPResponse.Status
func (r UpdateFlowValidateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFlowValidateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateFlowValidateRequestWithBody generates requests for UpdateFlowValidate with any type of body
func newUpdateFlowValidateRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathUpdateFlowValidate)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateFlowValidateWithBody returns a parsed response.
// POST /v2/Flows/Validate
func (c *Client) UpdateFlowValidateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateFlowValidateResponse, error) {
	req, err := newUpdateFlowValidateRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateFlowValidateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StudioV2FlowValidate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListExecution: GET /v2/Flows/{FlowSid}/Executions

type ListExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Executions *[]StudioV2FlowExecution `json:"executions,omitempty"`
		Meta       *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListExecutionRequest generates requests for ListExecution
func newListExecutionRequest(baseURL *url.URL, flowSid string, params *ListExecutionParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("FlowSid", flowSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListExecutionFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.DateCreatedFrom != nil {
		if err := client.AddQueryParam(q, "DateCreatedFrom", *params.DateCreatedFrom); err != nil {
			return nil, err
		}
	}

	if params.DateCreatedTo != nil {
		if err := client.AddQueryParam(q, "DateCreatedTo", *params.DateCreatedTo); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListExecution returns a parsed response.
// GET /v2/Flows/{FlowSid}/Executions
func (c *Client) ListExecution(ctx context.Context, flowSid string, params *ListExecutionParams, reqEditors ...client.RequestEditorFn) (*ListExecutionResponse, error) {
	req, err := newListExecutionRequest(c.BaseURL, flowSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Executions *[]StudioV2FlowExecution `json:"executions,omitempty"`
			Meta       *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateExecution: POST /v2/Flows/{FlowSid}/Executions

type CreateExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *StudioV2FlowExecution
}

// Status returns HTTPResponse.Status
func (r CreateExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateExecutionRequestWithBody generates requests for CreateExecution with any type of body
func newCreateExecutionRequestWithBody(baseURL *url.URL, flowSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("FlowSid", flowSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateExecutionFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateExecutionWithBody returns a parsed response.
// POST /v2/Flows/{FlowSid}/Executions
func (c *Client) CreateExecutionWithBody(ctx context.Context, flowSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateExecutionResponse, error) {
	req, err := newCreateExecutionRequestWithBody(c.BaseURL, flowSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest StudioV2FlowExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// FetchExecutionContext: GET /v2/Flows/{FlowSid}/Executions/{ExecutionSid}/Context

type FetchExecutionContextResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StudioV2FlowExecutionExecutionContext
}

// Status returns HTTPResponse.Status
func (r FetchExecutionContextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchExecutionContextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchExecutionContextRequest generates requests for FetchExecutionContext
func newFetchExecutionContextRequest(baseURL *url.URL, flowSid string, executionSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("FlowSid", flowSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ExecutionSid", executionSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchExecutionContextFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchExecutionContext returns a parsed response.
// GET /v2/Flows/{FlowSid}/Executions/{ExecutionSid}/Context
func (c *Client) FetchExecutionContext(ctx context.Context, flowSid string, executionSid string, reqEditors ...client.RequestEditorFn) (*FetchExecutionContextResponse, error) {
	req, err := newFetchExecutionContextRequest(c.BaseURL, flowSid, executionSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchExecutionContextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StudioV2FlowExecutionExecutionContext
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListExecutionStep: GET /v2/Flows/{FlowSid}/Executions/{ExecutionSid}/Steps

type ListExecutionStepResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Steps *[]StudioV2FlowExecutionExecutionStep `json:"steps,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListExecutionStepResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListExecutionStepResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListExecutionStepRequest generates requests for ListExecutionStep
func newListExecutionStepRequest(baseURL *url.URL, flowSid string, executionSid string, params *ListExecutionStepParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("FlowSid", flowSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ExecutionSid", executionSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListExecutionStepFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListExecutionStep returns a parsed response.
// GET /v2/Flows/{FlowSid}/Executions/{ExecutionSid}/Steps
func (c *Client) ListExecutionStep(ctx context.Context, flowSid string, executionSid string, params *ListExecutionStepParams, reqEditors ...client.RequestEditorFn) (*ListExecutionStepResponse, error) {
	req, err := newListExecutionStepRequest(c.BaseURL, flowSid, executionSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListExecutionStepResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Steps *[]StudioV2FlowExecutionExecutionStep `json:"steps,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchExecutionStep: GET /v2/Flows/{FlowSid}/Executions/{ExecutionSid}/Steps/{Sid}

type FetchExecutionStepResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StudioV2FlowExecutionExecutionStep
}

// Status returns HTTPResponse.Status
func (r FetchExecutionStepResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchExecutionStepResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchExecutionStepRequest generates requests for FetchExecutionStep
func newFetchExecutionStepRequest(baseURL *url.URL, flowSid string, executionSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("FlowSid", flowSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ExecutionSid", executionSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchExecutionStepFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchExecutionStep returns a parsed response.
// GET /v2/Flows/{FlowSid}/Executions/{ExecutionSid}/Steps/{Sid}
func (c *Client) FetchExecutionStep(ctx context.Context, flowSid string, executionSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchExecutionStepResponse, error) {
	req, err := newFetchExecutionStepRequest(c.BaseURL, flowSid, executionSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchExecutionStepResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StudioV2FlowExecutionExecutionStep
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchExecutionStepContext: GET /v2/Flows/{FlowSid}/Executions/{ExecutionSid}/Steps/{StepSid}/Context

type FetchExecutionStepContextResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StudioV2FlowExecutionExecutionStepExecutionStepContext
}

// Status returns HTTPResponse.Status
func (r FetchExecutionStepContextResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchExecutionStepContextResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchExecutionStepContextRequest generates requests for FetchExecutionStepContext
func newFetchExecutionStepContextRequest(baseURL *url.URL, flowSid string, executionSid string, stepSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("FlowSid", flowSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ExecutionSid", executionSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("StepSid", stepSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchExecutionStepContextFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchExecutionStepContext returns a parsed response.
// GET /v2/Flows/{FlowSid}/Executions/{ExecutionSid}/Steps/{StepSid}/Context
func (c *Client) FetchExecutionStepContext(ctx context.Context, flowSid string, executionSid string, stepSid string, reqEditors ...client.RequestEditorFn) (*FetchExecutionStepContextResponse, error) {
	req, err := newFetchExecutionStepContextRequest(c.BaseURL, flowSid, executionSid, stepSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchExecutionStepContextResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StudioV2FlowExecutionExecutionStepExecutionStepContext
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteExecution: DELETE /v2/Flows/{FlowSid}/Executions/{Sid}

type DeleteExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteExecutionRequest generates requests for DeleteExecution
func newDeleteExecutionRequest(baseURL *url.URL, flowSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("FlowSid", flowSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteExecutionFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteExecution returns a parsed response.
// DELETE /v2/Flows/{FlowSid}/Executions/{Sid}
func (c *Client) DeleteExecution(ctx context.Context, flowSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteExecutionResponse, error) {
	req, err := newDeleteExecutionRequest(c.BaseURL, flowSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchExecution: GET /v2/Flows/{FlowSid}/Executions/{Sid}

type FetchExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StudioV2FlowExecution
}

// Status returns HTTPResponse.Status
func (r FetchExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchExecutionRequest generates requests for FetchExecution
func newFetchExecutionRequest(baseURL *url.URL, flowSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("FlowSid", flowSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchExecutionFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchExecution returns a parsed response.
// GET /v2/Flows/{FlowSid}/Executions/{Sid}
func (c *Client) FetchExecution(ctx context.Context, flowSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchExecutionResponse, error) {
	req, err := newFetchExecutionRequest(c.BaseURL, flowSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StudioV2FlowExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateExecution: POST /v2/Flows/{FlowSid}/Executions/{Sid}

type UpdateExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StudioV2FlowExecution
}

// Status returns HTTPResponse.Status
func (r UpdateExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateExecutionRequestWithBody generates requests for UpdateExecution with any type of body
func newUpdateExecutionRequestWithBody(baseURL *url.URL, flowSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("FlowSid", flowSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateExecutionFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateExecutionWithBody returns a parsed response.
// POST /v2/Flows/{FlowSid}/Executions/{Sid}
func (c *Client) UpdateExecutionWithBody(ctx context.Context, flowSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateExecutionResponse, error) {
	req, err := newUpdateExecutionRequestWithBody(c.BaseURL, flowSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StudioV2FlowExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteFlow: DELETE /v2/Flows/{Sid}

type DeleteFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteFlowRequest generates requests for DeleteFlow
func newDeleteFlowRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteFlowFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteFlow returns a parsed response.
// DELETE /v2/Flows/{Sid}
func (c *Client) DeleteFlow(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteFlowResponse, error) {
	req, err := newDeleteFlowRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchFlow: GET /v2/Flows/{Sid}

type FetchFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StudioV2Flow
}

// Status returns HTTPResponse.Status
func (r FetchFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchFlowRequest generates requests for FetchFlow
func newFetchFlowRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchFlowFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchFlow returns a parsed response.
// GET /v2/Flows/{Sid}
func (c *Client) FetchFlow(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchFlowResponse, error) {
	req, err := newFetchFlowRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StudioV2Flow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateFlow: POST /v2/Flows/{Sid}

type UpdateFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StudioV2Flow
}

// Status returns HTTPResponse.Status
func (r UpdateFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateFlowRequestWithBody generates requests for UpdateFlow with any type of body
func newUpdateFlowRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateFlowFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateFlowWithBody returns a parsed response.
// POST /v2/Flows/{Sid}
func (c *Client) UpdateFlowWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateFlowResponse, error) {
	req, err := newUpdateFlowRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StudioV2Flow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListFlowRevision: GET /v2/Flows/{Sid}/Revisions

type ListFlowRevisionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Revisions *[]StudioV2FlowFlowRevision `json:"revisions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListFlowRevisionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFlowRevisionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListFlowRevisionRequest generates requests for ListFlowRevision
func newListFlowRevisionRequest(baseURL *url.URL, sid string, params *ListFlowRevisionParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListFlowRevisionFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListFlowRevision returns a parsed response.
// GET /v2/Flows/{Sid}/Revisions
func (c *Client) ListFlowRevision(ctx context.Context, sid string, params *ListFlowRevisionParams, reqEditors ...client.RequestEditorFn) (*ListFlowRevisionResponse, error) {
	req, err := newListFlowRevisionRequest(c.BaseURL, sid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListFlowRevisionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Revisions *[]StudioV2FlowFlowRevision `json:"revisions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchFlowRevision: GET /v2/Flows/{Sid}/Revisions/{Revision}

type FetchFlowRevisionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StudioV2FlowFlowRevision
}

// Status returns HTTPResponse.Status
func (r FetchFlowRevisionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchFlowRevisionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchFlowRevisionRequest generates requests for FetchFlowRevision
func newFetchFlowRevisionRequest(baseURL *url.URL, sid string, revision string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Revision", revision)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchFlowRevisionFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchFlowRevision returns a parsed response.
// GET /v2/Flows/{Sid}/Revisions/{Revision}
func (c *Client) FetchFlowRevision(ctx context.Context, sid string, revision string, reqEditors ...client.RequestEditorFn) (*FetchFlowRevisionResponse, error) {
	req, err := newFetchFlowRevisionRequest(c.BaseURL, sid, revision)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchFlowRevisionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StudioV2FlowFlowRevision
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchTestUser: GET /v2/Flows/{Sid}/TestUsers

type FetchTestUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StudioV2FlowTestUser
}

// Status returns HTTPResponse.Status
func (r FetchTestUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTestUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchTestUserRequest generates requests for FetchTestUser
func newFetchTestUserRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchTestUserFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchTestUser returns a parsed response.
// GET /v2/Flows/{Sid}/TestUsers
func (c *Client) FetchTestUser(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchTestUserResponse, error) {
	req, err := newFetchTestUserRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchTestUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StudioV2FlowTestUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateTestUser: POST /v2/Flows/{Sid}/TestUsers

type UpdateTestUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StudioV2FlowTestUser
}

// Status returns HTTPResponse.Status
func (r UpdateTestUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTestUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateTestUserRequestWithBody generates requests for UpdateTestUser with any type of body
func newUpdateTestUserRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateTestUserFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateTestUserWithBody returns a parsed response.
// POST /v2/Flows/{Sid}/TestUsers
func (c *Client) UpdateTestUserWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateTestUserResponse, error) {
	req, err := newUpdateTestUserRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateTestUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StudioV2FlowTestUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
