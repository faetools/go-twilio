// Package verify provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package verify

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/faetools/client"
)

// operation paths

const (
	opPathFetchVerificationAttemptFormat     = "./v2/Attempts/%s"
	opPathFetchFormFormat                    = "./v2/Forms/%s"
	opPathCreateAccessTokenFormat            = "./v2/Services/%s/AccessTokens"
	opPathFetchAccessTokenFormat             = "./v2/Services/%s/AccessTokens/%s"
	opPathListEntityFormat                   = "./v2/Services/%s/Entities"
	opPathCreateEntityFormat                 = "./v2/Services/%s/Entities"
	opPathDeleteEntityFormat                 = "./v2/Services/%s/Entities/%s"
	opPathFetchEntityFormat                  = "./v2/Services/%s/Entities/%s"
	opPathListChallengeFormat                = "./v2/Services/%s/Entities/%s/Challenges"
	opPathCreateChallengeFormat              = "./v2/Services/%s/Entities/%s/Challenges"
	opPathCreateNotificationFormat           = "./v2/Services/%s/Entities/%s/Challenges/%s/Notifications"
	opPathFetchChallengeFormat               = "./v2/Services/%s/Entities/%s/Challenges/%s"
	opPathUpdateChallengeFormat              = "./v2/Services/%s/Entities/%s/Challenges/%s"
	opPathListFactorFormat                   = "./v2/Services/%s/Entities/%s/Factors"
	opPathCreateNewFactorFormat              = "./v2/Services/%s/Entities/%s/Factors"
	opPathDeleteFactorFormat                 = "./v2/Services/%s/Entities/%s/Factors/%s"
	opPathFetchFactorFormat                  = "./v2/Services/%s/Entities/%s/Factors/%s"
	opPathUpdateFactorFormat                 = "./v2/Services/%s/Entities/%s/Factors/%s"
	opPathListMessagingConfigurationFormat   = "./v2/Services/%s/MessagingConfigurations"
	opPathCreateMessagingConfigurationFormat = "./v2/Services/%s/MessagingConfigurations"
	opPathDeleteMessagingConfigurationFormat = "./v2/Services/%s/MessagingConfigurations/%s"
	opPathFetchMessagingConfigurationFormat  = "./v2/Services/%s/MessagingConfigurations/%s"
	opPathUpdateMessagingConfigurationFormat = "./v2/Services/%s/MessagingConfigurations/%s"
	opPathListRateLimitFormat                = "./v2/Services/%s/RateLimits"
	opPathCreateRateLimitFormat              = "./v2/Services/%s/RateLimits"
	opPathListBucketFormat                   = "./v2/Services/%s/RateLimits/%s/Buckets"
	opPathCreateBucketFormat                 = "./v2/Services/%s/RateLimits/%s/Buckets"
	opPathDeleteBucketFormat                 = "./v2/Services/%s/RateLimits/%s/Buckets/%s"
	opPathFetchBucketFormat                  = "./v2/Services/%s/RateLimits/%s/Buckets/%s"
	opPathUpdateBucketFormat                 = "./v2/Services/%s/RateLimits/%s/Buckets/%s"
	opPathDeleteRateLimitFormat              = "./v2/Services/%s/RateLimits/%s"
	opPathFetchRateLimitFormat               = "./v2/Services/%s/RateLimits/%s"
	opPathUpdateRateLimitFormat              = "./v2/Services/%s/RateLimits/%s"
	opPathCreateVerificationCheckFormat      = "./v2/Services/%s/VerificationCheck"
	opPathCreateVerificationFormat           = "./v2/Services/%s/Verifications"
	opPathFetchVerificationFormat            = "./v2/Services/%s/Verifications/%s"
	opPathUpdateVerificationFormat           = "./v2/Services/%s/Verifications/%s"
	opPathListWebhookFormat                  = "./v2/Services/%s/Webhooks"
	opPathCreateWebhookFormat                = "./v2/Services/%s/Webhooks"
	opPathDeleteWebhookFormat                = "./v2/Services/%s/Webhooks/%s"
	opPathFetchWebhookFormat                 = "./v2/Services/%s/Webhooks/%s"
	opPathUpdateWebhookFormat                = "./v2/Services/%s/Webhooks/%s"
	opPathDeleteServiceFormat                = "./v2/Services/%s"
	opPathFetchServiceFormat                 = "./v2/Services/%s"
	opPathUpdateServiceFormat                = "./v2/Services/%s"
)

var (
	opPathListVerificationAttempt  = client.MustParseURL("./v2/Attempts")
	opPathListService              = client.MustParseURL("./v2/Services")
	opPathCreateService            = client.MustParseURL("./v2/Services")
	opPathListVerificationTemplate = client.MustParseURL("./v2/Templates")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// ListVerificationAttempt request
	ListVerificationAttempt(ctx context.Context, params *ListVerificationAttemptParams, reqEditors ...client.RequestEditorFn) (*ListVerificationAttemptResponse, error)

	// FetchVerificationAttempt request
	FetchVerificationAttempt(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchVerificationAttemptResponse, error)

	// FetchForm request
	FetchForm(ctx context.Context, formType FetchFormParamsFormType, reqEditors ...client.RequestEditorFn) (*FetchFormResponse, error)

	// ListService request
	ListService(ctx context.Context, params *ListServiceParams, reqEditors ...client.RequestEditorFn) (*ListServiceResponse, error)

	// CreateService request with any body
	CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceResponse, error)

	// CreateAccessToken request with any body
	CreateAccessTokenWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateAccessTokenResponse, error)

	// FetchAccessToken request
	FetchAccessToken(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchAccessTokenResponse, error)

	// ListEntity request
	ListEntity(ctx context.Context, serviceSid string, params *ListEntityParams, reqEditors ...client.RequestEditorFn) (*ListEntityResponse, error)

	// CreateEntity request with any body
	CreateEntityWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateEntityResponse, error)

	// DeleteEntity request
	DeleteEntity(ctx context.Context, serviceSid string, identity string, reqEditors ...client.RequestEditorFn) (*DeleteEntityResponse, error)

	// FetchEntity request
	FetchEntity(ctx context.Context, serviceSid string, identity string, reqEditors ...client.RequestEditorFn) (*FetchEntityResponse, error)

	// ListChallenge request
	ListChallenge(ctx context.Context, serviceSid string, identity string, params *ListChallengeParams, reqEditors ...client.RequestEditorFn) (*ListChallengeResponse, error)

	// CreateChallenge request with any body
	CreateChallengeWithBody(ctx context.Context, serviceSid string, identity string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateChallengeResponse, error)

	// CreateNotification request with any body
	CreateNotificationWithBody(ctx context.Context, serviceSid string, identity string, challengeSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateNotificationResponse, error)

	// FetchChallenge request
	FetchChallenge(ctx context.Context, serviceSid string, identity string, sid string, reqEditors ...client.RequestEditorFn) (*FetchChallengeResponse, error)

	// UpdateChallenge request with any body
	UpdateChallengeWithBody(ctx context.Context, serviceSid string, identity string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateChallengeResponse, error)

	// ListFactor request
	ListFactor(ctx context.Context, serviceSid string, identity string, params *ListFactorParams, reqEditors ...client.RequestEditorFn) (*ListFactorResponse, error)

	// CreateNewFactor request with any body
	CreateNewFactorWithBody(ctx context.Context, serviceSid string, identity string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateNewFactorResponse, error)

	// DeleteFactor request
	DeleteFactor(ctx context.Context, serviceSid string, identity string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteFactorResponse, error)

	// FetchFactor request
	FetchFactor(ctx context.Context, serviceSid string, identity string, sid string, reqEditors ...client.RequestEditorFn) (*FetchFactorResponse, error)

	// UpdateFactor request with any body
	UpdateFactorWithBody(ctx context.Context, serviceSid string, identity string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateFactorResponse, error)

	// ListMessagingConfiguration request
	ListMessagingConfiguration(ctx context.Context, serviceSid string, params *ListMessagingConfigurationParams, reqEditors ...client.RequestEditorFn) (*ListMessagingConfigurationResponse, error)

	// CreateMessagingConfiguration request with any body
	CreateMessagingConfigurationWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateMessagingConfigurationResponse, error)

	// DeleteMessagingConfiguration request
	DeleteMessagingConfiguration(ctx context.Context, serviceSid string, country string, reqEditors ...client.RequestEditorFn) (*DeleteMessagingConfigurationResponse, error)

	// FetchMessagingConfiguration request
	FetchMessagingConfiguration(ctx context.Context, serviceSid string, country string, reqEditors ...client.RequestEditorFn) (*FetchMessagingConfigurationResponse, error)

	// UpdateMessagingConfiguration request with any body
	UpdateMessagingConfigurationWithBody(ctx context.Context, serviceSid string, country string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateMessagingConfigurationResponse, error)

	// ListRateLimit request
	ListRateLimit(ctx context.Context, serviceSid string, params *ListRateLimitParams, reqEditors ...client.RequestEditorFn) (*ListRateLimitResponse, error)

	// CreateRateLimit request with any body
	CreateRateLimitWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateRateLimitResponse, error)

	// ListBucket request
	ListBucket(ctx context.Context, serviceSid string, rateLimitSid string, params *ListBucketParams, reqEditors ...client.RequestEditorFn) (*ListBucketResponse, error)

	// CreateBucket request with any body
	CreateBucketWithBody(ctx context.Context, serviceSid string, rateLimitSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateBucketResponse, error)

	// DeleteBucket request
	DeleteBucket(ctx context.Context, serviceSid string, rateLimitSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteBucketResponse, error)

	// FetchBucket request
	FetchBucket(ctx context.Context, serviceSid string, rateLimitSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchBucketResponse, error)

	// UpdateBucket request with any body
	UpdateBucketWithBody(ctx context.Context, serviceSid string, rateLimitSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateBucketResponse, error)

	// DeleteRateLimit request
	DeleteRateLimit(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteRateLimitResponse, error)

	// FetchRateLimit request
	FetchRateLimit(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchRateLimitResponse, error)

	// UpdateRateLimit request with any body
	UpdateRateLimitWithBody(ctx context.Context, serviceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateRateLimitResponse, error)

	// CreateVerificationCheck request with any body
	CreateVerificationCheckWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateVerificationCheckResponse, error)

	// CreateVerification request with any body
	CreateVerificationWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateVerificationResponse, error)

	// FetchVerification request
	FetchVerification(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchVerificationResponse, error)

	// UpdateVerification request with any body
	UpdateVerificationWithBody(ctx context.Context, serviceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateVerificationResponse, error)

	// ListWebhook request
	ListWebhook(ctx context.Context, serviceSid string, params *ListWebhookParams, reqEditors ...client.RequestEditorFn) (*ListWebhookResponse, error)

	// CreateWebhook request with any body
	CreateWebhookWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateWebhookResponse, error)

	// DeleteWebhook request
	DeleteWebhook(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteWebhookResponse, error)

	// FetchWebhook request
	FetchWebhook(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchWebhookResponse, error)

	// UpdateWebhook request with any body
	UpdateWebhookWithBody(ctx context.Context, serviceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateWebhookResponse, error)

	// DeleteService request
	DeleteService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteServiceResponse, error)

	// FetchService request
	FetchService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceResponse, error)

	// UpdateService request with any body
	UpdateServiceWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceResponse, error)

	// ListVerificationTemplate request
	ListVerificationTemplate(ctx context.Context, params *ListVerificationTemplateParams, reqEditors ...client.RequestEditorFn) (*ListVerificationTemplateResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// ListVerificationAttempt: GET /v2/Attempts

type ListVerificationAttemptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Attempts *[]VerifyV2VerificationAttempt `json:"attempts,omitempty"`
		Meta     *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListVerificationAttemptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVerificationAttemptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListVerificationAttemptRequest generates requests for ListVerificationAttempt
func newListVerificationAttemptRequest(baseURL *url.URL, params *ListVerificationAttemptParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListVerificationAttempt)

	q := queryURL.Query()

	if params.DateCreatedAfter != nil {
		if err := client.AddQueryParam(q, "DateCreatedAfter", *params.DateCreatedAfter); err != nil {
			return nil, err
		}
	}

	if params.DateCreatedBefore != nil {
		if err := client.AddQueryParam(q, "DateCreatedBefore", *params.DateCreatedBefore); err != nil {
			return nil, err
		}
	}

	if params.ChannelDataTo != nil {
		if err := client.AddQueryParam(q, "ChannelData.To", *params.ChannelDataTo); err != nil {
			return nil, err
		}
	}

	if params.Country != nil {
		if err := client.AddQueryParam(q, "Country", *params.Country); err != nil {
			return nil, err
		}
	}

	if params.Channel != nil {
		if err := client.AddQueryParam(q, "Channel", *params.Channel); err != nil {
			return nil, err
		}
	}

	if params.VerifyServiceSid != nil {
		if err := client.AddQueryParam(q, "VerifyServiceSid", *params.VerifyServiceSid); err != nil {
			return nil, err
		}
	}

	if params.VerificationSid != nil {
		if err := client.AddQueryParam(q, "VerificationSid", *params.VerificationSid); err != nil {
			return nil, err
		}
	}

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListVerificationAttempt returns a parsed response.
// GET /v2/Attempts
func (c *Client) ListVerificationAttempt(ctx context.Context, params *ListVerificationAttemptParams, reqEditors ...client.RequestEditorFn) (*ListVerificationAttemptResponse, error) {
	req, err := newListVerificationAttemptRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListVerificationAttemptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Attempts *[]VerifyV2VerificationAttempt `json:"attempts,omitempty"`
			Meta     *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchVerificationAttempt: GET /v2/Attempts/{Sid}

type FetchVerificationAttemptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyV2VerificationAttempt
}

// Status returns HTTPResponse.Status
func (r FetchVerificationAttemptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchVerificationAttemptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchVerificationAttemptRequest generates requests for FetchVerificationAttempt
func newFetchVerificationAttemptRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchVerificationAttemptFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchVerificationAttempt returns a parsed response.
// GET /v2/Attempts/{Sid}
func (c *Client) FetchVerificationAttempt(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchVerificationAttemptResponse, error) {
	req, err := newFetchVerificationAttemptRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchVerificationAttemptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyV2VerificationAttempt
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchForm: GET /v2/Forms/{FormType}

type FetchFormResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyV2Form
}

// Status returns HTTPResponse.Status
func (r FetchFormResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchFormResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchFormRequest generates requests for FetchForm
func newFetchFormRequest(baseURL *url.URL, formType FetchFormParamsFormType) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("FormType", formType)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchFormFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchForm returns a parsed response.
// GET /v2/Forms/{FormType}
func (c *Client) FetchForm(ctx context.Context, formType FetchFormParamsFormType, reqEditors ...client.RequestEditorFn) (*FetchFormResponse, error) {
	req, err := newFetchFormRequest(c.BaseURL, formType)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchFormResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyV2Form
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListService: GET /v2/Services

type ListServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Services *[]VerifyV2Service `json:"services,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListServiceRequest generates requests for ListService
func newListServiceRequest(baseURL *url.URL, params *ListServiceParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListService)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListService returns a parsed response.
// GET /v2/Services
func (c *Client) ListService(ctx context.Context, params *ListServiceParams, reqEditors ...client.RequestEditorFn) (*ListServiceResponse, error) {
	req, err := newListServiceRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Services *[]VerifyV2Service `json:"services,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateService: POST /v2/Services

type CreateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VerifyV2Service
}

// Status returns HTTPResponse.Status
func (r CreateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateServiceRequestWithBody generates requests for CreateService with any type of body
func newCreateServiceRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateService)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateServiceWithBody returns a parsed response.
// POST /v2/Services
func (c *Client) CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceResponse, error) {
	req, err := newCreateServiceRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VerifyV2Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// CreateAccessToken: POST /v2/Services/{ServiceSid}/AccessTokens

type CreateAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VerifyV2ServiceAccessToken
}

// Status returns HTTPResponse.Status
func (r CreateAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateAccessTokenRequestWithBody generates requests for CreateAccessToken with any type of body
func newCreateAccessTokenRequestWithBody(baseURL *url.URL, serviceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateAccessTokenFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateAccessTokenWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/AccessTokens
func (c *Client) CreateAccessTokenWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateAccessTokenResponse, error) {
	req, err := newCreateAccessTokenRequestWithBody(c.BaseURL, serviceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VerifyV2ServiceAccessToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// FetchAccessToken: GET /v2/Services/{ServiceSid}/AccessTokens/{Sid}

type FetchAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyV2ServiceAccessToken
}

// Status returns HTTPResponse.Status
func (r FetchAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchAccessTokenRequest generates requests for FetchAccessToken
func newFetchAccessTokenRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchAccessTokenFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchAccessToken returns a parsed response.
// GET /v2/Services/{ServiceSid}/AccessTokens/{Sid}
func (c *Client) FetchAccessToken(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchAccessTokenResponse, error) {
	req, err := newFetchAccessTokenRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyV2ServiceAccessToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListEntity: GET /v2/Services/{ServiceSid}/Entities

type ListEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Entities *[]VerifyV2ServiceEntity `json:"entities,omitempty"`
		Meta     *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListEntityRequest generates requests for ListEntity
func newListEntityRequest(baseURL *url.URL, serviceSid string, params *ListEntityParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListEntityFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListEntity returns a parsed response.
// GET /v2/Services/{ServiceSid}/Entities
func (c *Client) ListEntity(ctx context.Context, serviceSid string, params *ListEntityParams, reqEditors ...client.RequestEditorFn) (*ListEntityResponse, error) {
	req, err := newListEntityRequest(c.BaseURL, serviceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Entities *[]VerifyV2ServiceEntity `json:"entities,omitempty"`
			Meta     *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateEntity: POST /v2/Services/{ServiceSid}/Entities

type CreateEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VerifyV2ServiceEntity
}

// Status returns HTTPResponse.Status
func (r CreateEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateEntityRequestWithBody generates requests for CreateEntity with any type of body
func newCreateEntityRequestWithBody(baseURL *url.URL, serviceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateEntityFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateEntityWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Entities
func (c *Client) CreateEntityWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateEntityResponse, error) {
	req, err := newCreateEntityRequestWithBody(c.BaseURL, serviceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VerifyV2ServiceEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteEntity: DELETE /v2/Services/{ServiceSid}/Entities/{Identity}

type DeleteEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteEntityRequest generates requests for DeleteEntity
func newDeleteEntityRequest(baseURL *url.URL, serviceSid string, identity string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteEntityFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteEntity returns a parsed response.
// DELETE /v2/Services/{ServiceSid}/Entities/{Identity}
func (c *Client) DeleteEntity(ctx context.Context, serviceSid string, identity string, reqEditors ...client.RequestEditorFn) (*DeleteEntityResponse, error) {
	req, err := newDeleteEntityRequest(c.BaseURL, serviceSid, identity)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchEntity: GET /v2/Services/{ServiceSid}/Entities/{Identity}

type FetchEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyV2ServiceEntity
}

// Status returns HTTPResponse.Status
func (r FetchEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchEntityRequest generates requests for FetchEntity
func newFetchEntityRequest(baseURL *url.URL, serviceSid string, identity string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchEntityFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchEntity returns a parsed response.
// GET /v2/Services/{ServiceSid}/Entities/{Identity}
func (c *Client) FetchEntity(ctx context.Context, serviceSid string, identity string, reqEditors ...client.RequestEditorFn) (*FetchEntityResponse, error) {
	req, err := newFetchEntityRequest(c.BaseURL, serviceSid, identity)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyV2ServiceEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListChallenge: GET /v2/Services/{ServiceSid}/Entities/{Identity}/Challenges

type ListChallengeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Challenges *[]VerifyV2ServiceEntityChallenge `json:"challenges,omitempty"`
		Meta       *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListChallengeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListChallengeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListChallengeRequest generates requests for ListChallenge
func newListChallengeRequest(baseURL *url.URL, serviceSid string, identity string, params *ListChallengeParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListChallengeFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.FactorSid != nil {
		if err := client.AddQueryParam(q, "FactorSid", *params.FactorSid); err != nil {
			return nil, err
		}
	}

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.Order != nil {
		if err := client.AddQueryParam(q, "Order", *params.Order); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListChallenge returns a parsed response.
// GET /v2/Services/{ServiceSid}/Entities/{Identity}/Challenges
func (c *Client) ListChallenge(ctx context.Context, serviceSid string, identity string, params *ListChallengeParams, reqEditors ...client.RequestEditorFn) (*ListChallengeResponse, error) {
	req, err := newListChallengeRequest(c.BaseURL, serviceSid, identity, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListChallengeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Challenges *[]VerifyV2ServiceEntityChallenge `json:"challenges,omitempty"`
			Meta       *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateChallenge: POST /v2/Services/{ServiceSid}/Entities/{Identity}/Challenges

type CreateChallengeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VerifyV2ServiceEntityChallenge
}

// Status returns HTTPResponse.Status
func (r CreateChallengeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateChallengeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateChallengeRequestWithBody generates requests for CreateChallenge with any type of body
func newCreateChallengeRequestWithBody(baseURL *url.URL, serviceSid string, identity string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateChallengeFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateChallengeWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Entities/{Identity}/Challenges
func (c *Client) CreateChallengeWithBody(ctx context.Context, serviceSid string, identity string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateChallengeResponse, error) {
	req, err := newCreateChallengeRequestWithBody(c.BaseURL, serviceSid, identity, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateChallengeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VerifyV2ServiceEntityChallenge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// CreateNotification: POST /v2/Services/{ServiceSid}/Entities/{Identity}/Challenges/{ChallengeSid}/Notifications

type CreateNotificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VerifyV2ServiceEntityChallengeNotification
}

// Status returns HTTPResponse.Status
func (r CreateNotificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNotificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateNotificationRequestWithBody generates requests for CreateNotification with any type of body
func newCreateNotificationRequestWithBody(baseURL *url.URL, serviceSid string, identity string, challengeSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("ChallengeSid", challengeSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateNotificationFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateNotificationWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Entities/{Identity}/Challenges/{ChallengeSid}/Notifications
func (c *Client) CreateNotificationWithBody(ctx context.Context, serviceSid string, identity string, challengeSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateNotificationResponse, error) {
	req, err := newCreateNotificationRequestWithBody(c.BaseURL, serviceSid, identity, challengeSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateNotificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VerifyV2ServiceEntityChallengeNotification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// FetchChallenge: GET /v2/Services/{ServiceSid}/Entities/{Identity}/Challenges/{Sid}

type FetchChallengeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyV2ServiceEntityChallenge
}

// Status returns HTTPResponse.Status
func (r FetchChallengeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchChallengeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchChallengeRequest generates requests for FetchChallenge
func newFetchChallengeRequest(baseURL *url.URL, serviceSid string, identity string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchChallengeFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchChallenge returns a parsed response.
// GET /v2/Services/{ServiceSid}/Entities/{Identity}/Challenges/{Sid}
func (c *Client) FetchChallenge(ctx context.Context, serviceSid string, identity string, sid string, reqEditors ...client.RequestEditorFn) (*FetchChallengeResponse, error) {
	req, err := newFetchChallengeRequest(c.BaseURL, serviceSid, identity, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchChallengeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyV2ServiceEntityChallenge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateChallenge: POST /v2/Services/{ServiceSid}/Entities/{Identity}/Challenges/{Sid}

type UpdateChallengeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyV2ServiceEntityChallenge
}

// Status returns HTTPResponse.Status
func (r UpdateChallengeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChallengeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateChallengeRequestWithBody generates requests for UpdateChallenge with any type of body
func newUpdateChallengeRequestWithBody(baseURL *url.URL, serviceSid string, identity string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateChallengeFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateChallengeWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Entities/{Identity}/Challenges/{Sid}
func (c *Client) UpdateChallengeWithBody(ctx context.Context, serviceSid string, identity string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateChallengeResponse, error) {
	req, err := newUpdateChallengeRequestWithBody(c.BaseURL, serviceSid, identity, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateChallengeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyV2ServiceEntityChallenge
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListFactor: GET /v2/Services/{ServiceSid}/Entities/{Identity}/Factors

type ListFactorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Factors *[]VerifyV2ServiceEntityFactor `json:"factors,omitempty"`
		Meta    *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListFactorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFactorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListFactorRequest generates requests for ListFactor
func newListFactorRequest(baseURL *url.URL, serviceSid string, identity string, params *ListFactorParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListFactorFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListFactor returns a parsed response.
// GET /v2/Services/{ServiceSid}/Entities/{Identity}/Factors
func (c *Client) ListFactor(ctx context.Context, serviceSid string, identity string, params *ListFactorParams, reqEditors ...client.RequestEditorFn) (*ListFactorResponse, error) {
	req, err := newListFactorRequest(c.BaseURL, serviceSid, identity, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListFactorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Factors *[]VerifyV2ServiceEntityFactor `json:"factors,omitempty"`
			Meta    *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateNewFactor: POST /v2/Services/{ServiceSid}/Entities/{Identity}/Factors

type CreateNewFactorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VerifyV2ServiceEntityNewFactor
}

// Status returns HTTPResponse.Status
func (r CreateNewFactorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNewFactorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateNewFactorRequestWithBody generates requests for CreateNewFactor with any type of body
func newCreateNewFactorRequestWithBody(baseURL *url.URL, serviceSid string, identity string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateNewFactorFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateNewFactorWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Entities/{Identity}/Factors
func (c *Client) CreateNewFactorWithBody(ctx context.Context, serviceSid string, identity string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateNewFactorResponse, error) {
	req, err := newCreateNewFactorRequestWithBody(c.BaseURL, serviceSid, identity, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateNewFactorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VerifyV2ServiceEntityNewFactor
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteFactor: DELETE /v2/Services/{ServiceSid}/Entities/{Identity}/Factors/{Sid}

type DeleteFactorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFactorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFactorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteFactorRequest generates requests for DeleteFactor
func newDeleteFactorRequest(baseURL *url.URL, serviceSid string, identity string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteFactorFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteFactor returns a parsed response.
// DELETE /v2/Services/{ServiceSid}/Entities/{Identity}/Factors/{Sid}
func (c *Client) DeleteFactor(ctx context.Context, serviceSid string, identity string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteFactorResponse, error) {
	req, err := newDeleteFactorRequest(c.BaseURL, serviceSid, identity, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteFactorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchFactor: GET /v2/Services/{ServiceSid}/Entities/{Identity}/Factors/{Sid}

type FetchFactorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyV2ServiceEntityFactor
}

// Status returns HTTPResponse.Status
func (r FetchFactorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchFactorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchFactorRequest generates requests for FetchFactor
func newFetchFactorRequest(baseURL *url.URL, serviceSid string, identity string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchFactorFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchFactor returns a parsed response.
// GET /v2/Services/{ServiceSid}/Entities/{Identity}/Factors/{Sid}
func (c *Client) FetchFactor(ctx context.Context, serviceSid string, identity string, sid string, reqEditors ...client.RequestEditorFn) (*FetchFactorResponse, error) {
	req, err := newFetchFactorRequest(c.BaseURL, serviceSid, identity, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchFactorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyV2ServiceEntityFactor
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateFactor: POST /v2/Services/{ServiceSid}/Entities/{Identity}/Factors/{Sid}

type UpdateFactorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyV2ServiceEntityFactor
}

// Status returns HTTPResponse.Status
func (r UpdateFactorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFactorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateFactorRequestWithBody generates requests for UpdateFactor with any type of body
func newUpdateFactorRequestWithBody(baseURL *url.URL, serviceSid string, identity string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Identity", identity)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateFactorFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateFactorWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Entities/{Identity}/Factors/{Sid}
func (c *Client) UpdateFactorWithBody(ctx context.Context, serviceSid string, identity string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateFactorResponse, error) {
	req, err := newUpdateFactorRequestWithBody(c.BaseURL, serviceSid, identity, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateFactorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyV2ServiceEntityFactor
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListMessagingConfiguration: GET /v2/Services/{ServiceSid}/MessagingConfigurations

type ListMessagingConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		MessagingConfigurations *[]VerifyV2ServiceMessagingConfiguration `json:"messaging_configurations,omitempty"`
		Meta                    *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListMessagingConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMessagingConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListMessagingConfigurationRequest generates requests for ListMessagingConfiguration
func newListMessagingConfigurationRequest(baseURL *url.URL, serviceSid string, params *ListMessagingConfigurationParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListMessagingConfigurationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListMessagingConfiguration returns a parsed response.
// GET /v2/Services/{ServiceSid}/MessagingConfigurations
func (c *Client) ListMessagingConfiguration(ctx context.Context, serviceSid string, params *ListMessagingConfigurationParams, reqEditors ...client.RequestEditorFn) (*ListMessagingConfigurationResponse, error) {
	req, err := newListMessagingConfigurationRequest(c.BaseURL, serviceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListMessagingConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			MessagingConfigurations *[]VerifyV2ServiceMessagingConfiguration `json:"messaging_configurations,omitempty"`
			Meta                    *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateMessagingConfiguration: POST /v2/Services/{ServiceSid}/MessagingConfigurations

type CreateMessagingConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VerifyV2ServiceMessagingConfiguration
}

// Status returns HTTPResponse.Status
func (r CreateMessagingConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMessagingConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateMessagingConfigurationRequestWithBody generates requests for CreateMessagingConfiguration with any type of body
func newCreateMessagingConfigurationRequestWithBody(baseURL *url.URL, serviceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateMessagingConfigurationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateMessagingConfigurationWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/MessagingConfigurations
func (c *Client) CreateMessagingConfigurationWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateMessagingConfigurationResponse, error) {
	req, err := newCreateMessagingConfigurationRequestWithBody(c.BaseURL, serviceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateMessagingConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VerifyV2ServiceMessagingConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteMessagingConfiguration: DELETE /v2/Services/{ServiceSid}/MessagingConfigurations/{Country}

type DeleteMessagingConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteMessagingConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMessagingConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteMessagingConfigurationRequest generates requests for DeleteMessagingConfiguration
func newDeleteMessagingConfigurationRequest(baseURL *url.URL, serviceSid string, country string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Country", country)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteMessagingConfigurationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteMessagingConfiguration returns a parsed response.
// DELETE /v2/Services/{ServiceSid}/MessagingConfigurations/{Country}
func (c *Client) DeleteMessagingConfiguration(ctx context.Context, serviceSid string, country string, reqEditors ...client.RequestEditorFn) (*DeleteMessagingConfigurationResponse, error) {
	req, err := newDeleteMessagingConfigurationRequest(c.BaseURL, serviceSid, country)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteMessagingConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchMessagingConfiguration: GET /v2/Services/{ServiceSid}/MessagingConfigurations/{Country}

type FetchMessagingConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyV2ServiceMessagingConfiguration
}

// Status returns HTTPResponse.Status
func (r FetchMessagingConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchMessagingConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchMessagingConfigurationRequest generates requests for FetchMessagingConfiguration
func newFetchMessagingConfigurationRequest(baseURL *url.URL, serviceSid string, country string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Country", country)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchMessagingConfigurationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchMessagingConfiguration returns a parsed response.
// GET /v2/Services/{ServiceSid}/MessagingConfigurations/{Country}
func (c *Client) FetchMessagingConfiguration(ctx context.Context, serviceSid string, country string, reqEditors ...client.RequestEditorFn) (*FetchMessagingConfigurationResponse, error) {
	req, err := newFetchMessagingConfigurationRequest(c.BaseURL, serviceSid, country)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchMessagingConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyV2ServiceMessagingConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateMessagingConfiguration: POST /v2/Services/{ServiceSid}/MessagingConfigurations/{Country}

type UpdateMessagingConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyV2ServiceMessagingConfiguration
}

// Status returns HTTPResponse.Status
func (r UpdateMessagingConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMessagingConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateMessagingConfigurationRequestWithBody generates requests for UpdateMessagingConfiguration with any type of body
func newUpdateMessagingConfigurationRequestWithBody(baseURL *url.URL, serviceSid string, country string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Country", country)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateMessagingConfigurationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateMessagingConfigurationWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/MessagingConfigurations/{Country}
func (c *Client) UpdateMessagingConfigurationWithBody(ctx context.Context, serviceSid string, country string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateMessagingConfigurationResponse, error) {
	req, err := newUpdateMessagingConfigurationRequestWithBody(c.BaseURL, serviceSid, country, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateMessagingConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyV2ServiceMessagingConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListRateLimit: GET /v2/Services/{ServiceSid}/RateLimits

type ListRateLimitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		RateLimits *[]VerifyV2ServiceRateLimit `json:"rate_limits,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRateLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRateLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListRateLimitRequest generates requests for ListRateLimit
func newListRateLimitRequest(baseURL *url.URL, serviceSid string, params *ListRateLimitParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListRateLimitFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListRateLimit returns a parsed response.
// GET /v2/Services/{ServiceSid}/RateLimits
func (c *Client) ListRateLimit(ctx context.Context, serviceSid string, params *ListRateLimitParams, reqEditors ...client.RequestEditorFn) (*ListRateLimitResponse, error) {
	req, err := newListRateLimitRequest(c.BaseURL, serviceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListRateLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			RateLimits *[]VerifyV2ServiceRateLimit `json:"rate_limits,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateRateLimit: POST /v2/Services/{ServiceSid}/RateLimits

type CreateRateLimitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VerifyV2ServiceRateLimit
}

// Status returns HTTPResponse.Status
func (r CreateRateLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRateLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateRateLimitRequestWithBody generates requests for CreateRateLimit with any type of body
func newCreateRateLimitRequestWithBody(baseURL *url.URL, serviceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateRateLimitFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateRateLimitWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/RateLimits
func (c *Client) CreateRateLimitWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateRateLimitResponse, error) {
	req, err := newCreateRateLimitRequestWithBody(c.BaseURL, serviceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateRateLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VerifyV2ServiceRateLimit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListBucket: GET /v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets

type ListBucketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Buckets *[]VerifyV2ServiceRateLimitBucket `json:"buckets,omitempty"`
		Meta    *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListBucketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBucketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListBucketRequest generates requests for ListBucket
func newListBucketRequest(baseURL *url.URL, serviceSid string, rateLimitSid string, params *ListBucketParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("RateLimitSid", rateLimitSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListBucketFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListBucket returns a parsed response.
// GET /v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets
func (c *Client) ListBucket(ctx context.Context, serviceSid string, rateLimitSid string, params *ListBucketParams, reqEditors ...client.RequestEditorFn) (*ListBucketResponse, error) {
	req, err := newListBucketRequest(c.BaseURL, serviceSid, rateLimitSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListBucketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Buckets *[]VerifyV2ServiceRateLimitBucket `json:"buckets,omitempty"`
			Meta    *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateBucket: POST /v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets

type CreateBucketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VerifyV2ServiceRateLimitBucket
}

// Status returns HTTPResponse.Status
func (r CreateBucketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBucketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateBucketRequestWithBody generates requests for CreateBucket with any type of body
func newCreateBucketRequestWithBody(baseURL *url.URL, serviceSid string, rateLimitSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("RateLimitSid", rateLimitSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateBucketFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateBucketWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets
func (c *Client) CreateBucketWithBody(ctx context.Context, serviceSid string, rateLimitSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateBucketResponse, error) {
	req, err := newCreateBucketRequestWithBody(c.BaseURL, serviceSid, rateLimitSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateBucketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VerifyV2ServiceRateLimitBucket
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteBucket: DELETE /v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets/{Sid}

type DeleteBucketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteBucketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBucketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteBucketRequest generates requests for DeleteBucket
func newDeleteBucketRequest(baseURL *url.URL, serviceSid string, rateLimitSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("RateLimitSid", rateLimitSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteBucketFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteBucket returns a parsed response.
// DELETE /v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets/{Sid}
func (c *Client) DeleteBucket(ctx context.Context, serviceSid string, rateLimitSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteBucketResponse, error) {
	req, err := newDeleteBucketRequest(c.BaseURL, serviceSid, rateLimitSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteBucketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchBucket: GET /v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets/{Sid}

type FetchBucketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyV2ServiceRateLimitBucket
}

// Status returns HTTPResponse.Status
func (r FetchBucketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchBucketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchBucketRequest generates requests for FetchBucket
func newFetchBucketRequest(baseURL *url.URL, serviceSid string, rateLimitSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("RateLimitSid", rateLimitSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchBucketFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchBucket returns a parsed response.
// GET /v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets/{Sid}
func (c *Client) FetchBucket(ctx context.Context, serviceSid string, rateLimitSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchBucketResponse, error) {
	req, err := newFetchBucketRequest(c.BaseURL, serviceSid, rateLimitSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchBucketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyV2ServiceRateLimitBucket
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateBucket: POST /v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets/{Sid}

type UpdateBucketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyV2ServiceRateLimitBucket
}

// Status returns HTTPResponse.Status
func (r UpdateBucketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBucketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateBucketRequestWithBody generates requests for UpdateBucket with any type of body
func newUpdateBucketRequestWithBody(baseURL *url.URL, serviceSid string, rateLimitSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("RateLimitSid", rateLimitSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateBucketFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateBucketWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/RateLimits/{RateLimitSid}/Buckets/{Sid}
func (c *Client) UpdateBucketWithBody(ctx context.Context, serviceSid string, rateLimitSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateBucketResponse, error) {
	req, err := newUpdateBucketRequestWithBody(c.BaseURL, serviceSid, rateLimitSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateBucketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyV2ServiceRateLimitBucket
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteRateLimit: DELETE /v2/Services/{ServiceSid}/RateLimits/{Sid}

type DeleteRateLimitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRateLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRateLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteRateLimitRequest generates requests for DeleteRateLimit
func newDeleteRateLimitRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteRateLimitFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteRateLimit returns a parsed response.
// DELETE /v2/Services/{ServiceSid}/RateLimits/{Sid}
func (c *Client) DeleteRateLimit(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteRateLimitResponse, error) {
	req, err := newDeleteRateLimitRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteRateLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchRateLimit: GET /v2/Services/{ServiceSid}/RateLimits/{Sid}

type FetchRateLimitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyV2ServiceRateLimit
}

// Status returns HTTPResponse.Status
func (r FetchRateLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchRateLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchRateLimitRequest generates requests for FetchRateLimit
func newFetchRateLimitRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchRateLimitFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchRateLimit returns a parsed response.
// GET /v2/Services/{ServiceSid}/RateLimits/{Sid}
func (c *Client) FetchRateLimit(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchRateLimitResponse, error) {
	req, err := newFetchRateLimitRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchRateLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyV2ServiceRateLimit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateRateLimit: POST /v2/Services/{ServiceSid}/RateLimits/{Sid}

type UpdateRateLimitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyV2ServiceRateLimit
}

// Status returns HTTPResponse.Status
func (r UpdateRateLimitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRateLimitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateRateLimitRequestWithBody generates requests for UpdateRateLimit with any type of body
func newUpdateRateLimitRequestWithBody(baseURL *url.URL, serviceSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateRateLimitFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateRateLimitWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/RateLimits/{Sid}
func (c *Client) UpdateRateLimitWithBody(ctx context.Context, serviceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateRateLimitResponse, error) {
	req, err := newUpdateRateLimitRequestWithBody(c.BaseURL, serviceSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateRateLimitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyV2ServiceRateLimit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateVerificationCheck: POST /v2/Services/{ServiceSid}/VerificationCheck

type CreateVerificationCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VerifyV2ServiceVerificationCheck
}

// Status returns HTTPResponse.Status
func (r CreateVerificationCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVerificationCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateVerificationCheckRequestWithBody generates requests for CreateVerificationCheck with any type of body
func newCreateVerificationCheckRequestWithBody(baseURL *url.URL, serviceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateVerificationCheckFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateVerificationCheckWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/VerificationCheck
func (c *Client) CreateVerificationCheckWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateVerificationCheckResponse, error) {
	req, err := newCreateVerificationCheckRequestWithBody(c.BaseURL, serviceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateVerificationCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VerifyV2ServiceVerificationCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// CreateVerification: POST /v2/Services/{ServiceSid}/Verifications

type CreateVerificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VerifyV2ServiceVerification
}

// Status returns HTTPResponse.Status
func (r CreateVerificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVerificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateVerificationRequestWithBody generates requests for CreateVerification with any type of body
func newCreateVerificationRequestWithBody(baseURL *url.URL, serviceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateVerificationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateVerificationWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Verifications
func (c *Client) CreateVerificationWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateVerificationResponse, error) {
	req, err := newCreateVerificationRequestWithBody(c.BaseURL, serviceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateVerificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VerifyV2ServiceVerification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// FetchVerification: GET /v2/Services/{ServiceSid}/Verifications/{Sid}

type FetchVerificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyV2ServiceVerification
}

// Status returns HTTPResponse.Status
func (r FetchVerificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchVerificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchVerificationRequest generates requests for FetchVerification
func newFetchVerificationRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchVerificationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchVerification returns a parsed response.
// GET /v2/Services/{ServiceSid}/Verifications/{Sid}
func (c *Client) FetchVerification(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchVerificationResponse, error) {
	req, err := newFetchVerificationRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchVerificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyV2ServiceVerification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateVerification: POST /v2/Services/{ServiceSid}/Verifications/{Sid}

type UpdateVerificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyV2ServiceVerification
}

// Status returns HTTPResponse.Status
func (r UpdateVerificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateVerificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateVerificationRequestWithBody generates requests for UpdateVerification with any type of body
func newUpdateVerificationRequestWithBody(baseURL *url.URL, serviceSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateVerificationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateVerificationWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Verifications/{Sid}
func (c *Client) UpdateVerificationWithBody(ctx context.Context, serviceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateVerificationResponse, error) {
	req, err := newUpdateVerificationRequestWithBody(c.BaseURL, serviceSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateVerificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyV2ServiceVerification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListWebhook: GET /v2/Services/{ServiceSid}/Webhooks

type ListWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Webhooks *[]VerifyV2ServiceWebhook `json:"webhooks,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListWebhookRequest generates requests for ListWebhook
func newListWebhookRequest(baseURL *url.URL, serviceSid string, params *ListWebhookParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListWebhookFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListWebhook returns a parsed response.
// GET /v2/Services/{ServiceSid}/Webhooks
func (c *Client) ListWebhook(ctx context.Context, serviceSid string, params *ListWebhookParams, reqEditors ...client.RequestEditorFn) (*ListWebhookResponse, error) {
	req, err := newListWebhookRequest(c.BaseURL, serviceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Webhooks *[]VerifyV2ServiceWebhook `json:"webhooks,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateWebhook: POST /v2/Services/{ServiceSid}/Webhooks

type CreateWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VerifyV2ServiceWebhook
}

// Status returns HTTPResponse.Status
func (r CreateWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateWebhookRequestWithBody generates requests for CreateWebhook with any type of body
func newCreateWebhookRequestWithBody(baseURL *url.URL, serviceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateWebhookFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateWebhookWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Webhooks
func (c *Client) CreateWebhookWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateWebhookResponse, error) {
	req, err := newCreateWebhookRequestWithBody(c.BaseURL, serviceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VerifyV2ServiceWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteWebhook: DELETE /v2/Services/{ServiceSid}/Webhooks/{Sid}

type DeleteWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteWebhookRequest generates requests for DeleteWebhook
func newDeleteWebhookRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteWebhookFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteWebhook returns a parsed response.
// DELETE /v2/Services/{ServiceSid}/Webhooks/{Sid}
func (c *Client) DeleteWebhook(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteWebhookResponse, error) {
	req, err := newDeleteWebhookRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchWebhook: GET /v2/Services/{ServiceSid}/Webhooks/{Sid}

type FetchWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyV2ServiceWebhook
}

// Status returns HTTPResponse.Status
func (r FetchWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchWebhookRequest generates requests for FetchWebhook
func newFetchWebhookRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchWebhookFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchWebhook returns a parsed response.
// GET /v2/Services/{ServiceSid}/Webhooks/{Sid}
func (c *Client) FetchWebhook(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchWebhookResponse, error) {
	req, err := newFetchWebhookRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyV2ServiceWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateWebhook: POST /v2/Services/{ServiceSid}/Webhooks/{Sid}

type UpdateWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyV2ServiceWebhook
}

// Status returns HTTPResponse.Status
func (r UpdateWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateWebhookRequestWithBody generates requests for UpdateWebhook with any type of body
func newUpdateWebhookRequestWithBody(baseURL *url.URL, serviceSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateWebhookFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateWebhookWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Webhooks/{Sid}
func (c *Client) UpdateWebhookWithBody(ctx context.Context, serviceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateWebhookResponse, error) {
	req, err := newUpdateWebhookRequestWithBody(c.BaseURL, serviceSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyV2ServiceWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteService: DELETE /v2/Services/{Sid}

type DeleteServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteServiceRequest generates requests for DeleteService
func newDeleteServiceRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteServiceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteService returns a parsed response.
// DELETE /v2/Services/{Sid}
func (c *Client) DeleteService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteServiceResponse, error) {
	req, err := newDeleteServiceRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchService: GET /v2/Services/{Sid}

type FetchServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyV2Service
}

// Status returns HTTPResponse.Status
func (r FetchServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchServiceRequest generates requests for FetchService
func newFetchServiceRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchServiceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchService returns a parsed response.
// GET /v2/Services/{Sid}
func (c *Client) FetchService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceResponse, error) {
	req, err := newFetchServiceRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyV2Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateService: POST /v2/Services/{Sid}

type UpdateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VerifyV2Service
}

// Status returns HTTPResponse.Status
func (r UpdateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateServiceRequestWithBody generates requests for UpdateService with any type of body
func newUpdateServiceRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateServiceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateServiceWithBody returns a parsed response.
// POST /v2/Services/{Sid}
func (c *Client) UpdateServiceWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceResponse, error) {
	req, err := newUpdateServiceRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VerifyV2Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListVerificationTemplate: GET /v2/Templates

type ListVerificationTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Templates *[]VerifyV2VerificationTemplate `json:"templates,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListVerificationTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVerificationTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListVerificationTemplateRequest generates requests for ListVerificationTemplate
func newListVerificationTemplateRequest(baseURL *url.URL, params *ListVerificationTemplateParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListVerificationTemplate)

	q := queryURL.Query()

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListVerificationTemplate returns a parsed response.
// GET /v2/Templates
func (c *Client) ListVerificationTemplate(ctx context.Context, params *ListVerificationTemplateParams, reqEditors ...client.RequestEditorFn) (*ListVerificationTemplateResponse, error) {
	req, err := newListVerificationTemplateRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListVerificationTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Templates *[]VerifyV2VerificationTemplate `json:"templates,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
