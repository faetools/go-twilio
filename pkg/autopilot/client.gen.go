// Package autopilot provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package autopilot

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/faetools/client"
)

// operation paths

const (
	opPathFetchDefaultsFormat       = "./v1/Assistants/%s/Defaults"
	opPathUpdateDefaultsFormat      = "./v1/Assistants/%s/Defaults"
	opPathFetchDialogueFormat       = "./v1/Assistants/%s/Dialogues/%s"
	opPathListFieldTypeFormat       = "./v1/Assistants/%s/FieldTypes"
	opPathCreateFieldTypeFormat     = "./v1/Assistants/%s/FieldTypes"
	opPathListFieldValueFormat      = "./v1/Assistants/%s/FieldTypes/%s/FieldValues"
	opPathCreateFieldValueFormat    = "./v1/Assistants/%s/FieldTypes/%s/FieldValues"
	opPathDeleteFieldValueFormat    = "./v1/Assistants/%s/FieldTypes/%s/FieldValues/%s"
	opPathFetchFieldValueFormat     = "./v1/Assistants/%s/FieldTypes/%s/FieldValues/%s"
	opPathDeleteFieldTypeFormat     = "./v1/Assistants/%s/FieldTypes/%s"
	opPathFetchFieldTypeFormat      = "./v1/Assistants/%s/FieldTypes/%s"
	opPathUpdateFieldTypeFormat     = "./v1/Assistants/%s/FieldTypes/%s"
	opPathListModelBuildFormat      = "./v1/Assistants/%s/ModelBuilds"
	opPathCreateModelBuildFormat    = "./v1/Assistants/%s/ModelBuilds"
	opPathDeleteModelBuildFormat    = "./v1/Assistants/%s/ModelBuilds/%s"
	opPathFetchModelBuildFormat     = "./v1/Assistants/%s/ModelBuilds/%s"
	opPathUpdateModelBuildFormat    = "./v1/Assistants/%s/ModelBuilds/%s"
	opPathListQueryFormat           = "./v1/Assistants/%s/Queries"
	opPathCreateQueryFormat         = "./v1/Assistants/%s/Queries"
	opPathDeleteQueryFormat         = "./v1/Assistants/%s/Queries/%s"
	opPathFetchQueryFormat          = "./v1/Assistants/%s/Queries/%s"
	opPathUpdateQueryFormat         = "./v1/Assistants/%s/Queries/%s"
	opPathFetchStyleSheetFormat     = "./v1/Assistants/%s/StyleSheet"
	opPathUpdateStyleSheetFormat    = "./v1/Assistants/%s/StyleSheet"
	opPathListTaskFormat            = "./v1/Assistants/%s/Tasks"
	opPathCreateTaskFormat          = "./v1/Assistants/%s/Tasks"
	opPathDeleteTaskFormat          = "./v1/Assistants/%s/Tasks/%s"
	opPathFetchTaskFormat           = "./v1/Assistants/%s/Tasks/%s"
	opPathUpdateTaskFormat          = "./v1/Assistants/%s/Tasks/%s"
	opPathFetchTaskActionsFormat    = "./v1/Assistants/%s/Tasks/%s/Actions"
	opPathUpdateTaskActionsFormat   = "./v1/Assistants/%s/Tasks/%s/Actions"
	opPathListFieldFormat           = "./v1/Assistants/%s/Tasks/%s/Fields"
	opPathCreateFieldFormat         = "./v1/Assistants/%s/Tasks/%s/Fields"
	opPathDeleteFieldFormat         = "./v1/Assistants/%s/Tasks/%s/Fields/%s"
	opPathFetchFieldFormat          = "./v1/Assistants/%s/Tasks/%s/Fields/%s"
	opPathListSampleFormat          = "./v1/Assistants/%s/Tasks/%s/Samples"
	opPathCreateSampleFormat        = "./v1/Assistants/%s/Tasks/%s/Samples"
	opPathDeleteSampleFormat        = "./v1/Assistants/%s/Tasks/%s/Samples/%s"
	opPathFetchSampleFormat         = "./v1/Assistants/%s/Tasks/%s/Samples/%s"
	opPathUpdateSampleFormat        = "./v1/Assistants/%s/Tasks/%s/Samples/%s"
	opPathFetchTaskStatisticsFormat = "./v1/Assistants/%s/Tasks/%s/Statistics"
	opPathListWebhookFormat         = "./v1/Assistants/%s/Webhooks"
	opPathCreateWebhookFormat       = "./v1/Assistants/%s/Webhooks"
	opPathDeleteWebhookFormat       = "./v1/Assistants/%s/Webhooks/%s"
	opPathFetchWebhookFormat        = "./v1/Assistants/%s/Webhooks/%s"
	opPathUpdateWebhookFormat       = "./v1/Assistants/%s/Webhooks/%s"
	opPathDeleteAssistantFormat     = "./v1/Assistants/%s"
	opPathFetchAssistantFormat      = "./v1/Assistants/%s"
	opPathUpdateAssistantFormat     = "./v1/Assistants/%s"
)

var (
	opPathListAssistant          = client.MustParseURL("./v1/Assistants")
	opPathCreateAssistant        = client.MustParseURL("./v1/Assistants")
	opPathUpdateRestoreAssistant = client.MustParseURL("./v1/Assistants/Restore")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// ListAssistant request
	ListAssistant(ctx context.Context, params *ListAssistantParams, reqEditors ...client.RequestEditorFn) (*ListAssistantResponse, error)

	// CreateAssistant request with any body
	CreateAssistantWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateAssistantResponse, error)

	// UpdateRestoreAssistant request with any body
	UpdateRestoreAssistantWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateRestoreAssistantResponse, error)

	// FetchDefaults request
	FetchDefaults(ctx context.Context, assistantSid string, reqEditors ...client.RequestEditorFn) (*FetchDefaultsResponse, error)

	// UpdateDefaults request with any body
	UpdateDefaultsWithBody(ctx context.Context, assistantSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateDefaultsResponse, error)

	// FetchDialogue request
	FetchDialogue(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchDialogueResponse, error)

	// ListFieldType request
	ListFieldType(ctx context.Context, assistantSid string, params *ListFieldTypeParams, reqEditors ...client.RequestEditorFn) (*ListFieldTypeResponse, error)

	// CreateFieldType request with any body
	CreateFieldTypeWithBody(ctx context.Context, assistantSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateFieldTypeResponse, error)

	// ListFieldValue request
	ListFieldValue(ctx context.Context, assistantSid string, fieldTypeSid string, params *ListFieldValueParams, reqEditors ...client.RequestEditorFn) (*ListFieldValueResponse, error)

	// CreateFieldValue request with any body
	CreateFieldValueWithBody(ctx context.Context, assistantSid string, fieldTypeSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateFieldValueResponse, error)

	// DeleteFieldValue request
	DeleteFieldValue(ctx context.Context, assistantSid string, fieldTypeSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteFieldValueResponse, error)

	// FetchFieldValue request
	FetchFieldValue(ctx context.Context, assistantSid string, fieldTypeSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchFieldValueResponse, error)

	// DeleteFieldType request
	DeleteFieldType(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteFieldTypeResponse, error)

	// FetchFieldType request
	FetchFieldType(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchFieldTypeResponse, error)

	// UpdateFieldType request with any body
	UpdateFieldTypeWithBody(ctx context.Context, assistantSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateFieldTypeResponse, error)

	// ListModelBuild request
	ListModelBuild(ctx context.Context, assistantSid string, params *ListModelBuildParams, reqEditors ...client.RequestEditorFn) (*ListModelBuildResponse, error)

	// CreateModelBuild request with any body
	CreateModelBuildWithBody(ctx context.Context, assistantSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateModelBuildResponse, error)

	// DeleteModelBuild request
	DeleteModelBuild(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteModelBuildResponse, error)

	// FetchModelBuild request
	FetchModelBuild(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchModelBuildResponse, error)

	// UpdateModelBuild request with any body
	UpdateModelBuildWithBody(ctx context.Context, assistantSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateModelBuildResponse, error)

	// ListQuery request
	ListQuery(ctx context.Context, assistantSid string, params *ListQueryParams, reqEditors ...client.RequestEditorFn) (*ListQueryResponse, error)

	// CreateQuery request with any body
	CreateQueryWithBody(ctx context.Context, assistantSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateQueryResponse, error)

	// DeleteQuery request
	DeleteQuery(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteQueryResponse, error)

	// FetchQuery request
	FetchQuery(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchQueryResponse, error)

	// UpdateQuery request with any body
	UpdateQueryWithBody(ctx context.Context, assistantSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateQueryResponse, error)

	// FetchStyleSheet request
	FetchStyleSheet(ctx context.Context, assistantSid string, reqEditors ...client.RequestEditorFn) (*FetchStyleSheetResponse, error)

	// UpdateStyleSheet request with any body
	UpdateStyleSheetWithBody(ctx context.Context, assistantSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateStyleSheetResponse, error)

	// ListTask request
	ListTask(ctx context.Context, assistantSid string, params *ListTaskParams, reqEditors ...client.RequestEditorFn) (*ListTaskResponse, error)

	// CreateTask request with any body
	CreateTaskWithBody(ctx context.Context, assistantSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateTaskResponse, error)

	// DeleteTask request
	DeleteTask(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteTaskResponse, error)

	// FetchTask request
	FetchTask(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchTaskResponse, error)

	// UpdateTask request with any body
	UpdateTaskWithBody(ctx context.Context, assistantSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateTaskResponse, error)

	// FetchTaskActions request
	FetchTaskActions(ctx context.Context, assistantSid string, taskSid string, reqEditors ...client.RequestEditorFn) (*FetchTaskActionsResponse, error)

	// UpdateTaskActions request with any body
	UpdateTaskActionsWithBody(ctx context.Context, assistantSid string, taskSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateTaskActionsResponse, error)

	// ListField request
	ListField(ctx context.Context, assistantSid string, taskSid string, params *ListFieldParams, reqEditors ...client.RequestEditorFn) (*ListFieldResponse, error)

	// CreateField request with any body
	CreateFieldWithBody(ctx context.Context, assistantSid string, taskSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateFieldResponse, error)

	// DeleteField request
	DeleteField(ctx context.Context, assistantSid string, taskSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteFieldResponse, error)

	// FetchField request
	FetchField(ctx context.Context, assistantSid string, taskSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchFieldResponse, error)

	// ListSample request
	ListSample(ctx context.Context, assistantSid string, taskSid string, params *ListSampleParams, reqEditors ...client.RequestEditorFn) (*ListSampleResponse, error)

	// CreateSample request with any body
	CreateSampleWithBody(ctx context.Context, assistantSid string, taskSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSampleResponse, error)

	// DeleteSample request
	DeleteSample(ctx context.Context, assistantSid string, taskSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSampleResponse, error)

	// FetchSample request
	FetchSample(ctx context.Context, assistantSid string, taskSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSampleResponse, error)

	// UpdateSample request with any body
	UpdateSampleWithBody(ctx context.Context, assistantSid string, taskSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSampleResponse, error)

	// FetchTaskStatistics request
	FetchTaskStatistics(ctx context.Context, assistantSid string, taskSid string, reqEditors ...client.RequestEditorFn) (*FetchTaskStatisticsResponse, error)

	// ListWebhook request
	ListWebhook(ctx context.Context, assistantSid string, params *ListWebhookParams, reqEditors ...client.RequestEditorFn) (*ListWebhookResponse, error)

	// CreateWebhook request with any body
	CreateWebhookWithBody(ctx context.Context, assistantSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateWebhookResponse, error)

	// DeleteWebhook request
	DeleteWebhook(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteWebhookResponse, error)

	// FetchWebhook request
	FetchWebhook(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchWebhookResponse, error)

	// UpdateWebhook request with any body
	UpdateWebhookWithBody(ctx context.Context, assistantSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateWebhookResponse, error)

	// DeleteAssistant request
	DeleteAssistant(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteAssistantResponse, error)

	// FetchAssistant request
	FetchAssistant(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchAssistantResponse, error)

	// UpdateAssistant request with any body
	UpdateAssistantWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateAssistantResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// ListAssistant: GET /v1/Assistants

type ListAssistantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Assistants *[]AutopilotV1Assistant `json:"assistants,omitempty"`
		Meta       *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAssistantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssistantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListAssistantRequest generates requests for ListAssistant
func newListAssistantRequest(baseURL *url.URL, params *ListAssistantParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListAssistant)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListAssistant returns a parsed response.
// GET /v1/Assistants
func (c *Client) ListAssistant(ctx context.Context, params *ListAssistantParams, reqEditors ...client.RequestEditorFn) (*ListAssistantResponse, error) {
	req, err := newListAssistantRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListAssistantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Assistants *[]AutopilotV1Assistant `json:"assistants,omitempty"`
			Meta       *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateAssistant: POST /v1/Assistants

type CreateAssistantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AutopilotV1Assistant
}

// Status returns HTTPResponse.Status
func (r CreateAssistantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAssistantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateAssistantRequestWithBody generates requests for CreateAssistant with any type of body
func newCreateAssistantRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateAssistant)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateAssistantWithBody returns a parsed response.
// POST /v1/Assistants
func (c *Client) CreateAssistantWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateAssistantResponse, error) {
	req, err := newCreateAssistantRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateAssistantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AutopilotV1Assistant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// UpdateRestoreAssistant: POST /v1/Assistants/Restore

type UpdateRestoreAssistantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1RestoreAssistant
}

// Status returns HTTPResponse.Status
func (r UpdateRestoreAssistantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRestoreAssistantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateRestoreAssistantRequestWithBody generates requests for UpdateRestoreAssistant with any type of body
func newUpdateRestoreAssistantRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathUpdateRestoreAssistant)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateRestoreAssistantWithBody returns a parsed response.
// POST /v1/Assistants/Restore
func (c *Client) UpdateRestoreAssistantWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateRestoreAssistantResponse, error) {
	req, err := newUpdateRestoreAssistantRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateRestoreAssistantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1RestoreAssistant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchDefaults: GET /v1/Assistants/{AssistantSid}/Defaults

type FetchDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantDefaults
}

// Status returns HTTPResponse.Status
func (r FetchDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchDefaultsRequest generates requests for FetchDefaults
func newFetchDefaultsRequest(baseURL *url.URL, assistantSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchDefaultsFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchDefaults returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/Defaults
func (c *Client) FetchDefaults(ctx context.Context, assistantSid string, reqEditors ...client.RequestEditorFn) (*FetchDefaultsResponse, error) {
	req, err := newFetchDefaultsRequest(c.BaseURL, assistantSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantDefaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateDefaults: POST /v1/Assistants/{AssistantSid}/Defaults

type UpdateDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantDefaults
}

// Status returns HTTPResponse.Status
func (r UpdateDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateDefaultsRequestWithBody generates requests for UpdateDefaults with any type of body
func newUpdateDefaultsRequestWithBody(baseURL *url.URL, assistantSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateDefaultsFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateDefaultsWithBody returns a parsed response.
// POST /v1/Assistants/{AssistantSid}/Defaults
func (c *Client) UpdateDefaultsWithBody(ctx context.Context, assistantSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateDefaultsResponse, error) {
	req, err := newUpdateDefaultsRequestWithBody(c.BaseURL, assistantSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantDefaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchDialogue: GET /v1/Assistants/{AssistantSid}/Dialogues/{Sid}

type FetchDialogueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantDialogue
}

// Status returns HTTPResponse.Status
func (r FetchDialogueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchDialogueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchDialogueRequest generates requests for FetchDialogue
func newFetchDialogueRequest(baseURL *url.URL, assistantSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchDialogueFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchDialogue returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/Dialogues/{Sid}
func (c *Client) FetchDialogue(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchDialogueResponse, error) {
	req, err := newFetchDialogueRequest(c.BaseURL, assistantSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchDialogueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantDialogue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListFieldType: GET /v1/Assistants/{AssistantSid}/FieldTypes

type ListFieldTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		FieldTypes *[]AutopilotV1AssistantFieldType `json:"field_types,omitempty"`
		Meta       *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListFieldTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFieldTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListFieldTypeRequest generates requests for ListFieldType
func newListFieldTypeRequest(baseURL *url.URL, assistantSid string, params *ListFieldTypeParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListFieldTypeFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListFieldType returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/FieldTypes
func (c *Client) ListFieldType(ctx context.Context, assistantSid string, params *ListFieldTypeParams, reqEditors ...client.RequestEditorFn) (*ListFieldTypeResponse, error) {
	req, err := newListFieldTypeRequest(c.BaseURL, assistantSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListFieldTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			FieldTypes *[]AutopilotV1AssistantFieldType `json:"field_types,omitempty"`
			Meta       *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateFieldType: POST /v1/Assistants/{AssistantSid}/FieldTypes

type CreateFieldTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AutopilotV1AssistantFieldType
}

// Status returns HTTPResponse.Status
func (r CreateFieldTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFieldTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateFieldTypeRequestWithBody generates requests for CreateFieldType with any type of body
func newCreateFieldTypeRequestWithBody(baseURL *url.URL, assistantSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateFieldTypeFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateFieldTypeWithBody returns a parsed response.
// POST /v1/Assistants/{AssistantSid}/FieldTypes
func (c *Client) CreateFieldTypeWithBody(ctx context.Context, assistantSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateFieldTypeResponse, error) {
	req, err := newCreateFieldTypeRequestWithBody(c.BaseURL, assistantSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateFieldTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AutopilotV1AssistantFieldType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListFieldValue: GET /v1/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues

type ListFieldValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		FieldValues *[]AutopilotV1AssistantFieldTypeFieldValue `json:"field_values,omitempty"`
		Meta        *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListFieldValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFieldValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListFieldValueRequest generates requests for ListFieldValue
func newListFieldValueRequest(baseURL *url.URL, assistantSid string, fieldTypeSid string, params *ListFieldValueParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("FieldTypeSid", fieldTypeSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListFieldValueFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Language != nil {
		if err := client.AddQueryParam(q, "Language", *params.Language); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListFieldValue returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues
func (c *Client) ListFieldValue(ctx context.Context, assistantSid string, fieldTypeSid string, params *ListFieldValueParams, reqEditors ...client.RequestEditorFn) (*ListFieldValueResponse, error) {
	req, err := newListFieldValueRequest(c.BaseURL, assistantSid, fieldTypeSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListFieldValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			FieldValues *[]AutopilotV1AssistantFieldTypeFieldValue `json:"field_values,omitempty"`
			Meta        *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateFieldValue: POST /v1/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues

type CreateFieldValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AutopilotV1AssistantFieldTypeFieldValue
}

// Status returns HTTPResponse.Status
func (r CreateFieldValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFieldValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateFieldValueRequestWithBody generates requests for CreateFieldValue with any type of body
func newCreateFieldValueRequestWithBody(baseURL *url.URL, assistantSid string, fieldTypeSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("FieldTypeSid", fieldTypeSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateFieldValueFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateFieldValueWithBody returns a parsed response.
// POST /v1/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues
func (c *Client) CreateFieldValueWithBody(ctx context.Context, assistantSid string, fieldTypeSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateFieldValueResponse, error) {
	req, err := newCreateFieldValueRequestWithBody(c.BaseURL, assistantSid, fieldTypeSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateFieldValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AutopilotV1AssistantFieldTypeFieldValue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteFieldValue: DELETE /v1/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues/{Sid}

type DeleteFieldValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFieldValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFieldValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteFieldValueRequest generates requests for DeleteFieldValue
func newDeleteFieldValueRequest(baseURL *url.URL, assistantSid string, fieldTypeSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("FieldTypeSid", fieldTypeSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteFieldValueFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteFieldValue returns a parsed response.
// DELETE /v1/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues/{Sid}
func (c *Client) DeleteFieldValue(ctx context.Context, assistantSid string, fieldTypeSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteFieldValueResponse, error) {
	req, err := newDeleteFieldValueRequest(c.BaseURL, assistantSid, fieldTypeSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteFieldValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchFieldValue: GET /v1/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues/{Sid}

type FetchFieldValueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantFieldTypeFieldValue
}

// Status returns HTTPResponse.Status
func (r FetchFieldValueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchFieldValueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchFieldValueRequest generates requests for FetchFieldValue
func newFetchFieldValueRequest(baseURL *url.URL, assistantSid string, fieldTypeSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("FieldTypeSid", fieldTypeSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchFieldValueFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchFieldValue returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/FieldTypes/{FieldTypeSid}/FieldValues/{Sid}
func (c *Client) FetchFieldValue(ctx context.Context, assistantSid string, fieldTypeSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchFieldValueResponse, error) {
	req, err := newFetchFieldValueRequest(c.BaseURL, assistantSid, fieldTypeSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchFieldValueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantFieldTypeFieldValue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteFieldType: DELETE /v1/Assistants/{AssistantSid}/FieldTypes/{Sid}

type DeleteFieldTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFieldTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFieldTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteFieldTypeRequest generates requests for DeleteFieldType
func newDeleteFieldTypeRequest(baseURL *url.URL, assistantSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteFieldTypeFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteFieldType returns a parsed response.
// DELETE /v1/Assistants/{AssistantSid}/FieldTypes/{Sid}
func (c *Client) DeleteFieldType(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteFieldTypeResponse, error) {
	req, err := newDeleteFieldTypeRequest(c.BaseURL, assistantSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteFieldTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchFieldType: GET /v1/Assistants/{AssistantSid}/FieldTypes/{Sid}

type FetchFieldTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantFieldType
}

// Status returns HTTPResponse.Status
func (r FetchFieldTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchFieldTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchFieldTypeRequest generates requests for FetchFieldType
func newFetchFieldTypeRequest(baseURL *url.URL, assistantSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchFieldTypeFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchFieldType returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/FieldTypes/{Sid}
func (c *Client) FetchFieldType(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchFieldTypeResponse, error) {
	req, err := newFetchFieldTypeRequest(c.BaseURL, assistantSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchFieldTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantFieldType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateFieldType: POST /v1/Assistants/{AssistantSid}/FieldTypes/{Sid}

type UpdateFieldTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantFieldType
}

// Status returns HTTPResponse.Status
func (r UpdateFieldTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFieldTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateFieldTypeRequestWithBody generates requests for UpdateFieldType with any type of body
func newUpdateFieldTypeRequestWithBody(baseURL *url.URL, assistantSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateFieldTypeFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateFieldTypeWithBody returns a parsed response.
// POST /v1/Assistants/{AssistantSid}/FieldTypes/{Sid}
func (c *Client) UpdateFieldTypeWithBody(ctx context.Context, assistantSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateFieldTypeResponse, error) {
	req, err := newUpdateFieldTypeRequestWithBody(c.BaseURL, assistantSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateFieldTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantFieldType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListModelBuild: GET /v1/Assistants/{AssistantSid}/ModelBuilds

type ListModelBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		ModelBuilds *[]AutopilotV1AssistantModelBuild `json:"model_builds,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListModelBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListModelBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListModelBuildRequest generates requests for ListModelBuild
func newListModelBuildRequest(baseURL *url.URL, assistantSid string, params *ListModelBuildParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListModelBuildFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListModelBuild returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/ModelBuilds
func (c *Client) ListModelBuild(ctx context.Context, assistantSid string, params *ListModelBuildParams, reqEditors ...client.RequestEditorFn) (*ListModelBuildResponse, error) {
	req, err := newListModelBuildRequest(c.BaseURL, assistantSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListModelBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			ModelBuilds *[]AutopilotV1AssistantModelBuild `json:"model_builds,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateModelBuild: POST /v1/Assistants/{AssistantSid}/ModelBuilds

type CreateModelBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AutopilotV1AssistantModelBuild
}

// Status returns HTTPResponse.Status
func (r CreateModelBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateModelBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateModelBuildRequestWithBody generates requests for CreateModelBuild with any type of body
func newCreateModelBuildRequestWithBody(baseURL *url.URL, assistantSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateModelBuildFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateModelBuildWithBody returns a parsed response.
// POST /v1/Assistants/{AssistantSid}/ModelBuilds
func (c *Client) CreateModelBuildWithBody(ctx context.Context, assistantSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateModelBuildResponse, error) {
	req, err := newCreateModelBuildRequestWithBody(c.BaseURL, assistantSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateModelBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AutopilotV1AssistantModelBuild
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteModelBuild: DELETE /v1/Assistants/{AssistantSid}/ModelBuilds/{Sid}

type DeleteModelBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteModelBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteModelBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteModelBuildRequest generates requests for DeleteModelBuild
func newDeleteModelBuildRequest(baseURL *url.URL, assistantSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteModelBuildFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteModelBuild returns a parsed response.
// DELETE /v1/Assistants/{AssistantSid}/ModelBuilds/{Sid}
func (c *Client) DeleteModelBuild(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteModelBuildResponse, error) {
	req, err := newDeleteModelBuildRequest(c.BaseURL, assistantSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteModelBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchModelBuild: GET /v1/Assistants/{AssistantSid}/ModelBuilds/{Sid}

type FetchModelBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantModelBuild
}

// Status returns HTTPResponse.Status
func (r FetchModelBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchModelBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchModelBuildRequest generates requests for FetchModelBuild
func newFetchModelBuildRequest(baseURL *url.URL, assistantSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchModelBuildFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchModelBuild returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/ModelBuilds/{Sid}
func (c *Client) FetchModelBuild(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchModelBuildResponse, error) {
	req, err := newFetchModelBuildRequest(c.BaseURL, assistantSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchModelBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantModelBuild
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateModelBuild: POST /v1/Assistants/{AssistantSid}/ModelBuilds/{Sid}

type UpdateModelBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantModelBuild
}

// Status returns HTTPResponse.Status
func (r UpdateModelBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateModelBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateModelBuildRequestWithBody generates requests for UpdateModelBuild with any type of body
func newUpdateModelBuildRequestWithBody(baseURL *url.URL, assistantSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateModelBuildFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateModelBuildWithBody returns a parsed response.
// POST /v1/Assistants/{AssistantSid}/ModelBuilds/{Sid}
func (c *Client) UpdateModelBuildWithBody(ctx context.Context, assistantSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateModelBuildResponse, error) {
	req, err := newUpdateModelBuildRequestWithBody(c.BaseURL, assistantSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateModelBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantModelBuild
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListQuery: GET /v1/Assistants/{AssistantSid}/Queries

type ListQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Queries *[]AutopilotV1AssistantQuery `json:"queries,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListQueryRequest generates requests for ListQuery
func newListQueryRequest(baseURL *url.URL, assistantSid string, params *ListQueryParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListQueryFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Language != nil {
		if err := client.AddQueryParam(q, "Language", *params.Language); err != nil {
			return nil, err
		}
	}

	if params.ModelBuild != nil {
		if err := client.AddQueryParam(q, "ModelBuild", *params.ModelBuild); err != nil {
			return nil, err
		}
	}

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.DialogueSid != nil {
		if err := client.AddQueryParam(q, "DialogueSid", *params.DialogueSid); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListQuery returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/Queries
func (c *Client) ListQuery(ctx context.Context, assistantSid string, params *ListQueryParams, reqEditors ...client.RequestEditorFn) (*ListQueryResponse, error) {
	req, err := newListQueryRequest(c.BaseURL, assistantSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Queries *[]AutopilotV1AssistantQuery `json:"queries,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateQuery: POST /v1/Assistants/{AssistantSid}/Queries

type CreateQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AutopilotV1AssistantQuery
}

// Status returns HTTPResponse.Status
func (r CreateQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateQueryRequestWithBody generates requests for CreateQuery with any type of body
func newCreateQueryRequestWithBody(baseURL *url.URL, assistantSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateQueryFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateQueryWithBody returns a parsed response.
// POST /v1/Assistants/{AssistantSid}/Queries
func (c *Client) CreateQueryWithBody(ctx context.Context, assistantSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateQueryResponse, error) {
	req, err := newCreateQueryRequestWithBody(c.BaseURL, assistantSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AutopilotV1AssistantQuery
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteQuery: DELETE /v1/Assistants/{AssistantSid}/Queries/{Sid}

type DeleteQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteQueryRequest generates requests for DeleteQuery
func newDeleteQueryRequest(baseURL *url.URL, assistantSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteQueryFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteQuery returns a parsed response.
// DELETE /v1/Assistants/{AssistantSid}/Queries/{Sid}
func (c *Client) DeleteQuery(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteQueryResponse, error) {
	req, err := newDeleteQueryRequest(c.BaseURL, assistantSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchQuery: GET /v1/Assistants/{AssistantSid}/Queries/{Sid}

type FetchQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantQuery
}

// Status returns HTTPResponse.Status
func (r FetchQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchQueryRequest generates requests for FetchQuery
func newFetchQueryRequest(baseURL *url.URL, assistantSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchQueryFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchQuery returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/Queries/{Sid}
func (c *Client) FetchQuery(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchQueryResponse, error) {
	req, err := newFetchQueryRequest(c.BaseURL, assistantSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantQuery
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateQuery: POST /v1/Assistants/{AssistantSid}/Queries/{Sid}

type UpdateQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantQuery
}

// Status returns HTTPResponse.Status
func (r UpdateQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateQueryRequestWithBody generates requests for UpdateQuery with any type of body
func newUpdateQueryRequestWithBody(baseURL *url.URL, assistantSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateQueryFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateQueryWithBody returns a parsed response.
// POST /v1/Assistants/{AssistantSid}/Queries/{Sid}
func (c *Client) UpdateQueryWithBody(ctx context.Context, assistantSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateQueryResponse, error) {
	req, err := newUpdateQueryRequestWithBody(c.BaseURL, assistantSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantQuery
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchStyleSheet: GET /v1/Assistants/{AssistantSid}/StyleSheet

type FetchStyleSheetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantStyleSheet
}

// Status returns HTTPResponse.Status
func (r FetchStyleSheetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchStyleSheetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchStyleSheetRequest generates requests for FetchStyleSheet
func newFetchStyleSheetRequest(baseURL *url.URL, assistantSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchStyleSheetFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchStyleSheet returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/StyleSheet
func (c *Client) FetchStyleSheet(ctx context.Context, assistantSid string, reqEditors ...client.RequestEditorFn) (*FetchStyleSheetResponse, error) {
	req, err := newFetchStyleSheetRequest(c.BaseURL, assistantSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchStyleSheetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantStyleSheet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateStyleSheet: POST /v1/Assistants/{AssistantSid}/StyleSheet

type UpdateStyleSheetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantStyleSheet
}

// Status returns HTTPResponse.Status
func (r UpdateStyleSheetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateStyleSheetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateStyleSheetRequestWithBody generates requests for UpdateStyleSheet with any type of body
func newUpdateStyleSheetRequestWithBody(baseURL *url.URL, assistantSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateStyleSheetFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateStyleSheetWithBody returns a parsed response.
// POST /v1/Assistants/{AssistantSid}/StyleSheet
func (c *Client) UpdateStyleSheetWithBody(ctx context.Context, assistantSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateStyleSheetResponse, error) {
	req, err := newUpdateStyleSheetRequestWithBody(c.BaseURL, assistantSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateStyleSheetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantStyleSheet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListTask: GET /v1/Assistants/{AssistantSid}/Tasks

type ListTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Tasks *[]AutopilotV1AssistantTask `json:"tasks,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListTaskRequest generates requests for ListTask
func newListTaskRequest(baseURL *url.URL, assistantSid string, params *ListTaskParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListTaskFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListTask returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/Tasks
func (c *Client) ListTask(ctx context.Context, assistantSid string, params *ListTaskParams, reqEditors ...client.RequestEditorFn) (*ListTaskResponse, error) {
	req, err := newListTaskRequest(c.BaseURL, assistantSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Tasks *[]AutopilotV1AssistantTask `json:"tasks,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateTask: POST /v1/Assistants/{AssistantSid}/Tasks

type CreateTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AutopilotV1AssistantTask
}

// Status returns HTTPResponse.Status
func (r CreateTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateTaskRequestWithBody generates requests for CreateTask with any type of body
func newCreateTaskRequestWithBody(baseURL *url.URL, assistantSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateTaskFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateTaskWithBody returns a parsed response.
// POST /v1/Assistants/{AssistantSid}/Tasks
func (c *Client) CreateTaskWithBody(ctx context.Context, assistantSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateTaskResponse, error) {
	req, err := newCreateTaskRequestWithBody(c.BaseURL, assistantSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AutopilotV1AssistantTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteTask: DELETE /v1/Assistants/{AssistantSid}/Tasks/{Sid}

type DeleteTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteTaskRequest generates requests for DeleteTask
func newDeleteTaskRequest(baseURL *url.URL, assistantSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteTaskFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteTask returns a parsed response.
// DELETE /v1/Assistants/{AssistantSid}/Tasks/{Sid}
func (c *Client) DeleteTask(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteTaskResponse, error) {
	req, err := newDeleteTaskRequest(c.BaseURL, assistantSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchTask: GET /v1/Assistants/{AssistantSid}/Tasks/{Sid}

type FetchTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantTask
}

// Status returns HTTPResponse.Status
func (r FetchTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchTaskRequest generates requests for FetchTask
func newFetchTaskRequest(baseURL *url.URL, assistantSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchTaskFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchTask returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/Tasks/{Sid}
func (c *Client) FetchTask(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchTaskResponse, error) {
	req, err := newFetchTaskRequest(c.BaseURL, assistantSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateTask: POST /v1/Assistants/{AssistantSid}/Tasks/{Sid}

type UpdateTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantTask
}

// Status returns HTTPResponse.Status
func (r UpdateTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateTaskRequestWithBody generates requests for UpdateTask with any type of body
func newUpdateTaskRequestWithBody(baseURL *url.URL, assistantSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateTaskFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateTaskWithBody returns a parsed response.
// POST /v1/Assistants/{AssistantSid}/Tasks/{Sid}
func (c *Client) UpdateTaskWithBody(ctx context.Context, assistantSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateTaskResponse, error) {
	req, err := newUpdateTaskRequestWithBody(c.BaseURL, assistantSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchTaskActions: GET /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Actions

type FetchTaskActionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantTaskTaskActions
}

// Status returns HTTPResponse.Status
func (r FetchTaskActionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTaskActionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchTaskActionsRequest generates requests for FetchTaskActions
func newFetchTaskActionsRequest(baseURL *url.URL, assistantSid string, taskSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("TaskSid", taskSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchTaskActionsFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchTaskActions returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Actions
func (c *Client) FetchTaskActions(ctx context.Context, assistantSid string, taskSid string, reqEditors ...client.RequestEditorFn) (*FetchTaskActionsResponse, error) {
	req, err := newFetchTaskActionsRequest(c.BaseURL, assistantSid, taskSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchTaskActionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantTaskTaskActions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateTaskActions: POST /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Actions

type UpdateTaskActionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantTaskTaskActions
}

// Status returns HTTPResponse.Status
func (r UpdateTaskActionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTaskActionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateTaskActionsRequestWithBody generates requests for UpdateTaskActions with any type of body
func newUpdateTaskActionsRequestWithBody(baseURL *url.URL, assistantSid string, taskSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("TaskSid", taskSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateTaskActionsFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateTaskActionsWithBody returns a parsed response.
// POST /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Actions
func (c *Client) UpdateTaskActionsWithBody(ctx context.Context, assistantSid string, taskSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateTaskActionsResponse, error) {
	req, err := newUpdateTaskActionsRequestWithBody(c.BaseURL, assistantSid, taskSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateTaskActionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantTaskTaskActions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListField: GET /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields

type ListFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Fields *[]AutopilotV1AssistantTaskField `json:"fields,omitempty"`
		Meta   *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListFieldRequest generates requests for ListField
func newListFieldRequest(baseURL *url.URL, assistantSid string, taskSid string, params *ListFieldParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("TaskSid", taskSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListFieldFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListField returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields
func (c *Client) ListField(ctx context.Context, assistantSid string, taskSid string, params *ListFieldParams, reqEditors ...client.RequestEditorFn) (*ListFieldResponse, error) {
	req, err := newListFieldRequest(c.BaseURL, assistantSid, taskSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Fields *[]AutopilotV1AssistantTaskField `json:"fields,omitempty"`
			Meta   *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateField: POST /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields

type CreateFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AutopilotV1AssistantTaskField
}

// Status returns HTTPResponse.Status
func (r CreateFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateFieldRequestWithBody generates requests for CreateField with any type of body
func newCreateFieldRequestWithBody(baseURL *url.URL, assistantSid string, taskSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("TaskSid", taskSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateFieldFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateFieldWithBody returns a parsed response.
// POST /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields
func (c *Client) CreateFieldWithBody(ctx context.Context, assistantSid string, taskSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateFieldResponse, error) {
	req, err := newCreateFieldRequestWithBody(c.BaseURL, assistantSid, taskSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AutopilotV1AssistantTaskField
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteField: DELETE /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields/{Sid}

type DeleteFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteFieldRequest generates requests for DeleteField
func newDeleteFieldRequest(baseURL *url.URL, assistantSid string, taskSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("TaskSid", taskSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteFieldFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteField returns a parsed response.
// DELETE /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields/{Sid}
func (c *Client) DeleteField(ctx context.Context, assistantSid string, taskSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteFieldResponse, error) {
	req, err := newDeleteFieldRequest(c.BaseURL, assistantSid, taskSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchField: GET /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields/{Sid}

type FetchFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantTaskField
}

// Status returns HTTPResponse.Status
func (r FetchFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchFieldRequest generates requests for FetchField
func newFetchFieldRequest(baseURL *url.URL, assistantSid string, taskSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("TaskSid", taskSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchFieldFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchField returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Fields/{Sid}
func (c *Client) FetchField(ctx context.Context, assistantSid string, taskSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchFieldResponse, error) {
	req, err := newFetchFieldRequest(c.BaseURL, assistantSid, taskSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantTaskField
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSample: GET /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples

type ListSampleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Samples *[]AutopilotV1AssistantTaskSample `json:"samples,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSampleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSampleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSampleRequest generates requests for ListSample
func newListSampleRequest(baseURL *url.URL, assistantSid string, taskSid string, params *ListSampleParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("TaskSid", taskSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSampleFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Language != nil {
		if err := client.AddQueryParam(q, "Language", *params.Language); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSample returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples
func (c *Client) ListSample(ctx context.Context, assistantSid string, taskSid string, params *ListSampleParams, reqEditors ...client.RequestEditorFn) (*ListSampleResponse, error) {
	req, err := newListSampleRequest(c.BaseURL, assistantSid, taskSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSampleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Samples *[]AutopilotV1AssistantTaskSample `json:"samples,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSample: POST /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples

type CreateSampleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AutopilotV1AssistantTaskSample
}

// Status returns HTTPResponse.Status
func (r CreateSampleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSampleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSampleRequestWithBody generates requests for CreateSample with any type of body
func newCreateSampleRequestWithBody(baseURL *url.URL, assistantSid string, taskSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("TaskSid", taskSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSampleFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSampleWithBody returns a parsed response.
// POST /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples
func (c *Client) CreateSampleWithBody(ctx context.Context, assistantSid string, taskSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSampleResponse, error) {
	req, err := newCreateSampleRequestWithBody(c.BaseURL, assistantSid, taskSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSampleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AutopilotV1AssistantTaskSample
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteSample: DELETE /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples/{Sid}

type DeleteSampleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSampleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSampleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSampleRequest generates requests for DeleteSample
func newDeleteSampleRequest(baseURL *url.URL, assistantSid string, taskSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("TaskSid", taskSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSampleFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSample returns a parsed response.
// DELETE /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples/{Sid}
func (c *Client) DeleteSample(ctx context.Context, assistantSid string, taskSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSampleResponse, error) {
	req, err := newDeleteSampleRequest(c.BaseURL, assistantSid, taskSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSampleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSample: GET /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples/{Sid}

type FetchSampleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantTaskSample
}

// Status returns HTTPResponse.Status
func (r FetchSampleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSampleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSampleRequest generates requests for FetchSample
func newFetchSampleRequest(baseURL *url.URL, assistantSid string, taskSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("TaskSid", taskSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSampleFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSample returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples/{Sid}
func (c *Client) FetchSample(ctx context.Context, assistantSid string, taskSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSampleResponse, error) {
	req, err := newFetchSampleRequest(c.BaseURL, assistantSid, taskSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSampleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantTaskSample
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSample: POST /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples/{Sid}

type UpdateSampleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantTaskSample
}

// Status returns HTTPResponse.Status
func (r UpdateSampleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSampleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSampleRequestWithBody generates requests for UpdateSample with any type of body
func newUpdateSampleRequestWithBody(baseURL *url.URL, assistantSid string, taskSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("TaskSid", taskSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSampleFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSampleWithBody returns a parsed response.
// POST /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Samples/{Sid}
func (c *Client) UpdateSampleWithBody(ctx context.Context, assistantSid string, taskSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSampleResponse, error) {
	req, err := newUpdateSampleRequestWithBody(c.BaseURL, assistantSid, taskSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSampleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantTaskSample
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchTaskStatistics: GET /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Statistics

type FetchTaskStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantTaskTaskStatistics
}

// Status returns HTTPResponse.Status
func (r FetchTaskStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTaskStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchTaskStatisticsRequest generates requests for FetchTaskStatistics
func newFetchTaskStatisticsRequest(baseURL *url.URL, assistantSid string, taskSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("TaskSid", taskSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchTaskStatisticsFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchTaskStatistics returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/Tasks/{TaskSid}/Statistics
func (c *Client) FetchTaskStatistics(ctx context.Context, assistantSid string, taskSid string, reqEditors ...client.RequestEditorFn) (*FetchTaskStatisticsResponse, error) {
	req, err := newFetchTaskStatisticsRequest(c.BaseURL, assistantSid, taskSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchTaskStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantTaskTaskStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListWebhook: GET /v1/Assistants/{AssistantSid}/Webhooks

type ListWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Webhooks *[]AutopilotV1AssistantWebhook `json:"webhooks,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListWebhookRequest generates requests for ListWebhook
func newListWebhookRequest(baseURL *url.URL, assistantSid string, params *ListWebhookParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListWebhookFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListWebhook returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/Webhooks
func (c *Client) ListWebhook(ctx context.Context, assistantSid string, params *ListWebhookParams, reqEditors ...client.RequestEditorFn) (*ListWebhookResponse, error) {
	req, err := newListWebhookRequest(c.BaseURL, assistantSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Webhooks *[]AutopilotV1AssistantWebhook `json:"webhooks,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateWebhook: POST /v1/Assistants/{AssistantSid}/Webhooks

type CreateWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AutopilotV1AssistantWebhook
}

// Status returns HTTPResponse.Status
func (r CreateWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateWebhookRequestWithBody generates requests for CreateWebhook with any type of body
func newCreateWebhookRequestWithBody(baseURL *url.URL, assistantSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateWebhookFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateWebhookWithBody returns a parsed response.
// POST /v1/Assistants/{AssistantSid}/Webhooks
func (c *Client) CreateWebhookWithBody(ctx context.Context, assistantSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateWebhookResponse, error) {
	req, err := newCreateWebhookRequestWithBody(c.BaseURL, assistantSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AutopilotV1AssistantWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteWebhook: DELETE /v1/Assistants/{AssistantSid}/Webhooks/{Sid}

type DeleteWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteWebhookRequest generates requests for DeleteWebhook
func newDeleteWebhookRequest(baseURL *url.URL, assistantSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteWebhookFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteWebhook returns a parsed response.
// DELETE /v1/Assistants/{AssistantSid}/Webhooks/{Sid}
func (c *Client) DeleteWebhook(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteWebhookResponse, error) {
	req, err := newDeleteWebhookRequest(c.BaseURL, assistantSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchWebhook: GET /v1/Assistants/{AssistantSid}/Webhooks/{Sid}

type FetchWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantWebhook
}

// Status returns HTTPResponse.Status
func (r FetchWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchWebhookRequest generates requests for FetchWebhook
func newFetchWebhookRequest(baseURL *url.URL, assistantSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchWebhookFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchWebhook returns a parsed response.
// GET /v1/Assistants/{AssistantSid}/Webhooks/{Sid}
func (c *Client) FetchWebhook(ctx context.Context, assistantSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchWebhookResponse, error) {
	req, err := newFetchWebhookRequest(c.BaseURL, assistantSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateWebhook: POST /v1/Assistants/{AssistantSid}/Webhooks/{Sid}

type UpdateWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1AssistantWebhook
}

// Status returns HTTPResponse.Status
func (r UpdateWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateWebhookRequestWithBody generates requests for UpdateWebhook with any type of body
func newUpdateWebhookRequestWithBody(baseURL *url.URL, assistantSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AssistantSid", assistantSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateWebhookFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateWebhookWithBody returns a parsed response.
// POST /v1/Assistants/{AssistantSid}/Webhooks/{Sid}
func (c *Client) UpdateWebhookWithBody(ctx context.Context, assistantSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateWebhookResponse, error) {
	req, err := newUpdateWebhookRequestWithBody(c.BaseURL, assistantSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1AssistantWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteAssistant: DELETE /v1/Assistants/{Sid}

type DeleteAssistantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteAssistantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAssistantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteAssistantRequest generates requests for DeleteAssistant
func newDeleteAssistantRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteAssistantFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteAssistant returns a parsed response.
// DELETE /v1/Assistants/{Sid}
func (c *Client) DeleteAssistant(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteAssistantResponse, error) {
	req, err := newDeleteAssistantRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteAssistantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchAssistant: GET /v1/Assistants/{Sid}

type FetchAssistantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1Assistant
}

// Status returns HTTPResponse.Status
func (r FetchAssistantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchAssistantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchAssistantRequest generates requests for FetchAssistant
func newFetchAssistantRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchAssistantFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchAssistant returns a parsed response.
// GET /v1/Assistants/{Sid}
func (c *Client) FetchAssistant(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchAssistantResponse, error) {
	req, err := newFetchAssistantRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchAssistantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1Assistant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateAssistant: POST /v1/Assistants/{Sid}

type UpdateAssistantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutopilotV1Assistant
}

// Status returns HTTPResponse.Status
func (r UpdateAssistantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAssistantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateAssistantRequestWithBody generates requests for UpdateAssistant with any type of body
func newUpdateAssistantRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateAssistantFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateAssistantWithBody returns a parsed response.
// POST /v1/Assistants/{Sid}
func (c *Client) UpdateAssistantWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateAssistantResponse, error) {
	req, err := newUpdateAssistantRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateAssistantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutopilotV1Assistant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
