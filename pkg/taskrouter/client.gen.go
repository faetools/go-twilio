// Package taskrouter provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package taskrouter

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/faetools/client"
)

// operation paths

const (
	opPathDeleteWorkspaceFormat                    = "./v1/Workspaces/%s"
	opPathFetchWorkspaceFormat                     = "./v1/Workspaces/%s"
	opPathUpdateWorkspaceFormat                    = "./v1/Workspaces/%s"
	opPathListActivityFormat                       = "./v1/Workspaces/%s/Activities"
	opPathCreateActivityFormat                     = "./v1/Workspaces/%s/Activities"
	opPathDeleteActivityFormat                     = "./v1/Workspaces/%s/Activities/%s"
	opPathFetchActivityFormat                      = "./v1/Workspaces/%s/Activities/%s"
	opPathUpdateActivityFormat                     = "./v1/Workspaces/%s/Activities/%s"
	opPathFetchWorkspaceCumulativeStatisticsFormat = "./v1/Workspaces/%s/CumulativeStatistics"
	opPathListEventFormat                          = "./v1/Workspaces/%s/Events"
	opPathFetchEventFormat                         = "./v1/Workspaces/%s/Events/%s"
	opPathFetchWorkspaceRealTimeStatisticsFormat   = "./v1/Workspaces/%s/RealTimeStatistics"
	opPathFetchWorkspaceStatisticsFormat           = "./v1/Workspaces/%s/Statistics"
	opPathListTaskChannelFormat                    = "./v1/Workspaces/%s/TaskChannels"
	opPathCreateTaskChannelFormat                  = "./v1/Workspaces/%s/TaskChannels"
	opPathDeleteTaskChannelFormat                  = "./v1/Workspaces/%s/TaskChannels/%s"
	opPathFetchTaskChannelFormat                   = "./v1/Workspaces/%s/TaskChannels/%s"
	opPathUpdateTaskChannelFormat                  = "./v1/Workspaces/%s/TaskChannels/%s"
	opPathListTaskQueueFormat                      = "./v1/Workspaces/%s/TaskQueues"
	opPathCreateTaskQueueFormat                    = "./v1/Workspaces/%s/TaskQueues"
	opPathListTaskQueuesStatisticsFormat           = "./v1/Workspaces/%s/TaskQueues/Statistics"
	opPathDeleteTaskQueueFormat                    = "./v1/Workspaces/%s/TaskQueues/%s"
	opPathFetchTaskQueueFormat                     = "./v1/Workspaces/%s/TaskQueues/%s"
	opPathUpdateTaskQueueFormat                    = "./v1/Workspaces/%s/TaskQueues/%s"
	opPathFetchTaskQueueCumulativeStatisticsFormat = "./v1/Workspaces/%s/TaskQueues/%s/CumulativeStatistics"
	opPathFetchTaskQueueRealTimeStatisticsFormat   = "./v1/Workspaces/%s/TaskQueues/%s/RealTimeStatistics"
	opPathFetchTaskQueueStatisticsFormat           = "./v1/Workspaces/%s/TaskQueues/%s/Statistics"
	opPathListTaskFormat                           = "./v1/Workspaces/%s/Tasks"
	opPathCreateTaskFormat                         = "./v1/Workspaces/%s/Tasks"
	opPathDeleteTaskFormat                         = "./v1/Workspaces/%s/Tasks/%s"
	opPathFetchTaskFormat                          = "./v1/Workspaces/%s/Tasks/%s"
	opPathUpdateTaskFormat                         = "./v1/Workspaces/%s/Tasks/%s"
	opPathListTaskReservationFormat                = "./v1/Workspaces/%s/Tasks/%s/Reservations"
	opPathFetchTaskReservationFormat               = "./v1/Workspaces/%s/Tasks/%s/Reservations/%s"
	opPathUpdateTaskReservationFormat              = "./v1/Workspaces/%s/Tasks/%s/Reservations/%s"
	opPathListWorkerFormat                         = "./v1/Workspaces/%s/Workers"
	opPathCreateWorkerFormat                       = "./v1/Workspaces/%s/Workers"
	opPathFetchWorkersCumulativeStatisticsFormat   = "./v1/Workspaces/%s/Workers/CumulativeStatistics"
	opPathFetchWorkersRealTimeStatisticsFormat     = "./v1/Workspaces/%s/Workers/RealTimeStatistics"
	opPathFetchWorkerStatisticsFormat              = "./v1/Workspaces/%s/Workers/Statistics"
	opPathDeleteWorkerFormat                       = "./v1/Workspaces/%s/Workers/%s"
	opPathFetchWorkerFormat                        = "./v1/Workspaces/%s/Workers/%s"
	opPathUpdateWorkerFormat                       = "./v1/Workspaces/%s/Workers/%s"
	opPathListWorkerChannelFormat                  = "./v1/Workspaces/%s/Workers/%s/Channels"
	opPathFetchWorkerChannelFormat                 = "./v1/Workspaces/%s/Workers/%s/Channels/%s"
	opPathUpdateWorkerChannelFormat                = "./v1/Workspaces/%s/Workers/%s/Channels/%s"
	opPathListWorkerReservationFormat              = "./v1/Workspaces/%s/Workers/%s/Reservations"
	opPathFetchWorkerReservationFormat             = "./v1/Workspaces/%s/Workers/%s/Reservations/%s"
	opPathUpdateWorkerReservationFormat            = "./v1/Workspaces/%s/Workers/%s/Reservations/%s"
	opPathFetchWorkerInstanceStatisticsFormat      = "./v1/Workspaces/%s/Workers/%s/Statistics"
	opPathListWorkflowFormat                       = "./v1/Workspaces/%s/Workflows"
	opPathCreateWorkflowFormat                     = "./v1/Workspaces/%s/Workflows"
	opPathDeleteWorkflowFormat                     = "./v1/Workspaces/%s/Workflows/%s"
	opPathFetchWorkflowFormat                      = "./v1/Workspaces/%s/Workflows/%s"
	opPathUpdateWorkflowFormat                     = "./v1/Workspaces/%s/Workflows/%s"
	opPathFetchWorkflowCumulativeStatisticsFormat  = "./v1/Workspaces/%s/Workflows/%s/CumulativeStatistics"
	opPathFetchWorkflowRealTimeStatisticsFormat    = "./v1/Workspaces/%s/Workflows/%s/RealTimeStatistics"
	opPathFetchWorkflowStatisticsFormat            = "./v1/Workspaces/%s/Workflows/%s/Statistics"
)

var (
	opPathListWorkspace   = client.MustParseURL("./v1/Workspaces")
	opPathCreateWorkspace = client.MustParseURL("./v1/Workspaces")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// ListWorkspace request
	ListWorkspace(ctx context.Context, params *ListWorkspaceParams, reqEditors ...client.RequestEditorFn) (*ListWorkspaceResponse, error)

	// CreateWorkspace request with any body
	CreateWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateWorkspaceResponse, error)

	// DeleteWorkspace request
	DeleteWorkspace(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteWorkspaceResponse, error)

	// FetchWorkspace request
	FetchWorkspace(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchWorkspaceResponse, error)

	// UpdateWorkspace request with any body
	UpdateWorkspaceWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateWorkspaceResponse, error)

	// ListActivity request
	ListActivity(ctx context.Context, workspaceSid string, params *ListActivityParams, reqEditors ...client.RequestEditorFn) (*ListActivityResponse, error)

	// CreateActivity request with any body
	CreateActivityWithBody(ctx context.Context, workspaceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateActivityResponse, error)

	// DeleteActivity request
	DeleteActivity(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteActivityResponse, error)

	// FetchActivity request
	FetchActivity(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchActivityResponse, error)

	// UpdateActivity request with any body
	UpdateActivityWithBody(ctx context.Context, workspaceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateActivityResponse, error)

	// FetchWorkspaceCumulativeStatistics request
	FetchWorkspaceCumulativeStatistics(ctx context.Context, workspaceSid string, params *FetchWorkspaceCumulativeStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchWorkspaceCumulativeStatisticsResponse, error)

	// ListEvent request
	ListEvent(ctx context.Context, workspaceSid string, params *ListEventParams, reqEditors ...client.RequestEditorFn) (*ListEventResponse, error)

	// FetchEvent request
	FetchEvent(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchEventResponse, error)

	// FetchWorkspaceRealTimeStatistics request
	FetchWorkspaceRealTimeStatistics(ctx context.Context, workspaceSid string, params *FetchWorkspaceRealTimeStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchWorkspaceRealTimeStatisticsResponse, error)

	// FetchWorkspaceStatistics request
	FetchWorkspaceStatistics(ctx context.Context, workspaceSid string, params *FetchWorkspaceStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchWorkspaceStatisticsResponse, error)

	// ListTaskChannel request
	ListTaskChannel(ctx context.Context, workspaceSid string, params *ListTaskChannelParams, reqEditors ...client.RequestEditorFn) (*ListTaskChannelResponse, error)

	// CreateTaskChannel request with any body
	CreateTaskChannelWithBody(ctx context.Context, workspaceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateTaskChannelResponse, error)

	// DeleteTaskChannel request
	DeleteTaskChannel(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteTaskChannelResponse, error)

	// FetchTaskChannel request
	FetchTaskChannel(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchTaskChannelResponse, error)

	// UpdateTaskChannel request with any body
	UpdateTaskChannelWithBody(ctx context.Context, workspaceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateTaskChannelResponse, error)

	// ListTaskQueue request
	ListTaskQueue(ctx context.Context, workspaceSid string, params *ListTaskQueueParams, reqEditors ...client.RequestEditorFn) (*ListTaskQueueResponse, error)

	// CreateTaskQueue request with any body
	CreateTaskQueueWithBody(ctx context.Context, workspaceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateTaskQueueResponse, error)

	// ListTaskQueuesStatistics request
	ListTaskQueuesStatistics(ctx context.Context, workspaceSid string, params *ListTaskQueuesStatisticsParams, reqEditors ...client.RequestEditorFn) (*ListTaskQueuesStatisticsResponse, error)

	// DeleteTaskQueue request
	DeleteTaskQueue(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteTaskQueueResponse, error)

	// FetchTaskQueue request
	FetchTaskQueue(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchTaskQueueResponse, error)

	// UpdateTaskQueue request with any body
	UpdateTaskQueueWithBody(ctx context.Context, workspaceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateTaskQueueResponse, error)

	// FetchTaskQueueCumulativeStatistics request
	FetchTaskQueueCumulativeStatistics(ctx context.Context, workspaceSid string, taskQueueSid string, params *FetchTaskQueueCumulativeStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchTaskQueueCumulativeStatisticsResponse, error)

	// FetchTaskQueueRealTimeStatistics request
	FetchTaskQueueRealTimeStatistics(ctx context.Context, workspaceSid string, taskQueueSid string, params *FetchTaskQueueRealTimeStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchTaskQueueRealTimeStatisticsResponse, error)

	// FetchTaskQueueStatistics request
	FetchTaskQueueStatistics(ctx context.Context, workspaceSid string, taskQueueSid string, params *FetchTaskQueueStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchTaskQueueStatisticsResponse, error)

	// ListTask request
	ListTask(ctx context.Context, workspaceSid string, params *ListTaskParams, reqEditors ...client.RequestEditorFn) (*ListTaskResponse, error)

	// CreateTask request with any body
	CreateTaskWithBody(ctx context.Context, workspaceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateTaskResponse, error)

	// DeleteTask request
	DeleteTask(ctx context.Context, workspaceSid string, sid string, params *DeleteTaskParams, reqEditors ...client.RequestEditorFn) (*DeleteTaskResponse, error)

	// FetchTask request
	FetchTask(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchTaskResponse, error)

	// UpdateTask request with any body
	UpdateTaskWithBody(ctx context.Context, workspaceSid string, sid string, params *UpdateTaskParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateTaskResponse, error)

	// ListTaskReservation request
	ListTaskReservation(ctx context.Context, workspaceSid string, taskSid string, params *ListTaskReservationParams, reqEditors ...client.RequestEditorFn) (*ListTaskReservationResponse, error)

	// FetchTaskReservation request
	FetchTaskReservation(ctx context.Context, workspaceSid string, taskSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchTaskReservationResponse, error)

	// UpdateTaskReservation request with any body
	UpdateTaskReservationWithBody(ctx context.Context, workspaceSid string, taskSid string, sid string, params *UpdateTaskReservationParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateTaskReservationResponse, error)

	// ListWorker request
	ListWorker(ctx context.Context, workspaceSid string, params *ListWorkerParams, reqEditors ...client.RequestEditorFn) (*ListWorkerResponse, error)

	// CreateWorker request with any body
	CreateWorkerWithBody(ctx context.Context, workspaceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateWorkerResponse, error)

	// FetchWorkersCumulativeStatistics request
	FetchWorkersCumulativeStatistics(ctx context.Context, workspaceSid string, params *FetchWorkersCumulativeStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchWorkersCumulativeStatisticsResponse, error)

	// FetchWorkersRealTimeStatistics request
	FetchWorkersRealTimeStatistics(ctx context.Context, workspaceSid string, params *FetchWorkersRealTimeStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchWorkersRealTimeStatisticsResponse, error)

	// FetchWorkerStatistics request
	FetchWorkerStatistics(ctx context.Context, workspaceSid string, params *FetchWorkerStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchWorkerStatisticsResponse, error)

	// DeleteWorker request
	DeleteWorker(ctx context.Context, workspaceSid string, sid string, params *DeleteWorkerParams, reqEditors ...client.RequestEditorFn) (*DeleteWorkerResponse, error)

	// FetchWorker request
	FetchWorker(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchWorkerResponse, error)

	// UpdateWorker request with any body
	UpdateWorkerWithBody(ctx context.Context, workspaceSid string, sid string, params *UpdateWorkerParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateWorkerResponse, error)

	// ListWorkerChannel request
	ListWorkerChannel(ctx context.Context, workspaceSid string, workerSid string, params *ListWorkerChannelParams, reqEditors ...client.RequestEditorFn) (*ListWorkerChannelResponse, error)

	// FetchWorkerChannel request
	FetchWorkerChannel(ctx context.Context, workspaceSid string, workerSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchWorkerChannelResponse, error)

	// UpdateWorkerChannel request with any body
	UpdateWorkerChannelWithBody(ctx context.Context, workspaceSid string, workerSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateWorkerChannelResponse, error)

	// ListWorkerReservation request
	ListWorkerReservation(ctx context.Context, workspaceSid string, workerSid string, params *ListWorkerReservationParams, reqEditors ...client.RequestEditorFn) (*ListWorkerReservationResponse, error)

	// FetchWorkerReservation request
	FetchWorkerReservation(ctx context.Context, workspaceSid string, workerSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchWorkerReservationResponse, error)

	// UpdateWorkerReservation request with any body
	UpdateWorkerReservationWithBody(ctx context.Context, workspaceSid string, workerSid string, sid string, params *UpdateWorkerReservationParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateWorkerReservationResponse, error)

	// FetchWorkerInstanceStatistics request
	FetchWorkerInstanceStatistics(ctx context.Context, workspaceSid string, workerSid string, params *FetchWorkerInstanceStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchWorkerInstanceStatisticsResponse, error)

	// ListWorkflow request
	ListWorkflow(ctx context.Context, workspaceSid string, params *ListWorkflowParams, reqEditors ...client.RequestEditorFn) (*ListWorkflowResponse, error)

	// CreateWorkflow request with any body
	CreateWorkflowWithBody(ctx context.Context, workspaceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateWorkflowResponse, error)

	// DeleteWorkflow request
	DeleteWorkflow(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteWorkflowResponse, error)

	// FetchWorkflow request
	FetchWorkflow(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchWorkflowResponse, error)

	// UpdateWorkflow request with any body
	UpdateWorkflowWithBody(ctx context.Context, workspaceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateWorkflowResponse, error)

	// FetchWorkflowCumulativeStatistics request
	FetchWorkflowCumulativeStatistics(ctx context.Context, workspaceSid string, workflowSid string, params *FetchWorkflowCumulativeStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchWorkflowCumulativeStatisticsResponse, error)

	// FetchWorkflowRealTimeStatistics request
	FetchWorkflowRealTimeStatistics(ctx context.Context, workspaceSid string, workflowSid string, params *FetchWorkflowRealTimeStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchWorkflowRealTimeStatisticsResponse, error)

	// FetchWorkflowStatistics request
	FetchWorkflowStatistics(ctx context.Context, workspaceSid string, workflowSid string, params *FetchWorkflowStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchWorkflowStatisticsResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// ListWorkspace: GET /v1/Workspaces

type ListWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Workspaces *[]TaskrouterV1Workspace `json:"workspaces,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListWorkspaceRequest generates requests for ListWorkspace
func newListWorkspaceRequest(baseURL *url.URL, params *ListWorkspaceParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListWorkspace)

	q := queryURL.Query()

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListWorkspace returns a parsed response.
// GET /v1/Workspaces
func (c *Client) ListWorkspace(ctx context.Context, params *ListWorkspaceParams, reqEditors ...client.RequestEditorFn) (*ListWorkspaceResponse, error) {
	req, err := newListWorkspaceRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Workspaces *[]TaskrouterV1Workspace `json:"workspaces,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateWorkspace: POST /v1/Workspaces

type CreateWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TaskrouterV1Workspace
}

// Status returns HTTPResponse.Status
func (r CreateWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateWorkspaceRequestWithBody generates requests for CreateWorkspace with any type of body
func newCreateWorkspaceRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateWorkspace)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateWorkspaceWithBody returns a parsed response.
// POST /v1/Workspaces
func (c *Client) CreateWorkspaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateWorkspaceResponse, error) {
	req, err := newCreateWorkspaceRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TaskrouterV1Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteWorkspace: DELETE /v1/Workspaces/{Sid}

type DeleteWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteWorkspaceRequest generates requests for DeleteWorkspace
func newDeleteWorkspaceRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteWorkspaceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteWorkspace returns a parsed response.
// DELETE /v1/Workspaces/{Sid}
func (c *Client) DeleteWorkspace(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteWorkspaceResponse, error) {
	req, err := newDeleteWorkspaceRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchWorkspace: GET /v1/Workspaces/{Sid}

type FetchWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1Workspace
}

// Status returns HTTPResponse.Status
func (r FetchWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchWorkspaceRequest generates requests for FetchWorkspace
func newFetchWorkspaceRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchWorkspaceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchWorkspace returns a parsed response.
// GET /v1/Workspaces/{Sid}
func (c *Client) FetchWorkspace(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchWorkspaceResponse, error) {
	req, err := newFetchWorkspaceRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateWorkspace: POST /v1/Workspaces/{Sid}

type UpdateWorkspaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1Workspace
}

// Status returns HTTPResponse.Status
func (r UpdateWorkspaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWorkspaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateWorkspaceRequestWithBody generates requests for UpdateWorkspace with any type of body
func newUpdateWorkspaceRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateWorkspaceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateWorkspaceWithBody returns a parsed response.
// POST /v1/Workspaces/{Sid}
func (c *Client) UpdateWorkspaceWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateWorkspaceResponse, error) {
	req, err := newUpdateWorkspaceRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateWorkspaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1Workspace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListActivity: GET /v1/Workspaces/{WorkspaceSid}/Activities

type ListActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Activities *[]TaskrouterV1WorkspaceActivity `json:"activities,omitempty"`
		Meta       *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListActivityRequest generates requests for ListActivity
func newListActivityRequest(baseURL *url.URL, workspaceSid string, params *ListActivityParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListActivityFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.Available != nil {
		if err := client.AddQueryParam(q, "Available", *params.Available); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListActivity returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Activities
func (c *Client) ListActivity(ctx context.Context, workspaceSid string, params *ListActivityParams, reqEditors ...client.RequestEditorFn) (*ListActivityResponse, error) {
	req, err := newListActivityRequest(c.BaseURL, workspaceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Activities *[]TaskrouterV1WorkspaceActivity `json:"activities,omitempty"`
			Meta       *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateActivity: POST /v1/Workspaces/{WorkspaceSid}/Activities

type CreateActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TaskrouterV1WorkspaceActivity
}

// Status returns HTTPResponse.Status
func (r CreateActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateActivityRequestWithBody generates requests for CreateActivity with any type of body
func newCreateActivityRequestWithBody(baseURL *url.URL, workspaceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateActivityFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateActivityWithBody returns a parsed response.
// POST /v1/Workspaces/{WorkspaceSid}/Activities
func (c *Client) CreateActivityWithBody(ctx context.Context, workspaceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateActivityResponse, error) {
	req, err := newCreateActivityRequestWithBody(c.BaseURL, workspaceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TaskrouterV1WorkspaceActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteActivity: DELETE /v1/Workspaces/{WorkspaceSid}/Activities/{Sid}

type DeleteActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteActivityRequest generates requests for DeleteActivity
func newDeleteActivityRequest(baseURL *url.URL, workspaceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteActivityFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteActivity returns a parsed response.
// DELETE /v1/Workspaces/{WorkspaceSid}/Activities/{Sid}
func (c *Client) DeleteActivity(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteActivityResponse, error) {
	req, err := newDeleteActivityRequest(c.BaseURL, workspaceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchActivity: GET /v1/Workspaces/{WorkspaceSid}/Activities/{Sid}

type FetchActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceActivity
}

// Status returns HTTPResponse.Status
func (r FetchActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchActivityRequest generates requests for FetchActivity
func newFetchActivityRequest(baseURL *url.URL, workspaceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchActivityFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchActivity returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Activities/{Sid}
func (c *Client) FetchActivity(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchActivityResponse, error) {
	req, err := newFetchActivityRequest(c.BaseURL, workspaceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateActivity: POST /v1/Workspaces/{WorkspaceSid}/Activities/{Sid}

type UpdateActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceActivity
}

// Status returns HTTPResponse.Status
func (r UpdateActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateActivityRequestWithBody generates requests for UpdateActivity with any type of body
func newUpdateActivityRequestWithBody(baseURL *url.URL, workspaceSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateActivityFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateActivityWithBody returns a parsed response.
// POST /v1/Workspaces/{WorkspaceSid}/Activities/{Sid}
func (c *Client) UpdateActivityWithBody(ctx context.Context, workspaceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateActivityResponse, error) {
	req, err := newUpdateActivityRequestWithBody(c.BaseURL, workspaceSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchWorkspaceCumulativeStatistics: GET /v1/Workspaces/{WorkspaceSid}/CumulativeStatistics

type FetchWorkspaceCumulativeStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceWorkspaceCumulativeStatistics
}

// Status returns HTTPResponse.Status
func (r FetchWorkspaceCumulativeStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchWorkspaceCumulativeStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchWorkspaceCumulativeStatisticsRequest generates requests for FetchWorkspaceCumulativeStatistics
func newFetchWorkspaceCumulativeStatisticsRequest(baseURL *url.URL, workspaceSid string, params *FetchWorkspaceCumulativeStatisticsParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchWorkspaceCumulativeStatisticsFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.Minutes != nil {
		if err := client.AddQueryParam(q, "Minutes", *params.Minutes); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.TaskChannel != nil {
		if err := client.AddQueryParam(q, "TaskChannel", *params.TaskChannel); err != nil {
			return nil, err
		}
	}

	if params.SplitByWaitTime != nil {
		if err := client.AddQueryParam(q, "SplitByWaitTime", *params.SplitByWaitTime); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchWorkspaceCumulativeStatistics returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/CumulativeStatistics
func (c *Client) FetchWorkspaceCumulativeStatistics(ctx context.Context, workspaceSid string, params *FetchWorkspaceCumulativeStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchWorkspaceCumulativeStatisticsResponse, error) {
	req, err := newFetchWorkspaceCumulativeStatisticsRequest(c.BaseURL, workspaceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchWorkspaceCumulativeStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceWorkspaceCumulativeStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListEvent: GET /v1/Workspaces/{WorkspaceSid}/Events

type ListEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Events *[]TaskrouterV1WorkspaceEvent `json:"events,omitempty"`
		Meta   *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListEventRequest generates requests for ListEvent
func newListEventRequest(baseURL *url.URL, workspaceSid string, params *ListEventParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListEventFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.EventType != nil {
		if err := client.AddQueryParam(q, "EventType", *params.EventType); err != nil {
			return nil, err
		}
	}

	if params.Minutes != nil {
		if err := client.AddQueryParam(q, "Minutes", *params.Minutes); err != nil {
			return nil, err
		}
	}

	if params.ReservationSid != nil {
		if err := client.AddQueryParam(q, "ReservationSid", *params.ReservationSid); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.TaskQueueSid != nil {
		if err := client.AddQueryParam(q, "TaskQueueSid", *params.TaskQueueSid); err != nil {
			return nil, err
		}
	}

	if params.TaskSid != nil {
		if err := client.AddQueryParam(q, "TaskSid", *params.TaskSid); err != nil {
			return nil, err
		}
	}

	if params.WorkerSid != nil {
		if err := client.AddQueryParam(q, "WorkerSid", *params.WorkerSid); err != nil {
			return nil, err
		}
	}

	if params.WorkflowSid != nil {
		if err := client.AddQueryParam(q, "WorkflowSid", *params.WorkflowSid); err != nil {
			return nil, err
		}
	}

	if params.TaskChannel != nil {
		if err := client.AddQueryParam(q, "TaskChannel", *params.TaskChannel); err != nil {
			return nil, err
		}
	}

	if params.Sid != nil {
		if err := client.AddQueryParam(q, "Sid", *params.Sid); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListEvent returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Events
func (c *Client) ListEvent(ctx context.Context, workspaceSid string, params *ListEventParams, reqEditors ...client.RequestEditorFn) (*ListEventResponse, error) {
	req, err := newListEventRequest(c.BaseURL, workspaceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Events *[]TaskrouterV1WorkspaceEvent `json:"events,omitempty"`
			Meta   *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchEvent: GET /v1/Workspaces/{WorkspaceSid}/Events/{Sid}

type FetchEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceEvent
}

// Status returns HTTPResponse.Status
func (r FetchEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchEventRequest generates requests for FetchEvent
func newFetchEventRequest(baseURL *url.URL, workspaceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchEventFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchEvent returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Events/{Sid}
func (c *Client) FetchEvent(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchEventResponse, error) {
	req, err := newFetchEventRequest(c.BaseURL, workspaceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchWorkspaceRealTimeStatistics: GET /v1/Workspaces/{WorkspaceSid}/RealTimeStatistics

type FetchWorkspaceRealTimeStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceWorkspaceRealTimeStatistics
}

// Status returns HTTPResponse.Status
func (r FetchWorkspaceRealTimeStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchWorkspaceRealTimeStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchWorkspaceRealTimeStatisticsRequest generates requests for FetchWorkspaceRealTimeStatistics
func newFetchWorkspaceRealTimeStatisticsRequest(baseURL *url.URL, workspaceSid string, params *FetchWorkspaceRealTimeStatisticsParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchWorkspaceRealTimeStatisticsFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.TaskChannel != nil {
		if err := client.AddQueryParam(q, "TaskChannel", *params.TaskChannel); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchWorkspaceRealTimeStatistics returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/RealTimeStatistics
func (c *Client) FetchWorkspaceRealTimeStatistics(ctx context.Context, workspaceSid string, params *FetchWorkspaceRealTimeStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchWorkspaceRealTimeStatisticsResponse, error) {
	req, err := newFetchWorkspaceRealTimeStatisticsRequest(c.BaseURL, workspaceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchWorkspaceRealTimeStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceWorkspaceRealTimeStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchWorkspaceStatistics: GET /v1/Workspaces/{WorkspaceSid}/Statistics

type FetchWorkspaceStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceWorkspaceStatistics
}

// Status returns HTTPResponse.Status
func (r FetchWorkspaceStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchWorkspaceStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchWorkspaceStatisticsRequest generates requests for FetchWorkspaceStatistics
func newFetchWorkspaceStatisticsRequest(baseURL *url.URL, workspaceSid string, params *FetchWorkspaceStatisticsParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchWorkspaceStatisticsFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Minutes != nil {
		if err := client.AddQueryParam(q, "Minutes", *params.Minutes); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.TaskChannel != nil {
		if err := client.AddQueryParam(q, "TaskChannel", *params.TaskChannel); err != nil {
			return nil, err
		}
	}

	if params.SplitByWaitTime != nil {
		if err := client.AddQueryParam(q, "SplitByWaitTime", *params.SplitByWaitTime); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchWorkspaceStatistics returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Statistics
func (c *Client) FetchWorkspaceStatistics(ctx context.Context, workspaceSid string, params *FetchWorkspaceStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchWorkspaceStatisticsResponse, error) {
	req, err := newFetchWorkspaceStatisticsRequest(c.BaseURL, workspaceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchWorkspaceStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceWorkspaceStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListTaskChannel: GET /v1/Workspaces/{WorkspaceSid}/TaskChannels

type ListTaskChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Channels *[]TaskrouterV1WorkspaceTaskChannel `json:"channels,omitempty"`
		Meta     *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListTaskChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTaskChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListTaskChannelRequest generates requests for ListTaskChannel
func newListTaskChannelRequest(baseURL *url.URL, workspaceSid string, params *ListTaskChannelParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListTaskChannelFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListTaskChannel returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/TaskChannels
func (c *Client) ListTaskChannel(ctx context.Context, workspaceSid string, params *ListTaskChannelParams, reqEditors ...client.RequestEditorFn) (*ListTaskChannelResponse, error) {
	req, err := newListTaskChannelRequest(c.BaseURL, workspaceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListTaskChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Channels *[]TaskrouterV1WorkspaceTaskChannel `json:"channels,omitempty"`
			Meta     *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateTaskChannel: POST /v1/Workspaces/{WorkspaceSid}/TaskChannels

type CreateTaskChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TaskrouterV1WorkspaceTaskChannel
}

// Status returns HTTPResponse.Status
func (r CreateTaskChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTaskChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateTaskChannelRequestWithBody generates requests for CreateTaskChannel with any type of body
func newCreateTaskChannelRequestWithBody(baseURL *url.URL, workspaceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateTaskChannelFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateTaskChannelWithBody returns a parsed response.
// POST /v1/Workspaces/{WorkspaceSid}/TaskChannels
func (c *Client) CreateTaskChannelWithBody(ctx context.Context, workspaceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateTaskChannelResponse, error) {
	req, err := newCreateTaskChannelRequestWithBody(c.BaseURL, workspaceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateTaskChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TaskrouterV1WorkspaceTaskChannel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteTaskChannel: DELETE /v1/Workspaces/{WorkspaceSid}/TaskChannels/{Sid}

type DeleteTaskChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTaskChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTaskChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteTaskChannelRequest generates requests for DeleteTaskChannel
func newDeleteTaskChannelRequest(baseURL *url.URL, workspaceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteTaskChannelFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteTaskChannel returns a parsed response.
// DELETE /v1/Workspaces/{WorkspaceSid}/TaskChannels/{Sid}
func (c *Client) DeleteTaskChannel(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteTaskChannelResponse, error) {
	req, err := newDeleteTaskChannelRequest(c.BaseURL, workspaceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteTaskChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchTaskChannel: GET /v1/Workspaces/{WorkspaceSid}/TaskChannels/{Sid}

type FetchTaskChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceTaskChannel
}

// Status returns HTTPResponse.Status
func (r FetchTaskChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTaskChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchTaskChannelRequest generates requests for FetchTaskChannel
func newFetchTaskChannelRequest(baseURL *url.URL, workspaceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchTaskChannelFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchTaskChannel returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/TaskChannels/{Sid}
func (c *Client) FetchTaskChannel(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchTaskChannelResponse, error) {
	req, err := newFetchTaskChannelRequest(c.BaseURL, workspaceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchTaskChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceTaskChannel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateTaskChannel: POST /v1/Workspaces/{WorkspaceSid}/TaskChannels/{Sid}

type UpdateTaskChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceTaskChannel
}

// Status returns HTTPResponse.Status
func (r UpdateTaskChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTaskChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateTaskChannelRequestWithBody generates requests for UpdateTaskChannel with any type of body
func newUpdateTaskChannelRequestWithBody(baseURL *url.URL, workspaceSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateTaskChannelFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateTaskChannelWithBody returns a parsed response.
// POST /v1/Workspaces/{WorkspaceSid}/TaskChannels/{Sid}
func (c *Client) UpdateTaskChannelWithBody(ctx context.Context, workspaceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateTaskChannelResponse, error) {
	req, err := newUpdateTaskChannelRequestWithBody(c.BaseURL, workspaceSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateTaskChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceTaskChannel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListTaskQueue: GET /v1/Workspaces/{WorkspaceSid}/TaskQueues

type ListTaskQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		TaskQueues *[]TaskrouterV1WorkspaceTaskQueue `json:"task_queues,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListTaskQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTaskQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListTaskQueueRequest generates requests for ListTaskQueue
func newListTaskQueueRequest(baseURL *url.URL, workspaceSid string, params *ListTaskQueueParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListTaskQueueFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.EvaluateWorkerAttributes != nil {
		if err := client.AddQueryParam(q, "EvaluateWorkerAttributes", *params.EvaluateWorkerAttributes); err != nil {
			return nil, err
		}
	}

	if params.WorkerSid != nil {
		if err := client.AddQueryParam(q, "WorkerSid", *params.WorkerSid); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListTaskQueue returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/TaskQueues
func (c *Client) ListTaskQueue(ctx context.Context, workspaceSid string, params *ListTaskQueueParams, reqEditors ...client.RequestEditorFn) (*ListTaskQueueResponse, error) {
	req, err := newListTaskQueueRequest(c.BaseURL, workspaceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListTaskQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			TaskQueues *[]TaskrouterV1WorkspaceTaskQueue `json:"task_queues,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateTaskQueue: POST /v1/Workspaces/{WorkspaceSid}/TaskQueues

type CreateTaskQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TaskrouterV1WorkspaceTaskQueue
}

// Status returns HTTPResponse.Status
func (r CreateTaskQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTaskQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateTaskQueueRequestWithBody generates requests for CreateTaskQueue with any type of body
func newCreateTaskQueueRequestWithBody(baseURL *url.URL, workspaceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateTaskQueueFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateTaskQueueWithBody returns a parsed response.
// POST /v1/Workspaces/{WorkspaceSid}/TaskQueues
func (c *Client) CreateTaskQueueWithBody(ctx context.Context, workspaceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateTaskQueueResponse, error) {
	req, err := newCreateTaskQueueRequestWithBody(c.BaseURL, workspaceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateTaskQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TaskrouterV1WorkspaceTaskQueue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListTaskQueuesStatistics: GET /v1/Workspaces/{WorkspaceSid}/TaskQueues/Statistics

type ListTaskQueuesStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		TaskQueuesStatistics *[]TaskrouterV1WorkspaceTaskQueueTaskQueuesStatistics `json:"task_queues_statistics,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListTaskQueuesStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTaskQueuesStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListTaskQueuesStatisticsRequest generates requests for ListTaskQueuesStatistics
func newListTaskQueuesStatisticsRequest(baseURL *url.URL, workspaceSid string, params *ListTaskQueuesStatisticsParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListTaskQueuesStatisticsFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.Minutes != nil {
		if err := client.AddQueryParam(q, "Minutes", *params.Minutes); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.TaskChannel != nil {
		if err := client.AddQueryParam(q, "TaskChannel", *params.TaskChannel); err != nil {
			return nil, err
		}
	}

	if params.SplitByWaitTime != nil {
		if err := client.AddQueryParam(q, "SplitByWaitTime", *params.SplitByWaitTime); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListTaskQueuesStatistics returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/TaskQueues/Statistics
func (c *Client) ListTaskQueuesStatistics(ctx context.Context, workspaceSid string, params *ListTaskQueuesStatisticsParams, reqEditors ...client.RequestEditorFn) (*ListTaskQueuesStatisticsResponse, error) {
	req, err := newListTaskQueuesStatisticsRequest(c.BaseURL, workspaceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListTaskQueuesStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			TaskQueuesStatistics *[]TaskrouterV1WorkspaceTaskQueueTaskQueuesStatistics `json:"task_queues_statistics,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteTaskQueue: DELETE /v1/Workspaces/{WorkspaceSid}/TaskQueues/{Sid}

type DeleteTaskQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTaskQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTaskQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteTaskQueueRequest generates requests for DeleteTaskQueue
func newDeleteTaskQueueRequest(baseURL *url.URL, workspaceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteTaskQueueFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteTaskQueue returns a parsed response.
// DELETE /v1/Workspaces/{WorkspaceSid}/TaskQueues/{Sid}
func (c *Client) DeleteTaskQueue(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteTaskQueueResponse, error) {
	req, err := newDeleteTaskQueueRequest(c.BaseURL, workspaceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteTaskQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchTaskQueue: GET /v1/Workspaces/{WorkspaceSid}/TaskQueues/{Sid}

type FetchTaskQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceTaskQueue
}

// Status returns HTTPResponse.Status
func (r FetchTaskQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTaskQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchTaskQueueRequest generates requests for FetchTaskQueue
func newFetchTaskQueueRequest(baseURL *url.URL, workspaceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchTaskQueueFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchTaskQueue returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/TaskQueues/{Sid}
func (c *Client) FetchTaskQueue(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchTaskQueueResponse, error) {
	req, err := newFetchTaskQueueRequest(c.BaseURL, workspaceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchTaskQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceTaskQueue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateTaskQueue: POST /v1/Workspaces/{WorkspaceSid}/TaskQueues/{Sid}

type UpdateTaskQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceTaskQueue
}

// Status returns HTTPResponse.Status
func (r UpdateTaskQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTaskQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateTaskQueueRequestWithBody generates requests for UpdateTaskQueue with any type of body
func newUpdateTaskQueueRequestWithBody(baseURL *url.URL, workspaceSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateTaskQueueFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateTaskQueueWithBody returns a parsed response.
// POST /v1/Workspaces/{WorkspaceSid}/TaskQueues/{Sid}
func (c *Client) UpdateTaskQueueWithBody(ctx context.Context, workspaceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateTaskQueueResponse, error) {
	req, err := newUpdateTaskQueueRequestWithBody(c.BaseURL, workspaceSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateTaskQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceTaskQueue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchTaskQueueCumulativeStatistics: GET /v1/Workspaces/{WorkspaceSid}/TaskQueues/{TaskQueueSid}/CumulativeStatistics

type FetchTaskQueueCumulativeStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceTaskQueueTaskQueueCumulativeStatistics
}

// Status returns HTTPResponse.Status
func (r FetchTaskQueueCumulativeStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTaskQueueCumulativeStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchTaskQueueCumulativeStatisticsRequest generates requests for FetchTaskQueueCumulativeStatistics
func newFetchTaskQueueCumulativeStatisticsRequest(baseURL *url.URL, workspaceSid string, taskQueueSid string, params *FetchTaskQueueCumulativeStatisticsParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("TaskQueueSid", taskQueueSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchTaskQueueCumulativeStatisticsFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.Minutes != nil {
		if err := client.AddQueryParam(q, "Minutes", *params.Minutes); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.TaskChannel != nil {
		if err := client.AddQueryParam(q, "TaskChannel", *params.TaskChannel); err != nil {
			return nil, err
		}
	}

	if params.SplitByWaitTime != nil {
		if err := client.AddQueryParam(q, "SplitByWaitTime", *params.SplitByWaitTime); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchTaskQueueCumulativeStatistics returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/TaskQueues/{TaskQueueSid}/CumulativeStatistics
func (c *Client) FetchTaskQueueCumulativeStatistics(ctx context.Context, workspaceSid string, taskQueueSid string, params *FetchTaskQueueCumulativeStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchTaskQueueCumulativeStatisticsResponse, error) {
	req, err := newFetchTaskQueueCumulativeStatisticsRequest(c.BaseURL, workspaceSid, taskQueueSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchTaskQueueCumulativeStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceTaskQueueTaskQueueCumulativeStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchTaskQueueRealTimeStatistics: GET /v1/Workspaces/{WorkspaceSid}/TaskQueues/{TaskQueueSid}/RealTimeStatistics

type FetchTaskQueueRealTimeStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceTaskQueueTaskQueueRealTimeStatistics
}

// Status returns HTTPResponse.Status
func (r FetchTaskQueueRealTimeStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTaskQueueRealTimeStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchTaskQueueRealTimeStatisticsRequest generates requests for FetchTaskQueueRealTimeStatistics
func newFetchTaskQueueRealTimeStatisticsRequest(baseURL *url.URL, workspaceSid string, taskQueueSid string, params *FetchTaskQueueRealTimeStatisticsParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("TaskQueueSid", taskQueueSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchTaskQueueRealTimeStatisticsFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.TaskChannel != nil {
		if err := client.AddQueryParam(q, "TaskChannel", *params.TaskChannel); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchTaskQueueRealTimeStatistics returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/TaskQueues/{TaskQueueSid}/RealTimeStatistics
func (c *Client) FetchTaskQueueRealTimeStatistics(ctx context.Context, workspaceSid string, taskQueueSid string, params *FetchTaskQueueRealTimeStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchTaskQueueRealTimeStatisticsResponse, error) {
	req, err := newFetchTaskQueueRealTimeStatisticsRequest(c.BaseURL, workspaceSid, taskQueueSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchTaskQueueRealTimeStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceTaskQueueTaskQueueRealTimeStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchTaskQueueStatistics: GET /v1/Workspaces/{WorkspaceSid}/TaskQueues/{TaskQueueSid}/Statistics

type FetchTaskQueueStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceTaskQueueTaskQueueStatistics
}

// Status returns HTTPResponse.Status
func (r FetchTaskQueueStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTaskQueueStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchTaskQueueStatisticsRequest generates requests for FetchTaskQueueStatistics
func newFetchTaskQueueStatisticsRequest(baseURL *url.URL, workspaceSid string, taskQueueSid string, params *FetchTaskQueueStatisticsParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("TaskQueueSid", taskQueueSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchTaskQueueStatisticsFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.Minutes != nil {
		if err := client.AddQueryParam(q, "Minutes", *params.Minutes); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.TaskChannel != nil {
		if err := client.AddQueryParam(q, "TaskChannel", *params.TaskChannel); err != nil {
			return nil, err
		}
	}

	if params.SplitByWaitTime != nil {
		if err := client.AddQueryParam(q, "SplitByWaitTime", *params.SplitByWaitTime); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchTaskQueueStatistics returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/TaskQueues/{TaskQueueSid}/Statistics
func (c *Client) FetchTaskQueueStatistics(ctx context.Context, workspaceSid string, taskQueueSid string, params *FetchTaskQueueStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchTaskQueueStatisticsResponse, error) {
	req, err := newFetchTaskQueueStatisticsRequest(c.BaseURL, workspaceSid, taskQueueSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchTaskQueueStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceTaskQueueTaskQueueStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListTask: GET /v1/Workspaces/{WorkspaceSid}/Tasks

type ListTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Tasks *[]TaskrouterV1WorkspaceTask `json:"tasks,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListTaskRequest generates requests for ListTask
func newListTaskRequest(baseURL *url.URL, workspaceSid string, params *ListTaskParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListTaskFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Priority != nil {
		if err := client.AddQueryParam(q, "Priority", *params.Priority); err != nil {
			return nil, err
		}
	}

	if params.AssignmentStatus != nil {
		if err := client.AddQueryParam(q, "AssignmentStatus", *params.AssignmentStatus); err != nil {
			return nil, err
		}
	}

	if params.WorkflowSid != nil {
		if err := client.AddQueryParam(q, "WorkflowSid", *params.WorkflowSid); err != nil {
			return nil, err
		}
	}

	if params.WorkflowName != nil {
		if err := client.AddQueryParam(q, "WorkflowName", *params.WorkflowName); err != nil {
			return nil, err
		}
	}

	if params.TaskQueueSid != nil {
		if err := client.AddQueryParam(q, "TaskQueueSid", *params.TaskQueueSid); err != nil {
			return nil, err
		}
	}

	if params.TaskQueueName != nil {
		if err := client.AddQueryParam(q, "TaskQueueName", *params.TaskQueueName); err != nil {
			return nil, err
		}
	}

	if params.EvaluateTaskAttributes != nil {
		if err := client.AddQueryParam(q, "EvaluateTaskAttributes", *params.EvaluateTaskAttributes); err != nil {
			return nil, err
		}
	}

	if params.Ordering != nil {
		if err := client.AddQueryParam(q, "Ordering", *params.Ordering); err != nil {
			return nil, err
		}
	}

	if params.HasAddons != nil {
		if err := client.AddQueryParam(q, "HasAddons", *params.HasAddons); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListTask returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Tasks
func (c *Client) ListTask(ctx context.Context, workspaceSid string, params *ListTaskParams, reqEditors ...client.RequestEditorFn) (*ListTaskResponse, error) {
	req, err := newListTaskRequest(c.BaseURL, workspaceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Tasks *[]TaskrouterV1WorkspaceTask `json:"tasks,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateTask: POST /v1/Workspaces/{WorkspaceSid}/Tasks

type CreateTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TaskrouterV1WorkspaceTask
}

// Status returns HTTPResponse.Status
func (r CreateTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateTaskRequestWithBody generates requests for CreateTask with any type of body
func newCreateTaskRequestWithBody(baseURL *url.URL, workspaceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateTaskFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateTaskWithBody returns a parsed response.
// POST /v1/Workspaces/{WorkspaceSid}/Tasks
func (c *Client) CreateTaskWithBody(ctx context.Context, workspaceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateTaskResponse, error) {
	req, err := newCreateTaskRequestWithBody(c.BaseURL, workspaceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TaskrouterV1WorkspaceTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteTask: DELETE /v1/Workspaces/{WorkspaceSid}/Tasks/{Sid}

type DeleteTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteTaskRequest generates requests for DeleteTask
func newDeleteTaskRequest(baseURL *url.URL, workspaceSid string, sid string, params *DeleteTaskParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteTaskFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.IfMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-Match", headerParam0)
	}

	return req, nil
}

// DeleteTask returns a parsed response.
// DELETE /v1/Workspaces/{WorkspaceSid}/Tasks/{Sid}
func (c *Client) DeleteTask(ctx context.Context, workspaceSid string, sid string, params *DeleteTaskParams, reqEditors ...client.RequestEditorFn) (*DeleteTaskResponse, error) {
	req, err := newDeleteTaskRequest(c.BaseURL, workspaceSid, sid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchTask: GET /v1/Workspaces/{WorkspaceSid}/Tasks/{Sid}

type FetchTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceTask
}

// Status returns HTTPResponse.Status
func (r FetchTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchTaskRequest generates requests for FetchTask
func newFetchTaskRequest(baseURL *url.URL, workspaceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchTaskFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchTask returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Tasks/{Sid}
func (c *Client) FetchTask(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchTaskResponse, error) {
	req, err := newFetchTaskRequest(c.BaseURL, workspaceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateTask: POST /v1/Workspaces/{WorkspaceSid}/Tasks/{Sid}

type UpdateTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceTask
}

// Status returns HTTPResponse.Status
func (r UpdateTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateTaskRequestWithBody generates requests for UpdateTask with any type of body
func newUpdateTaskRequestWithBody(baseURL *url.URL, workspaceSid string, sid string, params *UpdateTaskParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateTaskFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.IfMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-Match", headerParam0)
	}

	return req, nil
}

// UpdateTaskWithBody returns a parsed response.
// POST /v1/Workspaces/{WorkspaceSid}/Tasks/{Sid}
func (c *Client) UpdateTaskWithBody(ctx context.Context, workspaceSid string, sid string, params *UpdateTaskParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateTaskResponse, error) {
	req, err := newUpdateTaskRequestWithBody(c.BaseURL, workspaceSid, sid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListTaskReservation: GET /v1/Workspaces/{WorkspaceSid}/Tasks/{TaskSid}/Reservations

type ListTaskReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Reservations *[]TaskrouterV1WorkspaceTaskTaskReservation `json:"reservations,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListTaskReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTaskReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListTaskReservationRequest generates requests for ListTaskReservation
func newListTaskReservationRequest(baseURL *url.URL, workspaceSid string, taskSid string, params *ListTaskReservationParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("TaskSid", taskSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListTaskReservationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.ReservationStatus != nil {
		if err := client.AddQueryParam(q, "ReservationStatus", *params.ReservationStatus); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListTaskReservation returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Tasks/{TaskSid}/Reservations
func (c *Client) ListTaskReservation(ctx context.Context, workspaceSid string, taskSid string, params *ListTaskReservationParams, reqEditors ...client.RequestEditorFn) (*ListTaskReservationResponse, error) {
	req, err := newListTaskReservationRequest(c.BaseURL, workspaceSid, taskSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListTaskReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Reservations *[]TaskrouterV1WorkspaceTaskTaskReservation `json:"reservations,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchTaskReservation: GET /v1/Workspaces/{WorkspaceSid}/Tasks/{TaskSid}/Reservations/{Sid}

type FetchTaskReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceTaskTaskReservation
}

// Status returns HTTPResponse.Status
func (r FetchTaskReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTaskReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchTaskReservationRequest generates requests for FetchTaskReservation
func newFetchTaskReservationRequest(baseURL *url.URL, workspaceSid string, taskSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("TaskSid", taskSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchTaskReservationFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchTaskReservation returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Tasks/{TaskSid}/Reservations/{Sid}
func (c *Client) FetchTaskReservation(ctx context.Context, workspaceSid string, taskSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchTaskReservationResponse, error) {
	req, err := newFetchTaskReservationRequest(c.BaseURL, workspaceSid, taskSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchTaskReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceTaskTaskReservation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateTaskReservation: POST /v1/Workspaces/{WorkspaceSid}/Tasks/{TaskSid}/Reservations/{Sid}

type UpdateTaskReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceTaskTaskReservation
}

// Status returns HTTPResponse.Status
func (r UpdateTaskReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTaskReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateTaskReservationRequestWithBody generates requests for UpdateTaskReservation with any type of body
func newUpdateTaskReservationRequestWithBody(baseURL *url.URL, workspaceSid string, taskSid string, sid string, params *UpdateTaskReservationParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("TaskSid", taskSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateTaskReservationFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.IfMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-Match", headerParam0)
	}

	return req, nil
}

// UpdateTaskReservationWithBody returns a parsed response.
// POST /v1/Workspaces/{WorkspaceSid}/Tasks/{TaskSid}/Reservations/{Sid}
func (c *Client) UpdateTaskReservationWithBody(ctx context.Context, workspaceSid string, taskSid string, sid string, params *UpdateTaskReservationParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateTaskReservationResponse, error) {
	req, err := newUpdateTaskReservationRequestWithBody(c.BaseURL, workspaceSid, taskSid, sid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateTaskReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceTaskTaskReservation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListWorker: GET /v1/Workspaces/{WorkspaceSid}/Workers

type ListWorkerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Workers *[]TaskrouterV1WorkspaceWorker `json:"workers,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListWorkerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListWorkerRequest generates requests for ListWorker
func newListWorkerRequest(baseURL *url.URL, workspaceSid string, params *ListWorkerParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListWorkerFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.ActivityName != nil {
		if err := client.AddQueryParam(q, "ActivityName", *params.ActivityName); err != nil {
			return nil, err
		}
	}

	if params.ActivitySid != nil {
		if err := client.AddQueryParam(q, "ActivitySid", *params.ActivitySid); err != nil {
			return nil, err
		}
	}

	if params.Available != nil {
		if err := client.AddQueryParam(q, "Available", *params.Available); err != nil {
			return nil, err
		}
	}

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.TargetWorkersExpression != nil {
		if err := client.AddQueryParam(q, "TargetWorkersExpression", *params.TargetWorkersExpression); err != nil {
			return nil, err
		}
	}

	if params.TaskQueueName != nil {
		if err := client.AddQueryParam(q, "TaskQueueName", *params.TaskQueueName); err != nil {
			return nil, err
		}
	}

	if params.TaskQueueSid != nil {
		if err := client.AddQueryParam(q, "TaskQueueSid", *params.TaskQueueSid); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListWorker returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Workers
func (c *Client) ListWorker(ctx context.Context, workspaceSid string, params *ListWorkerParams, reqEditors ...client.RequestEditorFn) (*ListWorkerResponse, error) {
	req, err := newListWorkerRequest(c.BaseURL, workspaceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListWorkerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Workers *[]TaskrouterV1WorkspaceWorker `json:"workers,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateWorker: POST /v1/Workspaces/{WorkspaceSid}/Workers

type CreateWorkerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TaskrouterV1WorkspaceWorker
}

// Status returns HTTPResponse.Status
func (r CreateWorkerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateWorkerRequestWithBody generates requests for CreateWorker with any type of body
func newCreateWorkerRequestWithBody(baseURL *url.URL, workspaceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateWorkerFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateWorkerWithBody returns a parsed response.
// POST /v1/Workspaces/{WorkspaceSid}/Workers
func (c *Client) CreateWorkerWithBody(ctx context.Context, workspaceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateWorkerResponse, error) {
	req, err := newCreateWorkerRequestWithBody(c.BaseURL, workspaceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateWorkerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TaskrouterV1WorkspaceWorker
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// FetchWorkersCumulativeStatistics: GET /v1/Workspaces/{WorkspaceSid}/Workers/CumulativeStatistics

type FetchWorkersCumulativeStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceWorkerWorkersCumulativeStatistics
}

// Status returns HTTPResponse.Status
func (r FetchWorkersCumulativeStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchWorkersCumulativeStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchWorkersCumulativeStatisticsRequest generates requests for FetchWorkersCumulativeStatistics
func newFetchWorkersCumulativeStatisticsRequest(baseURL *url.URL, workspaceSid string, params *FetchWorkersCumulativeStatisticsParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchWorkersCumulativeStatisticsFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.Minutes != nil {
		if err := client.AddQueryParam(q, "Minutes", *params.Minutes); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.TaskChannel != nil {
		if err := client.AddQueryParam(q, "TaskChannel", *params.TaskChannel); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchWorkersCumulativeStatistics returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Workers/CumulativeStatistics
func (c *Client) FetchWorkersCumulativeStatistics(ctx context.Context, workspaceSid string, params *FetchWorkersCumulativeStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchWorkersCumulativeStatisticsResponse, error) {
	req, err := newFetchWorkersCumulativeStatisticsRequest(c.BaseURL, workspaceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchWorkersCumulativeStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceWorkerWorkersCumulativeStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchWorkersRealTimeStatistics: GET /v1/Workspaces/{WorkspaceSid}/Workers/RealTimeStatistics

type FetchWorkersRealTimeStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceWorkerWorkersRealTimeStatistics
}

// Status returns HTTPResponse.Status
func (r FetchWorkersRealTimeStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchWorkersRealTimeStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchWorkersRealTimeStatisticsRequest generates requests for FetchWorkersRealTimeStatistics
func newFetchWorkersRealTimeStatisticsRequest(baseURL *url.URL, workspaceSid string, params *FetchWorkersRealTimeStatisticsParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchWorkersRealTimeStatisticsFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.TaskChannel != nil {
		if err := client.AddQueryParam(q, "TaskChannel", *params.TaskChannel); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchWorkersRealTimeStatistics returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Workers/RealTimeStatistics
func (c *Client) FetchWorkersRealTimeStatistics(ctx context.Context, workspaceSid string, params *FetchWorkersRealTimeStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchWorkersRealTimeStatisticsResponse, error) {
	req, err := newFetchWorkersRealTimeStatisticsRequest(c.BaseURL, workspaceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchWorkersRealTimeStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceWorkerWorkersRealTimeStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchWorkerStatistics: GET /v1/Workspaces/{WorkspaceSid}/Workers/Statistics

type FetchWorkerStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceWorkerWorkerStatistics
}

// Status returns HTTPResponse.Status
func (r FetchWorkerStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchWorkerStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchWorkerStatisticsRequest generates requests for FetchWorkerStatistics
func newFetchWorkerStatisticsRequest(baseURL *url.URL, workspaceSid string, params *FetchWorkerStatisticsParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchWorkerStatisticsFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Minutes != nil {
		if err := client.AddQueryParam(q, "Minutes", *params.Minutes); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.TaskQueueSid != nil {
		if err := client.AddQueryParam(q, "TaskQueueSid", *params.TaskQueueSid); err != nil {
			return nil, err
		}
	}

	if params.TaskQueueName != nil {
		if err := client.AddQueryParam(q, "TaskQueueName", *params.TaskQueueName); err != nil {
			return nil, err
		}
	}

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.TaskChannel != nil {
		if err := client.AddQueryParam(q, "TaskChannel", *params.TaskChannel); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchWorkerStatistics returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Workers/Statistics
func (c *Client) FetchWorkerStatistics(ctx context.Context, workspaceSid string, params *FetchWorkerStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchWorkerStatisticsResponse, error) {
	req, err := newFetchWorkerStatisticsRequest(c.BaseURL, workspaceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchWorkerStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceWorkerWorkerStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteWorker: DELETE /v1/Workspaces/{WorkspaceSid}/Workers/{Sid}

type DeleteWorkerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteWorkerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteWorkerRequest generates requests for DeleteWorker
func newDeleteWorkerRequest(baseURL *url.URL, workspaceSid string, sid string, params *DeleteWorkerParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteWorkerFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.IfMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-Match", headerParam0)
	}

	return req, nil
}

// DeleteWorker returns a parsed response.
// DELETE /v1/Workspaces/{WorkspaceSid}/Workers/{Sid}
func (c *Client) DeleteWorker(ctx context.Context, workspaceSid string, sid string, params *DeleteWorkerParams, reqEditors ...client.RequestEditorFn) (*DeleteWorkerResponse, error) {
	req, err := newDeleteWorkerRequest(c.BaseURL, workspaceSid, sid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteWorkerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchWorker: GET /v1/Workspaces/{WorkspaceSid}/Workers/{Sid}

type FetchWorkerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceWorker
}

// Status returns HTTPResponse.Status
func (r FetchWorkerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchWorkerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchWorkerRequest generates requests for FetchWorker
func newFetchWorkerRequest(baseURL *url.URL, workspaceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchWorkerFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchWorker returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Workers/{Sid}
func (c *Client) FetchWorker(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchWorkerResponse, error) {
	req, err := newFetchWorkerRequest(c.BaseURL, workspaceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchWorkerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceWorker
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateWorker: POST /v1/Workspaces/{WorkspaceSid}/Workers/{Sid}

type UpdateWorkerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceWorker
}

// Status returns HTTPResponse.Status
func (r UpdateWorkerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWorkerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateWorkerRequestWithBody generates requests for UpdateWorker with any type of body
func newUpdateWorkerRequestWithBody(baseURL *url.URL, workspaceSid string, sid string, params *UpdateWorkerParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateWorkerFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.IfMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-Match", headerParam0)
	}

	return req, nil
}

// UpdateWorkerWithBody returns a parsed response.
// POST /v1/Workspaces/{WorkspaceSid}/Workers/{Sid}
func (c *Client) UpdateWorkerWithBody(ctx context.Context, workspaceSid string, sid string, params *UpdateWorkerParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateWorkerResponse, error) {
	req, err := newUpdateWorkerRequestWithBody(c.BaseURL, workspaceSid, sid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateWorkerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceWorker
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListWorkerChannel: GET /v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Channels

type ListWorkerChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Channels *[]TaskrouterV1WorkspaceWorkerWorkerChannel `json:"channels,omitempty"`
		Meta     *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListWorkerChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkerChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListWorkerChannelRequest generates requests for ListWorkerChannel
func newListWorkerChannelRequest(baseURL *url.URL, workspaceSid string, workerSid string, params *ListWorkerChannelParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("WorkerSid", workerSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListWorkerChannelFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListWorkerChannel returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Channels
func (c *Client) ListWorkerChannel(ctx context.Context, workspaceSid string, workerSid string, params *ListWorkerChannelParams, reqEditors ...client.RequestEditorFn) (*ListWorkerChannelResponse, error) {
	req, err := newListWorkerChannelRequest(c.BaseURL, workspaceSid, workerSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListWorkerChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Channels *[]TaskrouterV1WorkspaceWorkerWorkerChannel `json:"channels,omitempty"`
			Meta     *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchWorkerChannel: GET /v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Channels/{Sid}

type FetchWorkerChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceWorkerWorkerChannel
}

// Status returns HTTPResponse.Status
func (r FetchWorkerChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchWorkerChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchWorkerChannelRequest generates requests for FetchWorkerChannel
func newFetchWorkerChannelRequest(baseURL *url.URL, workspaceSid string, workerSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("WorkerSid", workerSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchWorkerChannelFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchWorkerChannel returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Channels/{Sid}
func (c *Client) FetchWorkerChannel(ctx context.Context, workspaceSid string, workerSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchWorkerChannelResponse, error) {
	req, err := newFetchWorkerChannelRequest(c.BaseURL, workspaceSid, workerSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchWorkerChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceWorkerWorkerChannel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateWorkerChannel: POST /v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Channels/{Sid}

type UpdateWorkerChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceWorkerWorkerChannel
}

// Status returns HTTPResponse.Status
func (r UpdateWorkerChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWorkerChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateWorkerChannelRequestWithBody generates requests for UpdateWorkerChannel with any type of body
func newUpdateWorkerChannelRequestWithBody(baseURL *url.URL, workspaceSid string, workerSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("WorkerSid", workerSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateWorkerChannelFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateWorkerChannelWithBody returns a parsed response.
// POST /v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Channels/{Sid}
func (c *Client) UpdateWorkerChannelWithBody(ctx context.Context, workspaceSid string, workerSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateWorkerChannelResponse, error) {
	req, err := newUpdateWorkerChannelRequestWithBody(c.BaseURL, workspaceSid, workerSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateWorkerChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceWorkerWorkerChannel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListWorkerReservation: GET /v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Reservations

type ListWorkerReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Reservations *[]TaskrouterV1WorkspaceWorkerWorkerReservation `json:"reservations,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListWorkerReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkerReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListWorkerReservationRequest generates requests for ListWorkerReservation
func newListWorkerReservationRequest(baseURL *url.URL, workspaceSid string, workerSid string, params *ListWorkerReservationParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("WorkerSid", workerSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListWorkerReservationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.ReservationStatus != nil {
		if err := client.AddQueryParam(q, "ReservationStatus", *params.ReservationStatus); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListWorkerReservation returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Reservations
func (c *Client) ListWorkerReservation(ctx context.Context, workspaceSid string, workerSid string, params *ListWorkerReservationParams, reqEditors ...client.RequestEditorFn) (*ListWorkerReservationResponse, error) {
	req, err := newListWorkerReservationRequest(c.BaseURL, workspaceSid, workerSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListWorkerReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Reservations *[]TaskrouterV1WorkspaceWorkerWorkerReservation `json:"reservations,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchWorkerReservation: GET /v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Reservations/{Sid}

type FetchWorkerReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceWorkerWorkerReservation
}

// Status returns HTTPResponse.Status
func (r FetchWorkerReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchWorkerReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchWorkerReservationRequest generates requests for FetchWorkerReservation
func newFetchWorkerReservationRequest(baseURL *url.URL, workspaceSid string, workerSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("WorkerSid", workerSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchWorkerReservationFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchWorkerReservation returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Reservations/{Sid}
func (c *Client) FetchWorkerReservation(ctx context.Context, workspaceSid string, workerSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchWorkerReservationResponse, error) {
	req, err := newFetchWorkerReservationRequest(c.BaseURL, workspaceSid, workerSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchWorkerReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceWorkerWorkerReservation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateWorkerReservation: POST /v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Reservations/{Sid}

type UpdateWorkerReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceWorkerWorkerReservation
}

// Status returns HTTPResponse.Status
func (r UpdateWorkerReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWorkerReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateWorkerReservationRequestWithBody generates requests for UpdateWorkerReservation with any type of body
func newUpdateWorkerReservationRequestWithBody(baseURL *url.URL, workspaceSid string, workerSid string, sid string, params *UpdateWorkerReservationParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("WorkerSid", workerSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateWorkerReservationFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.IfMatch != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
		if err != nil {
			return nil, err
		}

		req.Header.Set("If-Match", headerParam0)
	}

	return req, nil
}

// UpdateWorkerReservationWithBody returns a parsed response.
// POST /v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Reservations/{Sid}
func (c *Client) UpdateWorkerReservationWithBody(ctx context.Context, workspaceSid string, workerSid string, sid string, params *UpdateWorkerReservationParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateWorkerReservationResponse, error) {
	req, err := newUpdateWorkerReservationRequestWithBody(c.BaseURL, workspaceSid, workerSid, sid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateWorkerReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceWorkerWorkerReservation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchWorkerInstanceStatistics: GET /v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Statistics

type FetchWorkerInstanceStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceWorkerWorkerInstanceStatistics
}

// Status returns HTTPResponse.Status
func (r FetchWorkerInstanceStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchWorkerInstanceStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchWorkerInstanceStatisticsRequest generates requests for FetchWorkerInstanceStatistics
func newFetchWorkerInstanceStatisticsRequest(baseURL *url.URL, workspaceSid string, workerSid string, params *FetchWorkerInstanceStatisticsParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("WorkerSid", workerSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchWorkerInstanceStatisticsFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Minutes != nil {
		if err := client.AddQueryParam(q, "Minutes", *params.Minutes); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.TaskChannel != nil {
		if err := client.AddQueryParam(q, "TaskChannel", *params.TaskChannel); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchWorkerInstanceStatistics returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Workers/{WorkerSid}/Statistics
func (c *Client) FetchWorkerInstanceStatistics(ctx context.Context, workspaceSid string, workerSid string, params *FetchWorkerInstanceStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchWorkerInstanceStatisticsResponse, error) {
	req, err := newFetchWorkerInstanceStatisticsRequest(c.BaseURL, workspaceSid, workerSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchWorkerInstanceStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceWorkerWorkerInstanceStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListWorkflow: GET /v1/Workspaces/{WorkspaceSid}/Workflows

type ListWorkflowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Workflows *[]TaskrouterV1WorkspaceWorkflow `json:"workflows,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListWorkflowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkflowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListWorkflowRequest generates requests for ListWorkflow
func newListWorkflowRequest(baseURL *url.URL, workspaceSid string, params *ListWorkflowParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListWorkflowFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListWorkflow returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Workflows
func (c *Client) ListWorkflow(ctx context.Context, workspaceSid string, params *ListWorkflowParams, reqEditors ...client.RequestEditorFn) (*ListWorkflowResponse, error) {
	req, err := newListWorkflowRequest(c.BaseURL, workspaceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListWorkflowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Workflows *[]TaskrouterV1WorkspaceWorkflow `json:"workflows,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateWorkflow: POST /v1/Workspaces/{WorkspaceSid}/Workflows

type CreateWorkflowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TaskrouterV1WorkspaceWorkflow
}

// Status returns HTTPResponse.Status
func (r CreateWorkflowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkflowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateWorkflowRequestWithBody generates requests for CreateWorkflow with any type of body
func newCreateWorkflowRequestWithBody(baseURL *url.URL, workspaceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateWorkflowFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateWorkflowWithBody returns a parsed response.
// POST /v1/Workspaces/{WorkspaceSid}/Workflows
func (c *Client) CreateWorkflowWithBody(ctx context.Context, workspaceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateWorkflowResponse, error) {
	req, err := newCreateWorkflowRequestWithBody(c.BaseURL, workspaceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateWorkflowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TaskrouterV1WorkspaceWorkflow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteWorkflow: DELETE /v1/Workspaces/{WorkspaceSid}/Workflows/{Sid}

type DeleteWorkflowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteWorkflowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWorkflowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteWorkflowRequest generates requests for DeleteWorkflow
func newDeleteWorkflowRequest(baseURL *url.URL, workspaceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteWorkflowFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteWorkflow returns a parsed response.
// DELETE /v1/Workspaces/{WorkspaceSid}/Workflows/{Sid}
func (c *Client) DeleteWorkflow(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteWorkflowResponse, error) {
	req, err := newDeleteWorkflowRequest(c.BaseURL, workspaceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteWorkflowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchWorkflow: GET /v1/Workspaces/{WorkspaceSid}/Workflows/{Sid}

type FetchWorkflowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceWorkflow
}

// Status returns HTTPResponse.Status
func (r FetchWorkflowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchWorkflowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchWorkflowRequest generates requests for FetchWorkflow
func newFetchWorkflowRequest(baseURL *url.URL, workspaceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchWorkflowFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchWorkflow returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Workflows/{Sid}
func (c *Client) FetchWorkflow(ctx context.Context, workspaceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchWorkflowResponse, error) {
	req, err := newFetchWorkflowRequest(c.BaseURL, workspaceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchWorkflowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceWorkflow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateWorkflow: POST /v1/Workspaces/{WorkspaceSid}/Workflows/{Sid}

type UpdateWorkflowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceWorkflow
}

// Status returns HTTPResponse.Status
func (r UpdateWorkflowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWorkflowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateWorkflowRequestWithBody generates requests for UpdateWorkflow with any type of body
func newUpdateWorkflowRequestWithBody(baseURL *url.URL, workspaceSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateWorkflowFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateWorkflowWithBody returns a parsed response.
// POST /v1/Workspaces/{WorkspaceSid}/Workflows/{Sid}
func (c *Client) UpdateWorkflowWithBody(ctx context.Context, workspaceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateWorkflowResponse, error) {
	req, err := newUpdateWorkflowRequestWithBody(c.BaseURL, workspaceSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateWorkflowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceWorkflow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchWorkflowCumulativeStatistics: GET /v1/Workspaces/{WorkspaceSid}/Workflows/{WorkflowSid}/CumulativeStatistics

type FetchWorkflowCumulativeStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceWorkflowWorkflowCumulativeStatistics
}

// Status returns HTTPResponse.Status
func (r FetchWorkflowCumulativeStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchWorkflowCumulativeStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchWorkflowCumulativeStatisticsRequest generates requests for FetchWorkflowCumulativeStatistics
func newFetchWorkflowCumulativeStatisticsRequest(baseURL *url.URL, workspaceSid string, workflowSid string, params *FetchWorkflowCumulativeStatisticsParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("WorkflowSid", workflowSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchWorkflowCumulativeStatisticsFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.Minutes != nil {
		if err := client.AddQueryParam(q, "Minutes", *params.Minutes); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.TaskChannel != nil {
		if err := client.AddQueryParam(q, "TaskChannel", *params.TaskChannel); err != nil {
			return nil, err
		}
	}

	if params.SplitByWaitTime != nil {
		if err := client.AddQueryParam(q, "SplitByWaitTime", *params.SplitByWaitTime); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchWorkflowCumulativeStatistics returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Workflows/{WorkflowSid}/CumulativeStatistics
func (c *Client) FetchWorkflowCumulativeStatistics(ctx context.Context, workspaceSid string, workflowSid string, params *FetchWorkflowCumulativeStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchWorkflowCumulativeStatisticsResponse, error) {
	req, err := newFetchWorkflowCumulativeStatisticsRequest(c.BaseURL, workspaceSid, workflowSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchWorkflowCumulativeStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceWorkflowWorkflowCumulativeStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchWorkflowRealTimeStatistics: GET /v1/Workspaces/{WorkspaceSid}/Workflows/{WorkflowSid}/RealTimeStatistics

type FetchWorkflowRealTimeStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceWorkflowWorkflowRealTimeStatistics
}

// Status returns HTTPResponse.Status
func (r FetchWorkflowRealTimeStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchWorkflowRealTimeStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchWorkflowRealTimeStatisticsRequest generates requests for FetchWorkflowRealTimeStatistics
func newFetchWorkflowRealTimeStatisticsRequest(baseURL *url.URL, workspaceSid string, workflowSid string, params *FetchWorkflowRealTimeStatisticsParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("WorkflowSid", workflowSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchWorkflowRealTimeStatisticsFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.TaskChannel != nil {
		if err := client.AddQueryParam(q, "TaskChannel", *params.TaskChannel); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchWorkflowRealTimeStatistics returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Workflows/{WorkflowSid}/RealTimeStatistics
func (c *Client) FetchWorkflowRealTimeStatistics(ctx context.Context, workspaceSid string, workflowSid string, params *FetchWorkflowRealTimeStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchWorkflowRealTimeStatisticsResponse, error) {
	req, err := newFetchWorkflowRealTimeStatisticsRequest(c.BaseURL, workspaceSid, workflowSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchWorkflowRealTimeStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceWorkflowWorkflowRealTimeStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchWorkflowStatistics: GET /v1/Workspaces/{WorkspaceSid}/Workflows/{WorkflowSid}/Statistics

type FetchWorkflowStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TaskrouterV1WorkspaceWorkflowWorkflowStatistics
}

// Status returns HTTPResponse.Status
func (r FetchWorkflowStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchWorkflowStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchWorkflowStatisticsRequest generates requests for FetchWorkflowStatistics
func newFetchWorkflowStatisticsRequest(baseURL *url.URL, workspaceSid string, workflowSid string, params *FetchWorkflowStatisticsParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("WorkspaceSid", workspaceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("WorkflowSid", workflowSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchWorkflowStatisticsFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Minutes != nil {
		if err := client.AddQueryParam(q, "Minutes", *params.Minutes); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.TaskChannel != nil {
		if err := client.AddQueryParam(q, "TaskChannel", *params.TaskChannel); err != nil {
			return nil, err
		}
	}

	if params.SplitByWaitTime != nil {
		if err := client.AddQueryParam(q, "SplitByWaitTime", *params.SplitByWaitTime); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchWorkflowStatistics returns a parsed response.
// GET /v1/Workspaces/{WorkspaceSid}/Workflows/{WorkflowSid}/Statistics
func (c *Client) FetchWorkflowStatistics(ctx context.Context, workspaceSid string, workflowSid string, params *FetchWorkflowStatisticsParams, reqEditors ...client.RequestEditorFn) (*FetchWorkflowStatisticsResponse, error) {
	req, err := newFetchWorkflowStatisticsRequest(c.BaseURL, workspaceSid, workflowSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchWorkflowStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TaskrouterV1WorkspaceWorkflowWorkflowStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
