// Package insights provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package insights

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/faetools/client"
)

// operation paths

const (
	opPathFetchConferenceFormat              = "./v1/Conferences/%s"
	opPathListConferenceParticipantFormat    = "./v1/Conferences/%s/Participants"
	opPathFetchConferenceParticipantFormat   = "./v1/Conferences/%s/Participants/%s"
	opPathFetchVideoRoomSummaryFormat        = "./v1/Video/Rooms/%s"
	opPathListVideoParticipantSummaryFormat  = "./v1/Video/Rooms/%s/Participants"
	opPathFetchVideoParticipantSummaryFormat = "./v1/Video/Rooms/%s/Participants/%s"
	opPathListEventFormat                    = "./v1/Voice/%s/Events"
	opPathListMetricFormat                   = "./v1/Voice/%s/Metrics"
	opPathFetchSummaryFormat                 = "./v1/Voice/%s/Summary"
	opPathFetchCallFormat                    = "./v1/Voice/%s"
)

var (
	opPathListConference        = client.MustParseURL("./v1/Conferences")
	opPathListVideoRoomSummary  = client.MustParseURL("./v1/Video/Rooms")
	opPathFetchAccountSettings  = client.MustParseURL("./v1/Voice/Settings")
	opPathUpdateAccountSettings = client.MustParseURL("./v1/Voice/Settings")
	opPathListCallSummaries     = client.MustParseURL("./v1/Voice/Summaries")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// ListConference request
	ListConference(ctx context.Context, params *ListConferenceParams, reqEditors ...client.RequestEditorFn) (*ListConferenceResponse, error)

	// FetchConference request
	FetchConference(ctx context.Context, conferenceSid string, reqEditors ...client.RequestEditorFn) (*FetchConferenceResponse, error)

	// ListConferenceParticipant request
	ListConferenceParticipant(ctx context.Context, conferenceSid string, params *ListConferenceParticipantParams, reqEditors ...client.RequestEditorFn) (*ListConferenceParticipantResponse, error)

	// FetchConferenceParticipant request
	FetchConferenceParticipant(ctx context.Context, conferenceSid string, participantSid string, params *FetchConferenceParticipantParams, reqEditors ...client.RequestEditorFn) (*FetchConferenceParticipantResponse, error)

	// ListVideoRoomSummary request
	ListVideoRoomSummary(ctx context.Context, params *ListVideoRoomSummaryParams, reqEditors ...client.RequestEditorFn) (*ListVideoRoomSummaryResponse, error)

	// FetchVideoRoomSummary request
	FetchVideoRoomSummary(ctx context.Context, roomSid string, reqEditors ...client.RequestEditorFn) (*FetchVideoRoomSummaryResponse, error)

	// ListVideoParticipantSummary request
	ListVideoParticipantSummary(ctx context.Context, roomSid string, params *ListVideoParticipantSummaryParams, reqEditors ...client.RequestEditorFn) (*ListVideoParticipantSummaryResponse, error)

	// FetchVideoParticipantSummary request
	FetchVideoParticipantSummary(ctx context.Context, roomSid string, participantSid string, reqEditors ...client.RequestEditorFn) (*FetchVideoParticipantSummaryResponse, error)

	// FetchAccountSettings request
	FetchAccountSettings(ctx context.Context, params *FetchAccountSettingsParams, reqEditors ...client.RequestEditorFn) (*FetchAccountSettingsResponse, error)

	// UpdateAccountSettings request with any body
	UpdateAccountSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateAccountSettingsResponse, error)

	// ListCallSummaries request
	ListCallSummaries(ctx context.Context, params *ListCallSummariesParams, reqEditors ...client.RequestEditorFn) (*ListCallSummariesResponse, error)

	// ListEvent request
	ListEvent(ctx context.Context, callSid string, params *ListEventParams, reqEditors ...client.RequestEditorFn) (*ListEventResponse, error)

	// ListMetric request
	ListMetric(ctx context.Context, callSid string, params *ListMetricParams, reqEditors ...client.RequestEditorFn) (*ListMetricResponse, error)

	// FetchSummary request
	FetchSummary(ctx context.Context, callSid string, params *FetchSummaryParams, reqEditors ...client.RequestEditorFn) (*FetchSummaryResponse, error)

	// FetchCall request
	FetchCall(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchCallResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// ListConference: GET /v1/Conferences

type ListConferenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Conferences *[]InsightsV1Conference `json:"conferences,omitempty"`
		Meta        *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListConferenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConferenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListConferenceRequest generates requests for ListConference
func newListConferenceRequest(baseURL *url.URL, params *ListConferenceParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListConference)

	q := queryURL.Query()

	if params.ConferenceSid != nil {
		if err := client.AddQueryParam(q, "ConferenceSid", *params.ConferenceSid); err != nil {
			return nil, err
		}
	}

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.CreatedAfter != nil {
		if err := client.AddQueryParam(q, "CreatedAfter", *params.CreatedAfter); err != nil {
			return nil, err
		}
	}

	if params.CreatedBefore != nil {
		if err := client.AddQueryParam(q, "CreatedBefore", *params.CreatedBefore); err != nil {
			return nil, err
		}
	}

	if params.MixerRegion != nil {
		if err := client.AddQueryParam(q, "MixerRegion", *params.MixerRegion); err != nil {
			return nil, err
		}
	}

	if params.Tags != nil {
		if err := client.AddQueryParam(q, "Tags", *params.Tags); err != nil {
			return nil, err
		}
	}

	if params.Subaccount != nil {
		if err := client.AddQueryParam(q, "Subaccount", *params.Subaccount); err != nil {
			return nil, err
		}
	}

	if params.DetectedIssues != nil {
		if err := client.AddQueryParam(q, "DetectedIssues", *params.DetectedIssues); err != nil {
			return nil, err
		}
	}

	if params.EndReason != nil {
		if err := client.AddQueryParam(q, "EndReason", *params.EndReason); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListConference returns a parsed response.
// GET /v1/Conferences
func (c *Client) ListConference(ctx context.Context, params *ListConferenceParams, reqEditors ...client.RequestEditorFn) (*ListConferenceResponse, error) {
	req, err := newListConferenceRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListConferenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Conferences *[]InsightsV1Conference `json:"conferences,omitempty"`
			Meta        *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchConference: GET /v1/Conferences/{ConferenceSid}

type FetchConferenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightsV1Conference
}

// Status returns HTTPResponse.Status
func (r FetchConferenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchConferenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchConferenceRequest generates requests for FetchConference
func newFetchConferenceRequest(baseURL *url.URL, conferenceSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConferenceSid", conferenceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchConferenceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchConference returns a parsed response.
// GET /v1/Conferences/{ConferenceSid}
func (c *Client) FetchConference(ctx context.Context, conferenceSid string, reqEditors ...client.RequestEditorFn) (*FetchConferenceResponse, error) {
	req, err := newFetchConferenceRequest(c.BaseURL, conferenceSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchConferenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightsV1Conference
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListConferenceParticipant: GET /v1/Conferences/{ConferenceSid}/Participants

type ListConferenceParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Participants *[]InsightsV1ConferenceConferenceParticipant `json:"participants,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListConferenceParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConferenceParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListConferenceParticipantRequest generates requests for ListConferenceParticipant
func newListConferenceParticipantRequest(baseURL *url.URL, conferenceSid string, params *ListConferenceParticipantParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConferenceSid", conferenceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListConferenceParticipantFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.ParticipantSid != nil {
		if err := client.AddQueryParam(q, "ParticipantSid", *params.ParticipantSid); err != nil {
			return nil, err
		}
	}

	if params.Label != nil {
		if err := client.AddQueryParam(q, "Label", *params.Label); err != nil {
			return nil, err
		}
	}

	if params.Events != nil {
		if err := client.AddQueryParam(q, "Events", *params.Events); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListConferenceParticipant returns a parsed response.
// GET /v1/Conferences/{ConferenceSid}/Participants
func (c *Client) ListConferenceParticipant(ctx context.Context, conferenceSid string, params *ListConferenceParticipantParams, reqEditors ...client.RequestEditorFn) (*ListConferenceParticipantResponse, error) {
	req, err := newListConferenceParticipantRequest(c.BaseURL, conferenceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListConferenceParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Participants *[]InsightsV1ConferenceConferenceParticipant `json:"participants,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchConferenceParticipant: GET /v1/Conferences/{ConferenceSid}/Participants/{ParticipantSid}

type FetchConferenceParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightsV1ConferenceConferenceParticipant
}

// Status returns HTTPResponse.Status
func (r FetchConferenceParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchConferenceParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchConferenceParticipantRequest generates requests for FetchConferenceParticipant
func newFetchConferenceParticipantRequest(baseURL *url.URL, conferenceSid string, participantSid string, params *FetchConferenceParticipantParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConferenceSid", conferenceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ParticipantSid", participantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchConferenceParticipantFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Events != nil {
		if err := client.AddQueryParam(q, "Events", *params.Events); err != nil {
			return nil, err
		}
	}

	if params.Metrics != nil {
		if err := client.AddQueryParam(q, "Metrics", *params.Metrics); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchConferenceParticipant returns a parsed response.
// GET /v1/Conferences/{ConferenceSid}/Participants/{ParticipantSid}
func (c *Client) FetchConferenceParticipant(ctx context.Context, conferenceSid string, participantSid string, params *FetchConferenceParticipantParams, reqEditors ...client.RequestEditorFn) (*FetchConferenceParticipantResponse, error) {
	req, err := newFetchConferenceParticipantRequest(c.BaseURL, conferenceSid, participantSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchConferenceParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightsV1ConferenceConferenceParticipant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListVideoRoomSummary: GET /v1/Video/Rooms

type ListVideoRoomSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Rooms *[]InsightsV1VideoRoomSummary `json:"rooms,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListVideoRoomSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVideoRoomSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListVideoRoomSummaryRequest generates requests for ListVideoRoomSummary
func newListVideoRoomSummaryRequest(baseURL *url.URL, params *ListVideoRoomSummaryParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListVideoRoomSummary)

	q := queryURL.Query()

	if params.RoomType != nil {
		if err := client.AddQueryParam(q, "RoomType", *params.RoomType); err != nil {
			return nil, err
		}
	}

	if params.Codec != nil {
		if err := client.AddQueryParam(q, "Codec", *params.Codec); err != nil {
			return nil, err
		}
	}

	if params.RoomName != nil {
		if err := client.AddQueryParam(q, "RoomName", *params.RoomName); err != nil {
			return nil, err
		}
	}

	if params.CreatedAfter != nil {
		if err := client.AddQueryParam(q, "CreatedAfter", *params.CreatedAfter); err != nil {
			return nil, err
		}
	}

	if params.CreatedBefore != nil {
		if err := client.AddQueryParam(q, "CreatedBefore", *params.CreatedBefore); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListVideoRoomSummary returns a parsed response.
// GET /v1/Video/Rooms
func (c *Client) ListVideoRoomSummary(ctx context.Context, params *ListVideoRoomSummaryParams, reqEditors ...client.RequestEditorFn) (*ListVideoRoomSummaryResponse, error) {
	req, err := newListVideoRoomSummaryRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListVideoRoomSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Rooms *[]InsightsV1VideoRoomSummary `json:"rooms,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchVideoRoomSummary: GET /v1/Video/Rooms/{RoomSid}

type FetchVideoRoomSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightsV1VideoRoomSummary
}

// Status returns HTTPResponse.Status
func (r FetchVideoRoomSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchVideoRoomSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchVideoRoomSummaryRequest generates requests for FetchVideoRoomSummary
func newFetchVideoRoomSummaryRequest(baseURL *url.URL, roomSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("RoomSid", roomSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchVideoRoomSummaryFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchVideoRoomSummary returns a parsed response.
// GET /v1/Video/Rooms/{RoomSid}
func (c *Client) FetchVideoRoomSummary(ctx context.Context, roomSid string, reqEditors ...client.RequestEditorFn) (*FetchVideoRoomSummaryResponse, error) {
	req, err := newFetchVideoRoomSummaryRequest(c.BaseURL, roomSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchVideoRoomSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightsV1VideoRoomSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListVideoParticipantSummary: GET /v1/Video/Rooms/{RoomSid}/Participants

type ListVideoParticipantSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Participants *[]InsightsV1VideoRoomSummaryVideoParticipantSummary `json:"participants,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListVideoParticipantSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVideoParticipantSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListVideoParticipantSummaryRequest generates requests for ListVideoParticipantSummary
func newListVideoParticipantSummaryRequest(baseURL *url.URL, roomSid string, params *ListVideoParticipantSummaryParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("RoomSid", roomSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListVideoParticipantSummaryFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListVideoParticipantSummary returns a parsed response.
// GET /v1/Video/Rooms/{RoomSid}/Participants
func (c *Client) ListVideoParticipantSummary(ctx context.Context, roomSid string, params *ListVideoParticipantSummaryParams, reqEditors ...client.RequestEditorFn) (*ListVideoParticipantSummaryResponse, error) {
	req, err := newListVideoParticipantSummaryRequest(c.BaseURL, roomSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListVideoParticipantSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Participants *[]InsightsV1VideoRoomSummaryVideoParticipantSummary `json:"participants,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchVideoParticipantSummary: GET /v1/Video/Rooms/{RoomSid}/Participants/{ParticipantSid}

type FetchVideoParticipantSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightsV1VideoRoomSummaryVideoParticipantSummary
}

// Status returns HTTPResponse.Status
func (r FetchVideoParticipantSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchVideoParticipantSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchVideoParticipantSummaryRequest generates requests for FetchVideoParticipantSummary
func newFetchVideoParticipantSummaryRequest(baseURL *url.URL, roomSid string, participantSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("RoomSid", roomSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ParticipantSid", participantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchVideoParticipantSummaryFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchVideoParticipantSummary returns a parsed response.
// GET /v1/Video/Rooms/{RoomSid}/Participants/{ParticipantSid}
func (c *Client) FetchVideoParticipantSummary(ctx context.Context, roomSid string, participantSid string, reqEditors ...client.RequestEditorFn) (*FetchVideoParticipantSummaryResponse, error) {
	req, err := newFetchVideoParticipantSummaryRequest(c.BaseURL, roomSid, participantSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchVideoParticipantSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightsV1VideoRoomSummaryVideoParticipantSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchAccountSettings: GET /v1/Voice/Settings

type FetchAccountSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightsV1AccountSettings
}

// Status returns HTTPResponse.Status
func (r FetchAccountSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchAccountSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchAccountSettingsRequest generates requests for FetchAccountSettings
func newFetchAccountSettingsRequest(baseURL *url.URL, params *FetchAccountSettingsParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathFetchAccountSettings)

	q := queryURL.Query()

	if params.SubaccountSid != nil {
		if err := client.AddQueryParam(q, "SubaccountSid", *params.SubaccountSid); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchAccountSettings returns a parsed response.
// GET /v1/Voice/Settings
func (c *Client) FetchAccountSettings(ctx context.Context, params *FetchAccountSettingsParams, reqEditors ...client.RequestEditorFn) (*FetchAccountSettingsResponse, error) {
	req, err := newFetchAccountSettingsRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchAccountSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightsV1AccountSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateAccountSettings: POST /v1/Voice/Settings

type UpdateAccountSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightsV1AccountSettings
}

// Status returns HTTPResponse.Status
func (r UpdateAccountSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAccountSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateAccountSettingsRequestWithBody generates requests for UpdateAccountSettings with any type of body
func newUpdateAccountSettingsRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathUpdateAccountSettings)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateAccountSettingsWithBody returns a parsed response.
// POST /v1/Voice/Settings
func (c *Client) UpdateAccountSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateAccountSettingsResponse, error) {
	req, err := newUpdateAccountSettingsRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateAccountSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightsV1AccountSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListCallSummaries: GET /v1/Voice/Summaries

type ListCallSummariesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CallSummaries *[]InsightsV1CallSummaries `json:"call_summaries,omitempty"`
		Meta          *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCallSummariesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCallSummariesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListCallSummariesRequest generates requests for ListCallSummaries
func newListCallSummariesRequest(baseURL *url.URL, params *ListCallSummariesParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListCallSummaries)

	q := queryURL.Query()

	if params.From != nil {
		if err := client.AddQueryParam(q, "From", *params.From); err != nil {
			return nil, err
		}
	}

	if params.To != nil {
		if err := client.AddQueryParam(q, "To", *params.To); err != nil {
			return nil, err
		}
	}

	if params.FromCarrier != nil {
		if err := client.AddQueryParam(q, "FromCarrier", *params.FromCarrier); err != nil {
			return nil, err
		}
	}

	if params.ToCarrier != nil {
		if err := client.AddQueryParam(q, "ToCarrier", *params.ToCarrier); err != nil {
			return nil, err
		}
	}

	if params.FromCountryCode != nil {
		if err := client.AddQueryParam(q, "FromCountryCode", *params.FromCountryCode); err != nil {
			return nil, err
		}
	}

	if params.ToCountryCode != nil {
		if err := client.AddQueryParam(q, "ToCountryCode", *params.ToCountryCode); err != nil {
			return nil, err
		}
	}

	if params.Branded != nil {
		if err := client.AddQueryParam(q, "Branded", *params.Branded); err != nil {
			return nil, err
		}
	}

	if params.VerifiedCaller != nil {
		if err := client.AddQueryParam(q, "VerifiedCaller", *params.VerifiedCaller); err != nil {
			return nil, err
		}
	}

	if params.HasTag != nil {
		if err := client.AddQueryParam(q, "HasTag", *params.HasTag); err != nil {
			return nil, err
		}
	}

	if params.StartTime != nil {
		if err := client.AddQueryParam(q, "StartTime", *params.StartTime); err != nil {
			return nil, err
		}
	}

	if params.EndTime != nil {
		if err := client.AddQueryParam(q, "EndTime", *params.EndTime); err != nil {
			return nil, err
		}
	}

	if params.CallType != nil {
		if err := client.AddQueryParam(q, "CallType", *params.CallType); err != nil {
			return nil, err
		}
	}

	if params.CallState != nil {
		if err := client.AddQueryParam(q, "CallState", *params.CallState); err != nil {
			return nil, err
		}
	}

	if params.Direction != nil {
		if err := client.AddQueryParam(q, "Direction", *params.Direction); err != nil {
			return nil, err
		}
	}

	if params.ProcessingState != nil {
		if err := client.AddQueryParam(q, "ProcessingState", *params.ProcessingState); err != nil {
			return nil, err
		}
	}

	if params.SortBy != nil {
		if err := client.AddQueryParam(q, "SortBy", *params.SortBy); err != nil {
			return nil, err
		}
	}

	if params.Subaccount != nil {
		if err := client.AddQueryParam(q, "Subaccount", *params.Subaccount); err != nil {
			return nil, err
		}
	}

	if params.AbnormalSession != nil {
		if err := client.AddQueryParam(q, "AbnormalSession", *params.AbnormalSession); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListCallSummaries returns a parsed response.
// GET /v1/Voice/Summaries
func (c *Client) ListCallSummaries(ctx context.Context, params *ListCallSummariesParams, reqEditors ...client.RequestEditorFn) (*ListCallSummariesResponse, error) {
	req, err := newListCallSummariesRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListCallSummariesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CallSummaries *[]InsightsV1CallSummaries `json:"call_summaries,omitempty"`
			Meta          *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListEvent: GET /v1/Voice/{CallSid}/Events

type ListEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Events *[]InsightsV1CallEvent `json:"events,omitempty"`
		Meta   *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListEventRequest generates requests for ListEvent
func newListEventRequest(baseURL *url.URL, callSid string, params *ListEventParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListEventFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Edge != nil {
		if err := client.AddQueryParam(q, "Edge", *params.Edge); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListEvent returns a parsed response.
// GET /v1/Voice/{CallSid}/Events
func (c *Client) ListEvent(ctx context.Context, callSid string, params *ListEventParams, reqEditors ...client.RequestEditorFn) (*ListEventResponse, error) {
	req, err := newListEventRequest(c.BaseURL, callSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Events *[]InsightsV1CallEvent `json:"events,omitempty"`
			Meta   *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListMetric: GET /v1/Voice/{CallSid}/Metrics

type ListMetricResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Metrics *[]InsightsV1CallMetric `json:"metrics,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListMetricResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMetricResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListMetricRequest generates requests for ListMetric
func newListMetricRequest(baseURL *url.URL, callSid string, params *ListMetricParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListMetricFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Edge != nil {
		if err := client.AddQueryParam(q, "Edge", *params.Edge); err != nil {
			return nil, err
		}
	}

	if params.Direction != nil {
		if err := client.AddQueryParam(q, "Direction", *params.Direction); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListMetric returns a parsed response.
// GET /v1/Voice/{CallSid}/Metrics
func (c *Client) ListMetric(ctx context.Context, callSid string, params *ListMetricParams, reqEditors ...client.RequestEditorFn) (*ListMetricResponse, error) {
	req, err := newListMetricRequest(c.BaseURL, callSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListMetricResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Metrics *[]InsightsV1CallMetric `json:"metrics,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchSummary: GET /v1/Voice/{CallSid}/Summary

type FetchSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightsV1CallSummary
}

// Status returns HTTPResponse.Status
func (r FetchSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSummaryRequest generates requests for FetchSummary
func newFetchSummaryRequest(baseURL *url.URL, callSid string, params *FetchSummaryParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSummaryFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.ProcessingState != nil {
		if err := client.AddQueryParam(q, "ProcessingState", *params.ProcessingState); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSummary returns a parsed response.
// GET /v1/Voice/{CallSid}/Summary
func (c *Client) FetchSummary(ctx context.Context, callSid string, params *FetchSummaryParams, reqEditors ...client.RequestEditorFn) (*FetchSummaryResponse, error) {
	req, err := newFetchSummaryRequest(c.BaseURL, callSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightsV1CallSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchCall: GET /v1/Voice/{Sid}

type FetchCallResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsightsV1Call
}

// Status returns HTTPResponse.Status
func (r FetchCallResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchCallResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchCallRequest generates requests for FetchCall
func newFetchCallRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchCallFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchCall returns a parsed response.
// GET /v1/Voice/{Sid}
func (c *Client) FetchCall(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchCallResponse, error) {
	req, err := newFetchCallRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchCallResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsightsV1Call
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
