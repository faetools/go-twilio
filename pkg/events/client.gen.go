// Package events provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package events

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/faetools/client"
)

// operation paths

const (
	opPathFetchSchemaFormat           = "./v1/Schemas/%s"
	opPathListSchemaVersionFormat     = "./v1/Schemas/%s/Versions"
	opPathFetchSchemaVersionFormat    = "./v1/Schemas/%s/Versions/%s"
	opPathDeleteSinkFormat            = "./v1/Sinks/%s"
	opPathFetchSinkFormat             = "./v1/Sinks/%s"
	opPathUpdateSinkFormat            = "./v1/Sinks/%s"
	opPathCreateSinkTestFormat        = "./v1/Sinks/%s/Test"
	opPathCreateSinkValidateFormat    = "./v1/Sinks/%s/Validate"
	opPathDeleteSubscriptionFormat    = "./v1/Subscriptions/%s"
	opPathFetchSubscriptionFormat     = "./v1/Subscriptions/%s"
	opPathUpdateSubscriptionFormat    = "./v1/Subscriptions/%s"
	opPathListSubscribedEventFormat   = "./v1/Subscriptions/%s/SubscribedEvents"
	opPathCreateSubscribedEventFormat = "./v1/Subscriptions/%s/SubscribedEvents"
	opPathDeleteSubscribedEventFormat = "./v1/Subscriptions/%s/SubscribedEvents/%s"
	opPathFetchSubscribedEventFormat  = "./v1/Subscriptions/%s/SubscribedEvents/%s"
	opPathUpdateSubscribedEventFormat = "./v1/Subscriptions/%s/SubscribedEvents/%s"
	opPathFetchEventTypeFormat        = "./v1/Types/%s"
)

var (
	opPathListSink           = client.MustParseURL("./v1/Sinks")
	opPathCreateSink         = client.MustParseURL("./v1/Sinks")
	opPathListSubscription   = client.MustParseURL("./v1/Subscriptions")
	opPathCreateSubscription = client.MustParseURL("./v1/Subscriptions")
	opPathListEventType      = client.MustParseURL("./v1/Types")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// FetchSchema request
	FetchSchema(ctx context.Context, id string, reqEditors ...client.RequestEditorFn) (*FetchSchemaResponse, error)

	// ListSchemaVersion request
	ListSchemaVersion(ctx context.Context, id string, params *ListSchemaVersionParams, reqEditors ...client.RequestEditorFn) (*ListSchemaVersionResponse, error)

	// FetchSchemaVersion request
	FetchSchemaVersion(ctx context.Context, id string, schemaVersion int, reqEditors ...client.RequestEditorFn) (*FetchSchemaVersionResponse, error)

	// ListSink request
	ListSink(ctx context.Context, params *ListSinkParams, reqEditors ...client.RequestEditorFn) (*ListSinkResponse, error)

	// CreateSink request with any body
	CreateSinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSinkResponse, error)

	// DeleteSink request
	DeleteSink(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSinkResponse, error)

	// FetchSink request
	FetchSink(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchSinkResponse, error)

	// UpdateSink request with any body
	UpdateSinkWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSinkResponse, error)

	// CreateSinkTest request
	CreateSinkTest(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*CreateSinkTestResponse, error)

	// CreateSinkValidate request with any body
	CreateSinkValidateWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSinkValidateResponse, error)

	// ListSubscription request
	ListSubscription(ctx context.Context, params *ListSubscriptionParams, reqEditors ...client.RequestEditorFn) (*ListSubscriptionResponse, error)

	// CreateSubscription request with any body
	CreateSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSubscriptionResponse, error)

	// DeleteSubscription request
	DeleteSubscription(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSubscriptionResponse, error)

	// FetchSubscription request
	FetchSubscription(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchSubscriptionResponse, error)

	// UpdateSubscription request with any body
	UpdateSubscriptionWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSubscriptionResponse, error)

	// ListSubscribedEvent request
	ListSubscribedEvent(ctx context.Context, subscriptionSid string, params *ListSubscribedEventParams, reqEditors ...client.RequestEditorFn) (*ListSubscribedEventResponse, error)

	// CreateSubscribedEvent request with any body
	CreateSubscribedEventWithBody(ctx context.Context, subscriptionSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSubscribedEventResponse, error)

	// DeleteSubscribedEvent request
	DeleteSubscribedEvent(ctx context.Context, subscriptionSid string, pType string, reqEditors ...client.RequestEditorFn) (*DeleteSubscribedEventResponse, error)

	// FetchSubscribedEvent request
	FetchSubscribedEvent(ctx context.Context, subscriptionSid string, pType string, reqEditors ...client.RequestEditorFn) (*FetchSubscribedEventResponse, error)

	// UpdateSubscribedEvent request with any body
	UpdateSubscribedEventWithBody(ctx context.Context, subscriptionSid string, pType string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSubscribedEventResponse, error)

	// ListEventType request
	ListEventType(ctx context.Context, params *ListEventTypeParams, reqEditors ...client.RequestEditorFn) (*ListEventTypeResponse, error)

	// FetchEventType request
	FetchEventType(ctx context.Context, pType string, reqEditors ...client.RequestEditorFn) (*FetchEventTypeResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// FetchSchema: GET /v1/Schemas/{Id}

type FetchSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventsV1Schema
}

// Status returns HTTPResponse.Status
func (r FetchSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSchemaRequest generates requests for FetchSchema
func newFetchSchemaRequest(baseURL *url.URL, id string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Id", id)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSchemaFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSchema returns a parsed response.
// GET /v1/Schemas/{Id}
func (c *Client) FetchSchema(ctx context.Context, id string, reqEditors ...client.RequestEditorFn) (*FetchSchemaResponse, error) {
	req, err := newFetchSchemaRequest(c.BaseURL, id)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventsV1Schema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSchemaVersion: GET /v1/Schemas/{Id}/Versions

type ListSchemaVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		SchemaVersions *[]EventsV1SchemaSchemaVersion `json:"schema_versions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSchemaVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSchemaVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSchemaVersionRequest generates requests for ListSchemaVersion
func newListSchemaVersionRequest(baseURL *url.URL, id string, params *ListSchemaVersionParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Id", id)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSchemaVersionFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSchemaVersion returns a parsed response.
// GET /v1/Schemas/{Id}/Versions
func (c *Client) ListSchemaVersion(ctx context.Context, id string, params *ListSchemaVersionParams, reqEditors ...client.RequestEditorFn) (*ListSchemaVersionResponse, error) {
	req, err := newListSchemaVersionRequest(c.BaseURL, id, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSchemaVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			SchemaVersions *[]EventsV1SchemaSchemaVersion `json:"schema_versions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchSchemaVersion: GET /v1/Schemas/{Id}/Versions/{SchemaVersion}

type FetchSchemaVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventsV1SchemaSchemaVersion
}

// Status returns HTTPResponse.Status
func (r FetchSchemaVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSchemaVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSchemaVersionRequest generates requests for FetchSchemaVersion
func newFetchSchemaVersionRequest(baseURL *url.URL, id string, schemaVersion int) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Id", id)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("SchemaVersion", schemaVersion)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSchemaVersionFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSchemaVersion returns a parsed response.
// GET /v1/Schemas/{Id}/Versions/{SchemaVersion}
func (c *Client) FetchSchemaVersion(ctx context.Context, id string, schemaVersion int, reqEditors ...client.RequestEditorFn) (*FetchSchemaVersionResponse, error) {
	req, err := newFetchSchemaVersionRequest(c.BaseURL, id, schemaVersion)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSchemaVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventsV1SchemaSchemaVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSink: GET /v1/Sinks

type ListSinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Sinks *[]EventsV1Sink `json:"sinks,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSinkRequest generates requests for ListSink
func newListSinkRequest(baseURL *url.URL, params *ListSinkParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListSink)

	q := queryURL.Query()

	if params.InUse != nil {
		if err := client.AddQueryParam(q, "InUse", *params.InUse); err != nil {
			return nil, err
		}
	}

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSink returns a parsed response.
// GET /v1/Sinks
func (c *Client) ListSink(ctx context.Context, params *ListSinkParams, reqEditors ...client.RequestEditorFn) (*ListSinkResponse, error) {
	req, err := newListSinkRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Sinks *[]EventsV1Sink `json:"sinks,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSink: POST /v1/Sinks

type CreateSinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EventsV1Sink
}

// Status returns HTTPResponse.Status
func (r CreateSinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSinkRequestWithBody generates requests for CreateSink with any type of body
func newCreateSinkRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateSink)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSinkWithBody returns a parsed response.
// POST /v1/Sinks
func (c *Client) CreateSinkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSinkResponse, error) {
	req, err := newCreateSinkRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EventsV1Sink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteSink: DELETE /v1/Sinks/{Sid}

type DeleteSinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSinkRequest generates requests for DeleteSink
func newDeleteSinkRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSinkFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSink returns a parsed response.
// DELETE /v1/Sinks/{Sid}
func (c *Client) DeleteSink(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSinkResponse, error) {
	req, err := newDeleteSinkRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSink: GET /v1/Sinks/{Sid}

type FetchSinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventsV1Sink
}

// Status returns HTTPResponse.Status
func (r FetchSinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSinkRequest generates requests for FetchSink
func newFetchSinkRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSinkFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSink returns a parsed response.
// GET /v1/Sinks/{Sid}
func (c *Client) FetchSink(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchSinkResponse, error) {
	req, err := newFetchSinkRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventsV1Sink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSink: POST /v1/Sinks/{Sid}

type UpdateSinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventsV1Sink
}

// Status returns HTTPResponse.Status
func (r UpdateSinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSinkRequestWithBody generates requests for UpdateSink with any type of body
func newUpdateSinkRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSinkFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSinkWithBody returns a parsed response.
// POST /v1/Sinks/{Sid}
func (c *Client) UpdateSinkWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSinkResponse, error) {
	req, err := newUpdateSinkRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventsV1Sink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSinkTest: POST /v1/Sinks/{Sid}/Test

type CreateSinkTestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EventsV1SinkSinkTest
}

// Status returns HTTPResponse.Status
func (r CreateSinkTestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSinkTestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSinkTestRequest generates requests for CreateSinkTest
func newCreateSinkTestRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSinkTestFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// CreateSinkTest returns a parsed response.
// POST /v1/Sinks/{Sid}/Test
func (c *Client) CreateSinkTest(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*CreateSinkTestResponse, error) {
	req, err := newCreateSinkTestRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSinkTestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EventsV1SinkSinkTest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// CreateSinkValidate: POST /v1/Sinks/{Sid}/Validate

type CreateSinkValidateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EventsV1SinkSinkValidate
}

// Status returns HTTPResponse.Status
func (r CreateSinkValidateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSinkValidateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSinkValidateRequestWithBody generates requests for CreateSinkValidate with any type of body
func newCreateSinkValidateRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSinkValidateFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSinkValidateWithBody returns a parsed response.
// POST /v1/Sinks/{Sid}/Validate
func (c *Client) CreateSinkValidateWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSinkValidateResponse, error) {
	req, err := newCreateSinkValidateRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSinkValidateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EventsV1SinkSinkValidate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListSubscription: GET /v1/Subscriptions

type ListSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Subscriptions *[]EventsV1Subscription `json:"subscriptions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSubscriptionRequest generates requests for ListSubscription
func newListSubscriptionRequest(baseURL *url.URL, params *ListSubscriptionParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListSubscription)

	q := queryURL.Query()

	if params.SinkSid != nil {
		if err := client.AddQueryParam(q, "SinkSid", *params.SinkSid); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSubscription returns a parsed response.
// GET /v1/Subscriptions
func (c *Client) ListSubscription(ctx context.Context, params *ListSubscriptionParams, reqEditors ...client.RequestEditorFn) (*ListSubscriptionResponse, error) {
	req, err := newListSubscriptionRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Subscriptions *[]EventsV1Subscription `json:"subscriptions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSubscription: POST /v1/Subscriptions

type CreateSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EventsV1Subscription
}

// Status returns HTTPResponse.Status
func (r CreateSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSubscriptionRequestWithBody generates requests for CreateSubscription with any type of body
func newCreateSubscriptionRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateSubscription)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSubscriptionWithBody returns a parsed response.
// POST /v1/Subscriptions
func (c *Client) CreateSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSubscriptionResponse, error) {
	req, err := newCreateSubscriptionRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EventsV1Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteSubscription: DELETE /v1/Subscriptions/{Sid}

type DeleteSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSubscriptionRequest generates requests for DeleteSubscription
func newDeleteSubscriptionRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSubscriptionFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSubscription returns a parsed response.
// DELETE /v1/Subscriptions/{Sid}
func (c *Client) DeleteSubscription(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSubscriptionResponse, error) {
	req, err := newDeleteSubscriptionRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSubscription: GET /v1/Subscriptions/{Sid}

type FetchSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventsV1Subscription
}

// Status returns HTTPResponse.Status
func (r FetchSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSubscriptionRequest generates requests for FetchSubscription
func newFetchSubscriptionRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSubscriptionFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSubscription returns a parsed response.
// GET /v1/Subscriptions/{Sid}
func (c *Client) FetchSubscription(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchSubscriptionResponse, error) {
	req, err := newFetchSubscriptionRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventsV1Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSubscription: POST /v1/Subscriptions/{Sid}

type UpdateSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventsV1Subscription
}

// Status returns HTTPResponse.Status
func (r UpdateSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSubscriptionRequestWithBody generates requests for UpdateSubscription with any type of body
func newUpdateSubscriptionRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSubscriptionFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSubscriptionWithBody returns a parsed response.
// POST /v1/Subscriptions/{Sid}
func (c *Client) UpdateSubscriptionWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSubscriptionResponse, error) {
	req, err := newUpdateSubscriptionRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventsV1Subscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSubscribedEvent: GET /v1/Subscriptions/{SubscriptionSid}/SubscribedEvents

type ListSubscribedEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Types *[]EventsV1SubscriptionSubscribedEvent `json:"types,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSubscribedEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSubscribedEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSubscribedEventRequest generates requests for ListSubscribedEvent
func newListSubscribedEventRequest(baseURL *url.URL, subscriptionSid string, params *ListSubscribedEventParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("SubscriptionSid", subscriptionSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSubscribedEventFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSubscribedEvent returns a parsed response.
// GET /v1/Subscriptions/{SubscriptionSid}/SubscribedEvents
func (c *Client) ListSubscribedEvent(ctx context.Context, subscriptionSid string, params *ListSubscribedEventParams, reqEditors ...client.RequestEditorFn) (*ListSubscribedEventResponse, error) {
	req, err := newListSubscribedEventRequest(c.BaseURL, subscriptionSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSubscribedEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Types *[]EventsV1SubscriptionSubscribedEvent `json:"types,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSubscribedEvent: POST /v1/Subscriptions/{SubscriptionSid}/SubscribedEvents

type CreateSubscribedEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EventsV1SubscriptionSubscribedEvent
}

// Status returns HTTPResponse.Status
func (r CreateSubscribedEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSubscribedEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSubscribedEventRequestWithBody generates requests for CreateSubscribedEvent with any type of body
func newCreateSubscribedEventRequestWithBody(baseURL *url.URL, subscriptionSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("SubscriptionSid", subscriptionSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSubscribedEventFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSubscribedEventWithBody returns a parsed response.
// POST /v1/Subscriptions/{SubscriptionSid}/SubscribedEvents
func (c *Client) CreateSubscribedEventWithBody(ctx context.Context, subscriptionSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSubscribedEventResponse, error) {
	req, err := newCreateSubscribedEventRequestWithBody(c.BaseURL, subscriptionSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSubscribedEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EventsV1SubscriptionSubscribedEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteSubscribedEvent: DELETE /v1/Subscriptions/{SubscriptionSid}/SubscribedEvents/{Type}

type DeleteSubscribedEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSubscribedEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSubscribedEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSubscribedEventRequest generates requests for DeleteSubscribedEvent
func newDeleteSubscribedEventRequest(baseURL *url.URL, subscriptionSid string, pType string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("SubscriptionSid", subscriptionSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Type", pType)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSubscribedEventFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSubscribedEvent returns a parsed response.
// DELETE /v1/Subscriptions/{SubscriptionSid}/SubscribedEvents/{Type}
func (c *Client) DeleteSubscribedEvent(ctx context.Context, subscriptionSid string, pType string, reqEditors ...client.RequestEditorFn) (*DeleteSubscribedEventResponse, error) {
	req, err := newDeleteSubscribedEventRequest(c.BaseURL, subscriptionSid, pType)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSubscribedEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSubscribedEvent: GET /v1/Subscriptions/{SubscriptionSid}/SubscribedEvents/{Type}

type FetchSubscribedEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventsV1SubscriptionSubscribedEvent
}

// Status returns HTTPResponse.Status
func (r FetchSubscribedEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSubscribedEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSubscribedEventRequest generates requests for FetchSubscribedEvent
func newFetchSubscribedEventRequest(baseURL *url.URL, subscriptionSid string, pType string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("SubscriptionSid", subscriptionSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Type", pType)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSubscribedEventFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSubscribedEvent returns a parsed response.
// GET /v1/Subscriptions/{SubscriptionSid}/SubscribedEvents/{Type}
func (c *Client) FetchSubscribedEvent(ctx context.Context, subscriptionSid string, pType string, reqEditors ...client.RequestEditorFn) (*FetchSubscribedEventResponse, error) {
	req, err := newFetchSubscribedEventRequest(c.BaseURL, subscriptionSid, pType)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSubscribedEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventsV1SubscriptionSubscribedEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSubscribedEvent: POST /v1/Subscriptions/{SubscriptionSid}/SubscribedEvents/{Type}

type UpdateSubscribedEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventsV1SubscriptionSubscribedEvent
}

// Status returns HTTPResponse.Status
func (r UpdateSubscribedEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSubscribedEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSubscribedEventRequestWithBody generates requests for UpdateSubscribedEvent with any type of body
func newUpdateSubscribedEventRequestWithBody(baseURL *url.URL, subscriptionSid string, pType string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("SubscriptionSid", subscriptionSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Type", pType)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSubscribedEventFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSubscribedEventWithBody returns a parsed response.
// POST /v1/Subscriptions/{SubscriptionSid}/SubscribedEvents/{Type}
func (c *Client) UpdateSubscribedEventWithBody(ctx context.Context, subscriptionSid string, pType string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSubscribedEventResponse, error) {
	req, err := newUpdateSubscribedEventRequestWithBody(c.BaseURL, subscriptionSid, pType, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSubscribedEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventsV1SubscriptionSubscribedEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListEventType: GET /v1/Types

type ListEventTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Types *[]EventsV1EventType `json:"types,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListEventTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListEventTypeRequest generates requests for ListEventType
func newListEventTypeRequest(baseURL *url.URL, params *ListEventTypeParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListEventType)

	q := queryURL.Query()

	if params.SchemaId != nil {
		if err := client.AddQueryParam(q, "SchemaId", *params.SchemaId); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListEventType returns a parsed response.
// GET /v1/Types
func (c *Client) ListEventType(ctx context.Context, params *ListEventTypeParams, reqEditors ...client.RequestEditorFn) (*ListEventTypeResponse, error) {
	req, err := newListEventTypeRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListEventTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Types *[]EventsV1EventType `json:"types,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchEventType: GET /v1/Types/{Type}

type FetchEventTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventsV1EventType
}

// Status returns HTTPResponse.Status
func (r FetchEventTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchEventTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchEventTypeRequest generates requests for FetchEventType
func newFetchEventTypeRequest(baseURL *url.URL, pType string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Type", pType)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchEventTypeFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchEventType returns a parsed response.
// GET /v1/Types/{Type}
func (c *Client) FetchEventType(ctx context.Context, pType string, reqEditors ...client.RequestEditorFn) (*FetchEventTypeResponse, error) {
	req, err := newFetchEventTypeRequest(c.BaseURL, pType)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchEventTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventsV1EventType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
