// Package accounts provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package accounts

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/faetools/client"
)

// operation paths

const (
	opPathDeleteCredentialAwsFormat       = "./v1/Credentials/AWS/%s"
	opPathFetchCredentialAwsFormat        = "./v1/Credentials/AWS/%s"
	opPathUpdateCredentialAwsFormat       = "./v1/Credentials/AWS/%s"
	opPathDeleteCredentialPublicKeyFormat = "./v1/Credentials/PublicKeys/%s"
	opPathFetchCredentialPublicKeyFormat  = "./v1/Credentials/PublicKeys/%s"
	opPathUpdateCredentialPublicKeyFormat = "./v1/Credentials/PublicKeys/%s"
)

var (
	opPathUpdateAuthTokenPromotion  = client.MustParseURL("./v1/AuthTokens/Promote")
	opPathDeleteSecondaryAuthToken  = client.MustParseURL("./v1/AuthTokens/Secondary")
	opPathCreateSecondaryAuthToken  = client.MustParseURL("./v1/AuthTokens/Secondary")
	opPathListCredentialAws         = client.MustParseURL("./v1/Credentials/AWS")
	opPathCreateCredentialAws       = client.MustParseURL("./v1/Credentials/AWS")
	opPathListCredentialPublicKey   = client.MustParseURL("./v1/Credentials/PublicKeys")
	opPathCreateCredentialPublicKey = client.MustParseURL("./v1/Credentials/PublicKeys")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// UpdateAuthTokenPromotion request
	UpdateAuthTokenPromotion(ctx context.Context, reqEditors ...client.RequestEditorFn) (*UpdateAuthTokenPromotionResponse, error)

	// DeleteSecondaryAuthToken request
	DeleteSecondaryAuthToken(ctx context.Context, reqEditors ...client.RequestEditorFn) (*DeleteSecondaryAuthTokenResponse, error)

	// CreateSecondaryAuthToken request
	CreateSecondaryAuthToken(ctx context.Context, reqEditors ...client.RequestEditorFn) (*CreateSecondaryAuthTokenResponse, error)

	// ListCredentialAws request
	ListCredentialAws(ctx context.Context, params *ListCredentialAwsParams, reqEditors ...client.RequestEditorFn) (*ListCredentialAwsResponse, error)

	// CreateCredentialAws request with any body
	CreateCredentialAwsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCredentialAwsResponse, error)

	// DeleteCredentialAws request
	DeleteCredentialAws(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCredentialAwsResponse, error)

	// FetchCredentialAws request
	FetchCredentialAws(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchCredentialAwsResponse, error)

	// UpdateCredentialAws request with any body
	UpdateCredentialAwsWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateCredentialAwsResponse, error)

	// ListCredentialPublicKey request
	ListCredentialPublicKey(ctx context.Context, params *ListCredentialPublicKeyParams, reqEditors ...client.RequestEditorFn) (*ListCredentialPublicKeyResponse, error)

	// CreateCredentialPublicKey request with any body
	CreateCredentialPublicKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCredentialPublicKeyResponse, error)

	// DeleteCredentialPublicKey request
	DeleteCredentialPublicKey(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCredentialPublicKeyResponse, error)

	// FetchCredentialPublicKey request
	FetchCredentialPublicKey(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchCredentialPublicKeyResponse, error)

	// UpdateCredentialPublicKey request with any body
	UpdateCredentialPublicKeyWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateCredentialPublicKeyResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// UpdateAuthTokenPromotion: POST /v1/AuthTokens/Promote

type UpdateAuthTokenPromotionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsV1AuthTokenPromotion
}

// Status returns HTTPResponse.Status
func (r UpdateAuthTokenPromotionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAuthTokenPromotionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateAuthTokenPromotionRequest generates requests for UpdateAuthTokenPromotion
func newUpdateAuthTokenPromotionRequest(baseURL *url.URL) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathUpdateAuthTokenPromotion)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// UpdateAuthTokenPromotion returns a parsed response.
// POST /v1/AuthTokens/Promote
func (c *Client) UpdateAuthTokenPromotion(ctx context.Context, reqEditors ...client.RequestEditorFn) (*UpdateAuthTokenPromotionResponse, error) {
	req, err := newUpdateAuthTokenPromotionRequest(c.BaseURL)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateAuthTokenPromotionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsV1AuthTokenPromotion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteSecondaryAuthToken: DELETE /v1/AuthTokens/Secondary

type DeleteSecondaryAuthTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSecondaryAuthTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSecondaryAuthTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSecondaryAuthTokenRequest generates requests for DeleteSecondaryAuthToken
func newDeleteSecondaryAuthTokenRequest(baseURL *url.URL) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathDeleteSecondaryAuthToken)

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSecondaryAuthToken returns a parsed response.
// DELETE /v1/AuthTokens/Secondary
func (c *Client) DeleteSecondaryAuthToken(ctx context.Context, reqEditors ...client.RequestEditorFn) (*DeleteSecondaryAuthTokenResponse, error) {
	req, err := newDeleteSecondaryAuthTokenRequest(c.BaseURL)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSecondaryAuthTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// CreateSecondaryAuthToken: POST /v1/AuthTokens/Secondary

type CreateSecondaryAuthTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AccountsV1SecondaryAuthToken
}

// Status returns HTTPResponse.Status
func (r CreateSecondaryAuthTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSecondaryAuthTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSecondaryAuthTokenRequest generates requests for CreateSecondaryAuthToken
func newCreateSecondaryAuthTokenRequest(baseURL *url.URL) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateSecondaryAuthToken)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// CreateSecondaryAuthToken returns a parsed response.
// POST /v1/AuthTokens/Secondary
func (c *Client) CreateSecondaryAuthToken(ctx context.Context, reqEditors ...client.RequestEditorFn) (*CreateSecondaryAuthTokenResponse, error) {
	req, err := newCreateSecondaryAuthTokenRequest(c.BaseURL)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSecondaryAuthTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AccountsV1SecondaryAuthToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListCredentialAws: GET /v1/Credentials/AWS

type ListCredentialAwsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Credentials *[]AccountsV1CredentialCredentialAws `json:"credentials,omitempty"`
		Meta        *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCredentialAwsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCredentialAwsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListCredentialAwsRequest generates requests for ListCredentialAws
func newListCredentialAwsRequest(baseURL *url.URL, params *ListCredentialAwsParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListCredentialAws)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListCredentialAws returns a parsed response.
// GET /v1/Credentials/AWS
func (c *Client) ListCredentialAws(ctx context.Context, params *ListCredentialAwsParams, reqEditors ...client.RequestEditorFn) (*ListCredentialAwsResponse, error) {
	req, err := newListCredentialAwsRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListCredentialAwsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Credentials *[]AccountsV1CredentialCredentialAws `json:"credentials,omitempty"`
			Meta        *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateCredentialAws: POST /v1/Credentials/AWS

type CreateCredentialAwsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AccountsV1CredentialCredentialAws
}

// Status returns HTTPResponse.Status
func (r CreateCredentialAwsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCredentialAwsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateCredentialAwsRequestWithBody generates requests for CreateCredentialAws with any type of body
func newCreateCredentialAwsRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateCredentialAws)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateCredentialAwsWithBody returns a parsed response.
// POST /v1/Credentials/AWS
func (c *Client) CreateCredentialAwsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCredentialAwsResponse, error) {
	req, err := newCreateCredentialAwsRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateCredentialAwsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AccountsV1CredentialCredentialAws
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteCredentialAws: DELETE /v1/Credentials/AWS/{Sid}

type DeleteCredentialAwsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCredentialAwsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCredentialAwsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteCredentialAwsRequest generates requests for DeleteCredentialAws
func newDeleteCredentialAwsRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteCredentialAwsFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteCredentialAws returns a parsed response.
// DELETE /v1/Credentials/AWS/{Sid}
func (c *Client) DeleteCredentialAws(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCredentialAwsResponse, error) {
	req, err := newDeleteCredentialAwsRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteCredentialAwsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchCredentialAws: GET /v1/Credentials/AWS/{Sid}

type FetchCredentialAwsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsV1CredentialCredentialAws
}

// Status returns HTTPResponse.Status
func (r FetchCredentialAwsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchCredentialAwsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchCredentialAwsRequest generates requests for FetchCredentialAws
func newFetchCredentialAwsRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchCredentialAwsFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchCredentialAws returns a parsed response.
// GET /v1/Credentials/AWS/{Sid}
func (c *Client) FetchCredentialAws(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchCredentialAwsResponse, error) {
	req, err := newFetchCredentialAwsRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchCredentialAwsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsV1CredentialCredentialAws
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateCredentialAws: POST /v1/Credentials/AWS/{Sid}

type UpdateCredentialAwsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsV1CredentialCredentialAws
}

// Status returns HTTPResponse.Status
func (r UpdateCredentialAwsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCredentialAwsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateCredentialAwsRequestWithBody generates requests for UpdateCredentialAws with any type of body
func newUpdateCredentialAwsRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateCredentialAwsFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateCredentialAwsWithBody returns a parsed response.
// POST /v1/Credentials/AWS/{Sid}
func (c *Client) UpdateCredentialAwsWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateCredentialAwsResponse, error) {
	req, err := newUpdateCredentialAwsRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateCredentialAwsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsV1CredentialCredentialAws
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListCredentialPublicKey: GET /v1/Credentials/PublicKeys

type ListCredentialPublicKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Credentials *[]AccountsV1CredentialCredentialPublicKey `json:"credentials,omitempty"`
		Meta        *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCredentialPublicKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCredentialPublicKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListCredentialPublicKeyRequest generates requests for ListCredentialPublicKey
func newListCredentialPublicKeyRequest(baseURL *url.URL, params *ListCredentialPublicKeyParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListCredentialPublicKey)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListCredentialPublicKey returns a parsed response.
// GET /v1/Credentials/PublicKeys
func (c *Client) ListCredentialPublicKey(ctx context.Context, params *ListCredentialPublicKeyParams, reqEditors ...client.RequestEditorFn) (*ListCredentialPublicKeyResponse, error) {
	req, err := newListCredentialPublicKeyRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListCredentialPublicKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Credentials *[]AccountsV1CredentialCredentialPublicKey `json:"credentials,omitempty"`
			Meta        *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateCredentialPublicKey: POST /v1/Credentials/PublicKeys

type CreateCredentialPublicKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AccountsV1CredentialCredentialPublicKey
}

// Status returns HTTPResponse.Status
func (r CreateCredentialPublicKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCredentialPublicKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateCredentialPublicKeyRequestWithBody generates requests for CreateCredentialPublicKey with any type of body
func newCreateCredentialPublicKeyRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateCredentialPublicKey)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateCredentialPublicKeyWithBody returns a parsed response.
// POST /v1/Credentials/PublicKeys
func (c *Client) CreateCredentialPublicKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCredentialPublicKeyResponse, error) {
	req, err := newCreateCredentialPublicKeyRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateCredentialPublicKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AccountsV1CredentialCredentialPublicKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteCredentialPublicKey: DELETE /v1/Credentials/PublicKeys/{Sid}

type DeleteCredentialPublicKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCredentialPublicKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCredentialPublicKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteCredentialPublicKeyRequest generates requests for DeleteCredentialPublicKey
func newDeleteCredentialPublicKeyRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteCredentialPublicKeyFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteCredentialPublicKey returns a parsed response.
// DELETE /v1/Credentials/PublicKeys/{Sid}
func (c *Client) DeleteCredentialPublicKey(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCredentialPublicKeyResponse, error) {
	req, err := newDeleteCredentialPublicKeyRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteCredentialPublicKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchCredentialPublicKey: GET /v1/Credentials/PublicKeys/{Sid}

type FetchCredentialPublicKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsV1CredentialCredentialPublicKey
}

// Status returns HTTPResponse.Status
func (r FetchCredentialPublicKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchCredentialPublicKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchCredentialPublicKeyRequest generates requests for FetchCredentialPublicKey
func newFetchCredentialPublicKeyRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchCredentialPublicKeyFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchCredentialPublicKey returns a parsed response.
// GET /v1/Credentials/PublicKeys/{Sid}
func (c *Client) FetchCredentialPublicKey(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchCredentialPublicKeyResponse, error) {
	req, err := newFetchCredentialPublicKeyRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchCredentialPublicKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsV1CredentialCredentialPublicKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateCredentialPublicKey: POST /v1/Credentials/PublicKeys/{Sid}

type UpdateCredentialPublicKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsV1CredentialCredentialPublicKey
}

// Status returns HTTPResponse.Status
func (r UpdateCredentialPublicKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCredentialPublicKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateCredentialPublicKeyRequestWithBody generates requests for UpdateCredentialPublicKey with any type of body
func newUpdateCredentialPublicKeyRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateCredentialPublicKeyFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateCredentialPublicKeyWithBody returns a parsed response.
// POST /v1/Credentials/PublicKeys/{Sid}
func (c *Client) UpdateCredentialPublicKeyWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateCredentialPublicKeyResponse, error) {
	req, err := newUpdateCredentialPublicKeyRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateCredentialPublicKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsV1CredentialCredentialPublicKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
