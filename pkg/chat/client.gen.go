// Package chat provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package chat

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/faetools/client"
)

// operation paths

const (
	opPathDeleteCredentialFormat     = "./v2/Credentials/%s"
	opPathFetchCredentialFormat      = "./v2/Credentials/%s"
	opPathUpdateCredentialFormat     = "./v2/Credentials/%s"
	opPathListBindingFormat          = "./v2/Services/%s/Bindings"
	opPathDeleteBindingFormat        = "./v2/Services/%s/Bindings/%s"
	opPathFetchBindingFormat         = "./v2/Services/%s/Bindings/%s"
	opPathListChannelFormat          = "./v2/Services/%s/Channels"
	opPathCreateChannelFormat        = "./v2/Services/%s/Channels"
	opPathListInviteFormat           = "./v2/Services/%s/Channels/%s/Invites"
	opPathCreateInviteFormat         = "./v2/Services/%s/Channels/%s/Invites"
	opPathDeleteInviteFormat         = "./v2/Services/%s/Channels/%s/Invites/%s"
	opPathFetchInviteFormat          = "./v2/Services/%s/Channels/%s/Invites/%s"
	opPathListMemberFormat           = "./v2/Services/%s/Channels/%s/Members"
	opPathCreateMemberFormat         = "./v2/Services/%s/Channels/%s/Members"
	opPathDeleteMemberFormat         = "./v2/Services/%s/Channels/%s/Members/%s"
	opPathFetchMemberFormat          = "./v2/Services/%s/Channels/%s/Members/%s"
	opPathUpdateMemberFormat         = "./v2/Services/%s/Channels/%s/Members/%s"
	opPathListMessageFormat          = "./v2/Services/%s/Channels/%s/Messages"
	opPathCreateMessageFormat        = "./v2/Services/%s/Channels/%s/Messages"
	opPathDeleteMessageFormat        = "./v2/Services/%s/Channels/%s/Messages/%s"
	opPathFetchMessageFormat         = "./v2/Services/%s/Channels/%s/Messages/%s"
	opPathUpdateMessageFormat        = "./v2/Services/%s/Channels/%s/Messages/%s"
	opPathListChannelWebhookFormat   = "./v2/Services/%s/Channels/%s/Webhooks"
	opPathCreateChannelWebhookFormat = "./v2/Services/%s/Channels/%s/Webhooks"
	opPathDeleteChannelWebhookFormat = "./v2/Services/%s/Channels/%s/Webhooks/%s"
	opPathFetchChannelWebhookFormat  = "./v2/Services/%s/Channels/%s/Webhooks/%s"
	opPathUpdateChannelWebhookFormat = "./v2/Services/%s/Channels/%s/Webhooks/%s"
	opPathDeleteChannelFormat        = "./v2/Services/%s/Channels/%s"
	opPathFetchChannelFormat         = "./v2/Services/%s/Channels/%s"
	opPathUpdateChannelFormat        = "./v2/Services/%s/Channels/%s"
	opPathListRoleFormat             = "./v2/Services/%s/Roles"
	opPathCreateRoleFormat           = "./v2/Services/%s/Roles"
	opPathDeleteRoleFormat           = "./v2/Services/%s/Roles/%s"
	opPathFetchRoleFormat            = "./v2/Services/%s/Roles/%s"
	opPathUpdateRoleFormat           = "./v2/Services/%s/Roles/%s"
	opPathListUserFormat             = "./v2/Services/%s/Users"
	opPathCreateUserFormat           = "./v2/Services/%s/Users"
	opPathDeleteUserFormat           = "./v2/Services/%s/Users/%s"
	opPathFetchUserFormat            = "./v2/Services/%s/Users/%s"
	opPathUpdateUserFormat           = "./v2/Services/%s/Users/%s"
	opPathListUserBindingFormat      = "./v2/Services/%s/Users/%s/Bindings"
	opPathDeleteUserBindingFormat    = "./v2/Services/%s/Users/%s/Bindings/%s"
	opPathFetchUserBindingFormat     = "./v2/Services/%s/Users/%s/Bindings/%s"
	opPathListUserChannelFormat      = "./v2/Services/%s/Users/%s/Channels"
	opPathDeleteUserChannelFormat    = "./v2/Services/%s/Users/%s/Channels/%s"
	opPathFetchUserChannelFormat     = "./v2/Services/%s/Users/%s/Channels/%s"
	opPathUpdateUserChannelFormat    = "./v2/Services/%s/Users/%s/Channels/%s"
	opPathDeleteServiceFormat        = "./v2/Services/%s"
	opPathFetchServiceFormat         = "./v2/Services/%s"
	opPathUpdateServiceFormat        = "./v2/Services/%s"
)

var (
	opPathListCredential   = client.MustParseURL("./v2/Credentials")
	opPathCreateCredential = client.MustParseURL("./v2/Credentials")
	opPathListService      = client.MustParseURL("./v2/Services")
	opPathCreateService    = client.MustParseURL("./v2/Services")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// ListCredential request
	ListCredential(ctx context.Context, params *ListCredentialParams, reqEditors ...client.RequestEditorFn) (*ListCredentialResponse, error)

	// CreateCredential request with any body
	CreateCredentialWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCredentialResponse, error)

	// DeleteCredential request
	DeleteCredential(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCredentialResponse, error)

	// FetchCredential request
	FetchCredential(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchCredentialResponse, error)

	// UpdateCredential request with any body
	UpdateCredentialWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateCredentialResponse, error)

	// ListService request
	ListService(ctx context.Context, params *ListServiceParams, reqEditors ...client.RequestEditorFn) (*ListServiceResponse, error)

	// CreateService request with any body
	CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceResponse, error)

	// ListBinding request
	ListBinding(ctx context.Context, serviceSid string, params *ListBindingParams, reqEditors ...client.RequestEditorFn) (*ListBindingResponse, error)

	// DeleteBinding request
	DeleteBinding(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteBindingResponse, error)

	// FetchBinding request
	FetchBinding(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchBindingResponse, error)

	// ListChannel request
	ListChannel(ctx context.Context, serviceSid string, params *ListChannelParams, reqEditors ...client.RequestEditorFn) (*ListChannelResponse, error)

	// CreateChannel request with any body
	CreateChannelWithBody(ctx context.Context, serviceSid string, params *CreateChannelParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateChannelResponse, error)

	// ListInvite request
	ListInvite(ctx context.Context, serviceSid string, channelSid string, params *ListInviteParams, reqEditors ...client.RequestEditorFn) (*ListInviteResponse, error)

	// CreateInvite request with any body
	CreateInviteWithBody(ctx context.Context, serviceSid string, channelSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateInviteResponse, error)

	// DeleteInvite request
	DeleteInvite(ctx context.Context, serviceSid string, channelSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteInviteResponse, error)

	// FetchInvite request
	FetchInvite(ctx context.Context, serviceSid string, channelSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchInviteResponse, error)

	// ListMember request
	ListMember(ctx context.Context, serviceSid string, channelSid string, params *ListMemberParams, reqEditors ...client.RequestEditorFn) (*ListMemberResponse, error)

	// CreateMember request with any body
	CreateMemberWithBody(ctx context.Context, serviceSid string, channelSid string, params *CreateMemberParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateMemberResponse, error)

	// DeleteMember request
	DeleteMember(ctx context.Context, serviceSid string, channelSid string, sid string, params *DeleteMemberParams, reqEditors ...client.RequestEditorFn) (*DeleteMemberResponse, error)

	// FetchMember request
	FetchMember(ctx context.Context, serviceSid string, channelSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchMemberResponse, error)

	// UpdateMember request with any body
	UpdateMemberWithBody(ctx context.Context, serviceSid string, channelSid string, sid string, params *UpdateMemberParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateMemberResponse, error)

	// ListMessage request
	ListMessage(ctx context.Context, serviceSid string, channelSid string, params *ListMessageParams, reqEditors ...client.RequestEditorFn) (*ListMessageResponse, error)

	// CreateMessage request with any body
	CreateMessageWithBody(ctx context.Context, serviceSid string, channelSid string, params *CreateMessageParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateMessageResponse, error)

	// DeleteMessage request
	DeleteMessage(ctx context.Context, serviceSid string, channelSid string, sid string, params *DeleteMessageParams, reqEditors ...client.RequestEditorFn) (*DeleteMessageResponse, error)

	// FetchMessage request
	FetchMessage(ctx context.Context, serviceSid string, channelSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchMessageResponse, error)

	// UpdateMessage request with any body
	UpdateMessageWithBody(ctx context.Context, serviceSid string, channelSid string, sid string, params *UpdateMessageParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateMessageResponse, error)

	// ListChannelWebhook request
	ListChannelWebhook(ctx context.Context, serviceSid string, channelSid string, params *ListChannelWebhookParams, reqEditors ...client.RequestEditorFn) (*ListChannelWebhookResponse, error)

	// CreateChannelWebhook request with any body
	CreateChannelWebhookWithBody(ctx context.Context, serviceSid string, channelSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateChannelWebhookResponse, error)

	// DeleteChannelWebhook request
	DeleteChannelWebhook(ctx context.Context, serviceSid string, channelSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteChannelWebhookResponse, error)

	// FetchChannelWebhook request
	FetchChannelWebhook(ctx context.Context, serviceSid string, channelSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchChannelWebhookResponse, error)

	// UpdateChannelWebhook request with any body
	UpdateChannelWebhookWithBody(ctx context.Context, serviceSid string, channelSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateChannelWebhookResponse, error)

	// DeleteChannel request
	DeleteChannel(ctx context.Context, serviceSid string, sid string, params *DeleteChannelParams, reqEditors ...client.RequestEditorFn) (*DeleteChannelResponse, error)

	// FetchChannel request
	FetchChannel(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchChannelResponse, error)

	// UpdateChannel request with any body
	UpdateChannelWithBody(ctx context.Context, serviceSid string, sid string, params *UpdateChannelParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateChannelResponse, error)

	// ListRole request
	ListRole(ctx context.Context, serviceSid string, params *ListRoleParams, reqEditors ...client.RequestEditorFn) (*ListRoleResponse, error)

	// CreateRole request with any body
	CreateRoleWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateRoleResponse, error)

	// DeleteRole request
	DeleteRole(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteRoleResponse, error)

	// FetchRole request
	FetchRole(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchRoleResponse, error)

	// UpdateRole request with any body
	UpdateRoleWithBody(ctx context.Context, serviceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateRoleResponse, error)

	// ListUser request
	ListUser(ctx context.Context, serviceSid string, params *ListUserParams, reqEditors ...client.RequestEditorFn) (*ListUserResponse, error)

	// CreateUser request with any body
	CreateUserWithBody(ctx context.Context, serviceSid string, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteUserResponse, error)

	// FetchUser request
	FetchUser(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchUserResponse, error)

	// UpdateUser request with any body
	UpdateUserWithBody(ctx context.Context, serviceSid string, sid string, params *UpdateUserParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateUserResponse, error)

	// ListUserBinding request
	ListUserBinding(ctx context.Context, serviceSid string, userSid string, params *ListUserBindingParams, reqEditors ...client.RequestEditorFn) (*ListUserBindingResponse, error)

	// DeleteUserBinding request
	DeleteUserBinding(ctx context.Context, serviceSid string, userSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteUserBindingResponse, error)

	// FetchUserBinding request
	FetchUserBinding(ctx context.Context, serviceSid string, userSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchUserBindingResponse, error)

	// ListUserChannel request
	ListUserChannel(ctx context.Context, serviceSid string, userSid string, params *ListUserChannelParams, reqEditors ...client.RequestEditorFn) (*ListUserChannelResponse, error)

	// DeleteUserChannel request
	DeleteUserChannel(ctx context.Context, serviceSid string, userSid string, channelSid string, params *DeleteUserChannelParams, reqEditors ...client.RequestEditorFn) (*DeleteUserChannelResponse, error)

	// FetchUserChannel request
	FetchUserChannel(ctx context.Context, serviceSid string, userSid string, channelSid string, reqEditors ...client.RequestEditorFn) (*FetchUserChannelResponse, error)

	// UpdateUserChannel request with any body
	UpdateUserChannelWithBody(ctx context.Context, serviceSid string, userSid string, channelSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateUserChannelResponse, error)

	// DeleteService request
	DeleteService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteServiceResponse, error)

	// FetchService request
	FetchService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceResponse, error)

	// UpdateService request with any body
	UpdateServiceWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// ListCredential: GET /v2/Credentials

type ListCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Credentials *[]ChatV2Credential `json:"credentials,omitempty"`
		Meta        *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListCredentialRequest generates requests for ListCredential
func newListCredentialRequest(baseURL *url.URL, params *ListCredentialParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListCredential)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListCredential returns a parsed response.
// GET /v2/Credentials
func (c *Client) ListCredential(ctx context.Context, params *ListCredentialParams, reqEditors ...client.RequestEditorFn) (*ListCredentialResponse, error) {
	req, err := newListCredentialRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Credentials *[]ChatV2Credential `json:"credentials,omitempty"`
			Meta        *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateCredential: POST /v2/Credentials

type CreateCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ChatV2Credential
}

// Status returns HTTPResponse.Status
func (r CreateCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateCredentialRequestWithBody generates requests for CreateCredential with any type of body
func newCreateCredentialRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateCredential)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateCredentialWithBody returns a parsed response.
// POST /v2/Credentials
func (c *Client) CreateCredentialWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCredentialResponse, error) {
	req, err := newCreateCredentialRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ChatV2Credential
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteCredential: DELETE /v2/Credentials/{Sid}

type DeleteCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteCredentialRequest generates requests for DeleteCredential
func newDeleteCredentialRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteCredentialFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteCredential returns a parsed response.
// DELETE /v2/Credentials/{Sid}
func (c *Client) DeleteCredential(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCredentialResponse, error) {
	req, err := newDeleteCredentialRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchCredential: GET /v2/Credentials/{Sid}

type FetchCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2Credential
}

// Status returns HTTPResponse.Status
func (r FetchCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchCredentialRequest generates requests for FetchCredential
func newFetchCredentialRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchCredentialFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchCredential returns a parsed response.
// GET /v2/Credentials/{Sid}
func (c *Client) FetchCredential(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchCredentialResponse, error) {
	req, err := newFetchCredentialRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2Credential
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateCredential: POST /v2/Credentials/{Sid}

type UpdateCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2Credential
}

// Status returns HTTPResponse.Status
func (r UpdateCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateCredentialRequestWithBody generates requests for UpdateCredential with any type of body
func newUpdateCredentialRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateCredentialFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateCredentialWithBody returns a parsed response.
// POST /v2/Credentials/{Sid}
func (c *Client) UpdateCredentialWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateCredentialResponse, error) {
	req, err := newUpdateCredentialRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2Credential
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListService: GET /v2/Services

type ListServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Services *[]ChatV2Service `json:"services,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListServiceRequest generates requests for ListService
func newListServiceRequest(baseURL *url.URL, params *ListServiceParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListService)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListService returns a parsed response.
// GET /v2/Services
func (c *Client) ListService(ctx context.Context, params *ListServiceParams, reqEditors ...client.RequestEditorFn) (*ListServiceResponse, error) {
	req, err := newListServiceRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Services *[]ChatV2Service `json:"services,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateService: POST /v2/Services

type CreateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ChatV2Service
}

// Status returns HTTPResponse.Status
func (r CreateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateServiceRequestWithBody generates requests for CreateService with any type of body
func newCreateServiceRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateService)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateServiceWithBody returns a parsed response.
// POST /v2/Services
func (c *Client) CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceResponse, error) {
	req, err := newCreateServiceRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ChatV2Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListBinding: GET /v2/Services/{ServiceSid}/Bindings

type ListBindingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Bindings *[]ChatV2ServiceBinding `json:"bindings,omitempty"`
		Meta     *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListBindingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBindingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListBindingRequest generates requests for ListBinding
func newListBindingRequest(baseURL *url.URL, serviceSid string, params *ListBindingParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListBindingFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.BindingType != nil {
		if err := client.AddQueryParam(q, "BindingType", *params.BindingType); err != nil {
			return nil, err
		}
	}

	if params.Identity != nil {
		if err := client.AddQueryParam(q, "Identity", *params.Identity); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListBinding returns a parsed response.
// GET /v2/Services/{ServiceSid}/Bindings
func (c *Client) ListBinding(ctx context.Context, serviceSid string, params *ListBindingParams, reqEditors ...client.RequestEditorFn) (*ListBindingResponse, error) {
	req, err := newListBindingRequest(c.BaseURL, serviceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListBindingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Bindings *[]ChatV2ServiceBinding `json:"bindings,omitempty"`
			Meta     *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteBinding: DELETE /v2/Services/{ServiceSid}/Bindings/{Sid}

type DeleteBindingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteBindingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBindingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteBindingRequest generates requests for DeleteBinding
func newDeleteBindingRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteBindingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteBinding returns a parsed response.
// DELETE /v2/Services/{ServiceSid}/Bindings/{Sid}
func (c *Client) DeleteBinding(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteBindingResponse, error) {
	req, err := newDeleteBindingRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteBindingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchBinding: GET /v2/Services/{ServiceSid}/Bindings/{Sid}

type FetchBindingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2ServiceBinding
}

// Status returns HTTPResponse.Status
func (r FetchBindingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchBindingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchBindingRequest generates requests for FetchBinding
func newFetchBindingRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchBindingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchBinding returns a parsed response.
// GET /v2/Services/{ServiceSid}/Bindings/{Sid}
func (c *Client) FetchBinding(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchBindingResponse, error) {
	req, err := newFetchBindingRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchBindingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2ServiceBinding
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListChannel: GET /v2/Services/{ServiceSid}/Channels

type ListChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Channels *[]ChatV2ServiceChannel `json:"channels,omitempty"`
		Meta     *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListChannelRequest generates requests for ListChannel
func newListChannelRequest(baseURL *url.URL, serviceSid string, params *ListChannelParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListChannelFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Type != nil {
		if err := client.AddQueryParam(q, "Type", *params.Type); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListChannel returns a parsed response.
// GET /v2/Services/{ServiceSid}/Channels
func (c *Client) ListChannel(ctx context.Context, serviceSid string, params *ListChannelParams, reqEditors ...client.RequestEditorFn) (*ListChannelResponse, error) {
	req, err := newListChannelRequest(c.BaseURL, serviceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Channels *[]ChatV2ServiceChannel `json:"channels,omitempty"`
			Meta     *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateChannel: POST /v2/Services/{ServiceSid}/Channels

type CreateChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ChatV2ServiceChannel
}

// Status returns HTTPResponse.Status
func (r CreateChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateChannelRequestWithBody generates requests for CreateChannel with any type of body
func newCreateChannelRequestWithBody(baseURL *url.URL, serviceSid string, params *CreateChannelParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateChannelFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// CreateChannelWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Channels
func (c *Client) CreateChannelWithBody(ctx context.Context, serviceSid string, params *CreateChannelParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateChannelResponse, error) {
	req, err := newCreateChannelRequestWithBody(c.BaseURL, serviceSid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ChatV2ServiceChannel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListInvite: GET /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Invites

type ListInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Invites *[]ChatV2ServiceChannelInvite `json:"invites,omitempty"`
		Meta    *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListInviteRequest generates requests for ListInvite
func newListInviteRequest(baseURL *url.URL, serviceSid string, channelSid string, params *ListInviteParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListInviteFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Identity != nil {
		if err := client.AddQueryParam(q, "Identity", *params.Identity); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListInvite returns a parsed response.
// GET /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Invites
func (c *Client) ListInvite(ctx context.Context, serviceSid string, channelSid string, params *ListInviteParams, reqEditors ...client.RequestEditorFn) (*ListInviteResponse, error) {
	req, err := newListInviteRequest(c.BaseURL, serviceSid, channelSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Invites *[]ChatV2ServiceChannelInvite `json:"invites,omitempty"`
			Meta    *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateInvite: POST /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Invites

type CreateInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ChatV2ServiceChannelInvite
}

// Status returns HTTPResponse.Status
func (r CreateInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateInviteRequestWithBody generates requests for CreateInvite with any type of body
func newCreateInviteRequestWithBody(baseURL *url.URL, serviceSid string, channelSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateInviteFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateInviteWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Invites
func (c *Client) CreateInviteWithBody(ctx context.Context, serviceSid string, channelSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateInviteResponse, error) {
	req, err := newCreateInviteRequestWithBody(c.BaseURL, serviceSid, channelSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ChatV2ServiceChannelInvite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteInvite: DELETE /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Invites/{Sid}

type DeleteInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteInviteRequest generates requests for DeleteInvite
func newDeleteInviteRequest(baseURL *url.URL, serviceSid string, channelSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteInviteFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteInvite returns a parsed response.
// DELETE /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Invites/{Sid}
func (c *Client) DeleteInvite(ctx context.Context, serviceSid string, channelSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteInviteResponse, error) {
	req, err := newDeleteInviteRequest(c.BaseURL, serviceSid, channelSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchInvite: GET /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Invites/{Sid}

type FetchInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2ServiceChannelInvite
}

// Status returns HTTPResponse.Status
func (r FetchInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchInviteRequest generates requests for FetchInvite
func newFetchInviteRequest(baseURL *url.URL, serviceSid string, channelSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchInviteFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchInvite returns a parsed response.
// GET /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Invites/{Sid}
func (c *Client) FetchInvite(ctx context.Context, serviceSid string, channelSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchInviteResponse, error) {
	req, err := newFetchInviteRequest(c.BaseURL, serviceSid, channelSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2ServiceChannelInvite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListMember: GET /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members

type ListMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Members *[]ChatV2ServiceChannelMember `json:"members,omitempty"`
		Meta    *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListMemberRequest generates requests for ListMember
func newListMemberRequest(baseURL *url.URL, serviceSid string, channelSid string, params *ListMemberParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListMemberFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Identity != nil {
		if err := client.AddQueryParam(q, "Identity", *params.Identity); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListMember returns a parsed response.
// GET /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members
func (c *Client) ListMember(ctx context.Context, serviceSid string, channelSid string, params *ListMemberParams, reqEditors ...client.RequestEditorFn) (*ListMemberResponse, error) {
	req, err := newListMemberRequest(c.BaseURL, serviceSid, channelSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Members *[]ChatV2ServiceChannelMember `json:"members,omitempty"`
			Meta    *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateMember: POST /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members

type CreateMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ChatV2ServiceChannelMember
}

// Status returns HTTPResponse.Status
func (r CreateMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateMemberRequestWithBody generates requests for CreateMember with any type of body
func newCreateMemberRequestWithBody(baseURL *url.URL, serviceSid string, channelSid string, params *CreateMemberParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateMemberFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// CreateMemberWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members
func (c *Client) CreateMemberWithBody(ctx context.Context, serviceSid string, channelSid string, params *CreateMemberParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateMemberResponse, error) {
	req, err := newCreateMemberRequestWithBody(c.BaseURL, serviceSid, channelSid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ChatV2ServiceChannelMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteMember: DELETE /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}

type DeleteMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteMemberRequest generates requests for DeleteMember
func newDeleteMemberRequest(baseURL *url.URL, serviceSid string, channelSid string, sid string, params *DeleteMemberParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteMemberFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// DeleteMember returns a parsed response.
// DELETE /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}
func (c *Client) DeleteMember(ctx context.Context, serviceSid string, channelSid string, sid string, params *DeleteMemberParams, reqEditors ...client.RequestEditorFn) (*DeleteMemberResponse, error) {
	req, err := newDeleteMemberRequest(c.BaseURL, serviceSid, channelSid, sid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchMember: GET /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}

type FetchMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2ServiceChannelMember
}

// Status returns HTTPResponse.Status
func (r FetchMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchMemberRequest generates requests for FetchMember
func newFetchMemberRequest(baseURL *url.URL, serviceSid string, channelSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchMemberFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchMember returns a parsed response.
// GET /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}
func (c *Client) FetchMember(ctx context.Context, serviceSid string, channelSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchMemberResponse, error) {
	req, err := newFetchMemberRequest(c.BaseURL, serviceSid, channelSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2ServiceChannelMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateMember: POST /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}

type UpdateMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2ServiceChannelMember
}

// Status returns HTTPResponse.Status
func (r UpdateMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateMemberRequestWithBody generates requests for UpdateMember with any type of body
func newUpdateMemberRequestWithBody(baseURL *url.URL, serviceSid string, channelSid string, sid string, params *UpdateMemberParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateMemberFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// UpdateMemberWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Members/{Sid}
func (c *Client) UpdateMemberWithBody(ctx context.Context, serviceSid string, channelSid string, sid string, params *UpdateMemberParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateMemberResponse, error) {
	req, err := newUpdateMemberRequestWithBody(c.BaseURL, serviceSid, channelSid, sid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2ServiceChannelMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListMessage: GET /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages

type ListMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Messages *[]ChatV2ServiceChannelMessage `json:"messages,omitempty"`
		Meta     *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListMessageRequest generates requests for ListMessage
func newListMessageRequest(baseURL *url.URL, serviceSid string, channelSid string, params *ListMessageParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListMessageFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Order != nil {
		if err := client.AddQueryParam(q, "Order", *params.Order); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListMessage returns a parsed response.
// GET /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages
func (c *Client) ListMessage(ctx context.Context, serviceSid string, channelSid string, params *ListMessageParams, reqEditors ...client.RequestEditorFn) (*ListMessageResponse, error) {
	req, err := newListMessageRequest(c.BaseURL, serviceSid, channelSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Messages *[]ChatV2ServiceChannelMessage `json:"messages,omitempty"`
			Meta     *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateMessage: POST /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages

type CreateMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ChatV2ServiceChannelMessage
}

// Status returns HTTPResponse.Status
func (r CreateMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateMessageRequestWithBody generates requests for CreateMessage with any type of body
func newCreateMessageRequestWithBody(baseURL *url.URL, serviceSid string, channelSid string, params *CreateMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateMessageFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// CreateMessageWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages
func (c *Client) CreateMessageWithBody(ctx context.Context, serviceSid string, channelSid string, params *CreateMessageParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateMessageResponse, error) {
	req, err := newCreateMessageRequestWithBody(c.BaseURL, serviceSid, channelSid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ChatV2ServiceChannelMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteMessage: DELETE /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}

type DeleteMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteMessageRequest generates requests for DeleteMessage
func newDeleteMessageRequest(baseURL *url.URL, serviceSid string, channelSid string, sid string, params *DeleteMessageParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteMessageFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// DeleteMessage returns a parsed response.
// DELETE /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}
func (c *Client) DeleteMessage(ctx context.Context, serviceSid string, channelSid string, sid string, params *DeleteMessageParams, reqEditors ...client.RequestEditorFn) (*DeleteMessageResponse, error) {
	req, err := newDeleteMessageRequest(c.BaseURL, serviceSid, channelSid, sid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchMessage: GET /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}

type FetchMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2ServiceChannelMessage
}

// Status returns HTTPResponse.Status
func (r FetchMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchMessageRequest generates requests for FetchMessage
func newFetchMessageRequest(baseURL *url.URL, serviceSid string, channelSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchMessageFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchMessage returns a parsed response.
// GET /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}
func (c *Client) FetchMessage(ctx context.Context, serviceSid string, channelSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchMessageResponse, error) {
	req, err := newFetchMessageRequest(c.BaseURL, serviceSid, channelSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2ServiceChannelMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateMessage: POST /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}

type UpdateMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2ServiceChannelMessage
}

// Status returns HTTPResponse.Status
func (r UpdateMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateMessageRequestWithBody generates requests for UpdateMessage with any type of body
func newUpdateMessageRequestWithBody(baseURL *url.URL, serviceSid string, channelSid string, sid string, params *UpdateMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateMessageFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// UpdateMessageWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Messages/{Sid}
func (c *Client) UpdateMessageWithBody(ctx context.Context, serviceSid string, channelSid string, sid string, params *UpdateMessageParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateMessageResponse, error) {
	req, err := newUpdateMessageRequestWithBody(c.BaseURL, serviceSid, channelSid, sid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2ServiceChannelMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListChannelWebhook: GET /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks

type ListChannelWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Webhooks *[]ChatV2ServiceChannelChannelWebhook `json:"webhooks,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListChannelWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListChannelWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListChannelWebhookRequest generates requests for ListChannelWebhook
func newListChannelWebhookRequest(baseURL *url.URL, serviceSid string, channelSid string, params *ListChannelWebhookParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListChannelWebhookFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListChannelWebhook returns a parsed response.
// GET /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks
func (c *Client) ListChannelWebhook(ctx context.Context, serviceSid string, channelSid string, params *ListChannelWebhookParams, reqEditors ...client.RequestEditorFn) (*ListChannelWebhookResponse, error) {
	req, err := newListChannelWebhookRequest(c.BaseURL, serviceSid, channelSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListChannelWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Webhooks *[]ChatV2ServiceChannelChannelWebhook `json:"webhooks,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateChannelWebhook: POST /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks

type CreateChannelWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ChatV2ServiceChannelChannelWebhook
}

// Status returns HTTPResponse.Status
func (r CreateChannelWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateChannelWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateChannelWebhookRequestWithBody generates requests for CreateChannelWebhook with any type of body
func newCreateChannelWebhookRequestWithBody(baseURL *url.URL, serviceSid string, channelSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateChannelWebhookFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateChannelWebhookWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks
func (c *Client) CreateChannelWebhookWithBody(ctx context.Context, serviceSid string, channelSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateChannelWebhookResponse, error) {
	req, err := newCreateChannelWebhookRequestWithBody(c.BaseURL, serviceSid, channelSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateChannelWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ChatV2ServiceChannelChannelWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteChannelWebhook: DELETE /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks/{Sid}

type DeleteChannelWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteChannelWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteChannelWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteChannelWebhookRequest generates requests for DeleteChannelWebhook
func newDeleteChannelWebhookRequest(baseURL *url.URL, serviceSid string, channelSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteChannelWebhookFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteChannelWebhook returns a parsed response.
// DELETE /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks/{Sid}
func (c *Client) DeleteChannelWebhook(ctx context.Context, serviceSid string, channelSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteChannelWebhookResponse, error) {
	req, err := newDeleteChannelWebhookRequest(c.BaseURL, serviceSid, channelSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteChannelWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchChannelWebhook: GET /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks/{Sid}

type FetchChannelWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2ServiceChannelChannelWebhook
}

// Status returns HTTPResponse.Status
func (r FetchChannelWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchChannelWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchChannelWebhookRequest generates requests for FetchChannelWebhook
func newFetchChannelWebhookRequest(baseURL *url.URL, serviceSid string, channelSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchChannelWebhookFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchChannelWebhook returns a parsed response.
// GET /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks/{Sid}
func (c *Client) FetchChannelWebhook(ctx context.Context, serviceSid string, channelSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchChannelWebhookResponse, error) {
	req, err := newFetchChannelWebhookRequest(c.BaseURL, serviceSid, channelSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchChannelWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2ServiceChannelChannelWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateChannelWebhook: POST /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks/{Sid}

type UpdateChannelWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2ServiceChannelChannelWebhook
}

// Status returns HTTPResponse.Status
func (r UpdateChannelWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChannelWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateChannelWebhookRequestWithBody generates requests for UpdateChannelWebhook with any type of body
func newUpdateChannelWebhookRequestWithBody(baseURL *url.URL, serviceSid string, channelSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateChannelWebhookFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateChannelWebhookWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Channels/{ChannelSid}/Webhooks/{Sid}
func (c *Client) UpdateChannelWebhookWithBody(ctx context.Context, serviceSid string, channelSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateChannelWebhookResponse, error) {
	req, err := newUpdateChannelWebhookRequestWithBody(c.BaseURL, serviceSid, channelSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateChannelWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2ServiceChannelChannelWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteChannel: DELETE /v2/Services/{ServiceSid}/Channels/{Sid}

type DeleteChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteChannelRequest generates requests for DeleteChannel
func newDeleteChannelRequest(baseURL *url.URL, serviceSid string, sid string, params *DeleteChannelParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteChannelFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// DeleteChannel returns a parsed response.
// DELETE /v2/Services/{ServiceSid}/Channels/{Sid}
func (c *Client) DeleteChannel(ctx context.Context, serviceSid string, sid string, params *DeleteChannelParams, reqEditors ...client.RequestEditorFn) (*DeleteChannelResponse, error) {
	req, err := newDeleteChannelRequest(c.BaseURL, serviceSid, sid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchChannel: GET /v2/Services/{ServiceSid}/Channels/{Sid}

type FetchChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2ServiceChannel
}

// Status returns HTTPResponse.Status
func (r FetchChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchChannelRequest generates requests for FetchChannel
func newFetchChannelRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchChannelFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchChannel returns a parsed response.
// GET /v2/Services/{ServiceSid}/Channels/{Sid}
func (c *Client) FetchChannel(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchChannelResponse, error) {
	req, err := newFetchChannelRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2ServiceChannel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateChannel: POST /v2/Services/{ServiceSid}/Channels/{Sid}

type UpdateChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2ServiceChannel
}

// Status returns HTTPResponse.Status
func (r UpdateChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateChannelRequestWithBody generates requests for UpdateChannel with any type of body
func newUpdateChannelRequestWithBody(baseURL *url.URL, serviceSid string, sid string, params *UpdateChannelParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateChannelFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// UpdateChannelWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Channels/{Sid}
func (c *Client) UpdateChannelWithBody(ctx context.Context, serviceSid string, sid string, params *UpdateChannelParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateChannelResponse, error) {
	req, err := newUpdateChannelRequestWithBody(c.BaseURL, serviceSid, sid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2ServiceChannel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListRole: GET /v2/Services/{ServiceSid}/Roles

type ListRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Roles *[]ChatV2ServiceRole `json:"roles,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListRoleRequest generates requests for ListRole
func newListRoleRequest(baseURL *url.URL, serviceSid string, params *ListRoleParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListRoleFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListRole returns a parsed response.
// GET /v2/Services/{ServiceSid}/Roles
func (c *Client) ListRole(ctx context.Context, serviceSid string, params *ListRoleParams, reqEditors ...client.RequestEditorFn) (*ListRoleResponse, error) {
	req, err := newListRoleRequest(c.BaseURL, serviceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Roles *[]ChatV2ServiceRole `json:"roles,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateRole: POST /v2/Services/{ServiceSid}/Roles

type CreateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ChatV2ServiceRole
}

// Status returns HTTPResponse.Status
func (r CreateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateRoleRequestWithBody generates requests for CreateRole with any type of body
func newCreateRoleRequestWithBody(baseURL *url.URL, serviceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateRoleFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateRoleWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Roles
func (c *Client) CreateRoleWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateRoleResponse, error) {
	req, err := newCreateRoleRequestWithBody(c.BaseURL, serviceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ChatV2ServiceRole
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteRole: DELETE /v2/Services/{ServiceSid}/Roles/{Sid}

type DeleteRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteRoleRequest generates requests for DeleteRole
func newDeleteRoleRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteRoleFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteRole returns a parsed response.
// DELETE /v2/Services/{ServiceSid}/Roles/{Sid}
func (c *Client) DeleteRole(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteRoleResponse, error) {
	req, err := newDeleteRoleRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchRole: GET /v2/Services/{ServiceSid}/Roles/{Sid}

type FetchRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2ServiceRole
}

// Status returns HTTPResponse.Status
func (r FetchRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchRoleRequest generates requests for FetchRole
func newFetchRoleRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchRoleFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchRole returns a parsed response.
// GET /v2/Services/{ServiceSid}/Roles/{Sid}
func (c *Client) FetchRole(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchRoleResponse, error) {
	req, err := newFetchRoleRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2ServiceRole
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateRole: POST /v2/Services/{ServiceSid}/Roles/{Sid}

type UpdateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2ServiceRole
}

// Status returns HTTPResponse.Status
func (r UpdateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateRoleRequestWithBody generates requests for UpdateRole with any type of body
func newUpdateRoleRequestWithBody(baseURL *url.URL, serviceSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateRoleFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateRoleWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Roles/{Sid}
func (c *Client) UpdateRoleWithBody(ctx context.Context, serviceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateRoleResponse, error) {
	req, err := newUpdateRoleRequestWithBody(c.BaseURL, serviceSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2ServiceRole
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListUser: GET /v2/Services/{ServiceSid}/Users

type ListUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Users *[]ChatV2ServiceUser `json:"users,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListUserRequest generates requests for ListUser
func newListUserRequest(baseURL *url.URL, serviceSid string, params *ListUserParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListUserFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListUser returns a parsed response.
// GET /v2/Services/{ServiceSid}/Users
func (c *Client) ListUser(ctx context.Context, serviceSid string, params *ListUserParams, reqEditors ...client.RequestEditorFn) (*ListUserResponse, error) {
	req, err := newListUserRequest(c.BaseURL, serviceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Users *[]ChatV2ServiceUser `json:"users,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateUser: POST /v2/Services/{ServiceSid}/Users

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ChatV2ServiceUser
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateUserRequestWithBody generates requests for CreateUser with any type of body
func newCreateUserRequestWithBody(baseURL *url.URL, serviceSid string, params *CreateUserParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateUserFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// CreateUserWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Users
func (c *Client) CreateUserWithBody(ctx context.Context, serviceSid string, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateUserResponse, error) {
	req, err := newCreateUserRequestWithBody(c.BaseURL, serviceSid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ChatV2ServiceUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteUser: DELETE /v2/Services/{ServiceSid}/Users/{Sid}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteUserRequest generates requests for DeleteUser
func newDeleteUserRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteUserFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteUser returns a parsed response.
// DELETE /v2/Services/{ServiceSid}/Users/{Sid}
func (c *Client) DeleteUser(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteUserResponse, error) {
	req, err := newDeleteUserRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchUser: GET /v2/Services/{ServiceSid}/Users/{Sid}

type FetchUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2ServiceUser
}

// Status returns HTTPResponse.Status
func (r FetchUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchUserRequest generates requests for FetchUser
func newFetchUserRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchUserFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchUser returns a parsed response.
// GET /v2/Services/{ServiceSid}/Users/{Sid}
func (c *Client) FetchUser(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchUserResponse, error) {
	req, err := newFetchUserRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2ServiceUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateUser: POST /v2/Services/{ServiceSid}/Users/{Sid}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2ServiceUser
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func newUpdateUserRequestWithBody(baseURL *url.URL, serviceSid string, sid string, params *UpdateUserParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateUserFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// UpdateUserWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Users/{Sid}
func (c *Client) UpdateUserWithBody(ctx context.Context, serviceSid string, sid string, params *UpdateUserParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateUserResponse, error) {
	req, err := newUpdateUserRequestWithBody(c.BaseURL, serviceSid, sid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2ServiceUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListUserBinding: GET /v2/Services/{ServiceSid}/Users/{UserSid}/Bindings

type ListUserBindingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Bindings *[]ChatV2ServiceUserUserBinding `json:"bindings,omitempty"`
		Meta     *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUserBindingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserBindingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListUserBindingRequest generates requests for ListUserBinding
func newListUserBindingRequest(baseURL *url.URL, serviceSid string, userSid string, params *ListUserBindingParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("UserSid", userSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListUserBindingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.BindingType != nil {
		if err := client.AddQueryParam(q, "BindingType", *params.BindingType); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListUserBinding returns a parsed response.
// GET /v2/Services/{ServiceSid}/Users/{UserSid}/Bindings
func (c *Client) ListUserBinding(ctx context.Context, serviceSid string, userSid string, params *ListUserBindingParams, reqEditors ...client.RequestEditorFn) (*ListUserBindingResponse, error) {
	req, err := newListUserBindingRequest(c.BaseURL, serviceSid, userSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListUserBindingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Bindings *[]ChatV2ServiceUserUserBinding `json:"bindings,omitempty"`
			Meta     *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteUserBinding: DELETE /v2/Services/{ServiceSid}/Users/{UserSid}/Bindings/{Sid}

type DeleteUserBindingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteUserBindingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserBindingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteUserBindingRequest generates requests for DeleteUserBinding
func newDeleteUserBindingRequest(baseURL *url.URL, serviceSid string, userSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("UserSid", userSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteUserBindingFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteUserBinding returns a parsed response.
// DELETE /v2/Services/{ServiceSid}/Users/{UserSid}/Bindings/{Sid}
func (c *Client) DeleteUserBinding(ctx context.Context, serviceSid string, userSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteUserBindingResponse, error) {
	req, err := newDeleteUserBindingRequest(c.BaseURL, serviceSid, userSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteUserBindingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchUserBinding: GET /v2/Services/{ServiceSid}/Users/{UserSid}/Bindings/{Sid}

type FetchUserBindingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2ServiceUserUserBinding
}

// Status returns HTTPResponse.Status
func (r FetchUserBindingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchUserBindingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchUserBindingRequest generates requests for FetchUserBinding
func newFetchUserBindingRequest(baseURL *url.URL, serviceSid string, userSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("UserSid", userSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchUserBindingFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchUserBinding returns a parsed response.
// GET /v2/Services/{ServiceSid}/Users/{UserSid}/Bindings/{Sid}
func (c *Client) FetchUserBinding(ctx context.Context, serviceSid string, userSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchUserBindingResponse, error) {
	req, err := newFetchUserBindingRequest(c.BaseURL, serviceSid, userSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchUserBindingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2ServiceUserUserBinding
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListUserChannel: GET /v2/Services/{ServiceSid}/Users/{UserSid}/Channels

type ListUserChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Channels *[]ChatV2ServiceUserUserChannel `json:"channels,omitempty"`
		Meta     *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUserChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListUserChannelRequest generates requests for ListUserChannel
func newListUserChannelRequest(baseURL *url.URL, serviceSid string, userSid string, params *ListUserChannelParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("UserSid", userSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListUserChannelFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListUserChannel returns a parsed response.
// GET /v2/Services/{ServiceSid}/Users/{UserSid}/Channels
func (c *Client) ListUserChannel(ctx context.Context, serviceSid string, userSid string, params *ListUserChannelParams, reqEditors ...client.RequestEditorFn) (*ListUserChannelResponse, error) {
	req, err := newListUserChannelRequest(c.BaseURL, serviceSid, userSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListUserChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Channels *[]ChatV2ServiceUserUserChannel `json:"channels,omitempty"`
			Meta     *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteUserChannel: DELETE /v2/Services/{ServiceSid}/Users/{UserSid}/Channels/{ChannelSid}

type DeleteUserChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteUserChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteUserChannelRequest generates requests for DeleteUserChannel
func newDeleteUserChannelRequest(baseURL *url.URL, serviceSid string, userSid string, channelSid string, params *DeleteUserChannelParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("UserSid", userSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteUserChannelFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// DeleteUserChannel returns a parsed response.
// DELETE /v2/Services/{ServiceSid}/Users/{UserSid}/Channels/{ChannelSid}
func (c *Client) DeleteUserChannel(ctx context.Context, serviceSid string, userSid string, channelSid string, params *DeleteUserChannelParams, reqEditors ...client.RequestEditorFn) (*DeleteUserChannelResponse, error) {
	req, err := newDeleteUserChannelRequest(c.BaseURL, serviceSid, userSid, channelSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteUserChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchUserChannel: GET /v2/Services/{ServiceSid}/Users/{UserSid}/Channels/{ChannelSid}

type FetchUserChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2ServiceUserUserChannel
}

// Status returns HTTPResponse.Status
func (r FetchUserChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchUserChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchUserChannelRequest generates requests for FetchUserChannel
func newFetchUserChannelRequest(baseURL *url.URL, serviceSid string, userSid string, channelSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("UserSid", userSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchUserChannelFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchUserChannel returns a parsed response.
// GET /v2/Services/{ServiceSid}/Users/{UserSid}/Channels/{ChannelSid}
func (c *Client) FetchUserChannel(ctx context.Context, serviceSid string, userSid string, channelSid string, reqEditors ...client.RequestEditorFn) (*FetchUserChannelResponse, error) {
	req, err := newFetchUserChannelRequest(c.BaseURL, serviceSid, userSid, channelSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchUserChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2ServiceUserUserChannel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateUserChannel: POST /v2/Services/{ServiceSid}/Users/{UserSid}/Channels/{ChannelSid}

type UpdateUserChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2ServiceUserUserChannel
}

// Status returns HTTPResponse.Status
func (r UpdateUserChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateUserChannelRequestWithBody generates requests for UpdateUserChannel with any type of body
func newUpdateUserChannelRequestWithBody(baseURL *url.URL, serviceSid string, userSid string, channelSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("UserSid", userSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("ChannelSid", channelSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateUserChannelFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateUserChannelWithBody returns a parsed response.
// POST /v2/Services/{ServiceSid}/Users/{UserSid}/Channels/{ChannelSid}
func (c *Client) UpdateUserChannelWithBody(ctx context.Context, serviceSid string, userSid string, channelSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateUserChannelResponse, error) {
	req, err := newUpdateUserChannelRequestWithBody(c.BaseURL, serviceSid, userSid, channelSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateUserChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2ServiceUserUserChannel
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteService: DELETE /v2/Services/{Sid}

type DeleteServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteServiceRequest generates requests for DeleteService
func newDeleteServiceRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteServiceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteService returns a parsed response.
// DELETE /v2/Services/{Sid}
func (c *Client) DeleteService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteServiceResponse, error) {
	req, err := newDeleteServiceRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchService: GET /v2/Services/{Sid}

type FetchServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2Service
}

// Status returns HTTPResponse.Status
func (r FetchServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchServiceRequest generates requests for FetchService
func newFetchServiceRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchServiceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchService returns a parsed response.
// GET /v2/Services/{Sid}
func (c *Client) FetchService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceResponse, error) {
	req, err := newFetchServiceRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateService: POST /v2/Services/{Sid}

type UpdateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChatV2Service
}

// Status returns HTTPResponse.Status
func (r UpdateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateServiceRequestWithBody generates requests for UpdateService with any type of body
func newUpdateServiceRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateServiceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateServiceWithBody returns a parsed response.
// POST /v2/Services/{Sid}
func (c *Client) UpdateServiceWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceResponse, error) {
	req, err := newUpdateServiceRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChatV2Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
