// Package numbers provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package numbers

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/faetools/client"
)

// operation paths

const (
	opPathListBundleCopyFormat              = "./v2/RegulatoryCompliance/Bundles/%s/Copies"
	opPathCreateBundleCopyFormat            = "./v2/RegulatoryCompliance/Bundles/%s/Copies"
	opPathListEvaluationFormat              = "./v2/RegulatoryCompliance/Bundles/%s/Evaluations"
	opPathCreateEvaluationFormat            = "./v2/RegulatoryCompliance/Bundles/%s/Evaluations"
	opPathFetchEvaluationFormat             = "./v2/RegulatoryCompliance/Bundles/%s/Evaluations/%s"
	opPathListItemAssignmentFormat          = "./v2/RegulatoryCompliance/Bundles/%s/ItemAssignments"
	opPathCreateItemAssignmentFormat        = "./v2/RegulatoryCompliance/Bundles/%s/ItemAssignments"
	opPathDeleteItemAssignmentFormat        = "./v2/RegulatoryCompliance/Bundles/%s/ItemAssignments/%s"
	opPathFetchItemAssignmentFormat         = "./v2/RegulatoryCompliance/Bundles/%s/ItemAssignments/%s"
	opPathCreateReplaceItemsFormat          = "./v2/RegulatoryCompliance/Bundles/%s/ReplaceItems"
	opPathDeleteBundleFormat                = "./v2/RegulatoryCompliance/Bundles/%s"
	opPathFetchBundleFormat                 = "./v2/RegulatoryCompliance/Bundles/%s"
	opPathUpdateBundleFormat                = "./v2/RegulatoryCompliance/Bundles/%s"
	opPathFetchEndUserTypeFormat            = "./v2/RegulatoryCompliance/EndUserTypes/%s"
	opPathDeleteEndUserFormat               = "./v2/RegulatoryCompliance/EndUsers/%s"
	opPathFetchEndUserFormat                = "./v2/RegulatoryCompliance/EndUsers/%s"
	opPathUpdateEndUserFormat               = "./v2/RegulatoryCompliance/EndUsers/%s"
	opPathFetchRegulationFormat             = "./v2/RegulatoryCompliance/Regulations/%s"
	opPathFetchSupportingDocumentTypeFormat = "./v2/RegulatoryCompliance/SupportingDocumentTypes/%s"
	opPathDeleteSupportingDocumentFormat    = "./v2/RegulatoryCompliance/SupportingDocuments/%s"
	opPathFetchSupportingDocumentFormat     = "./v2/RegulatoryCompliance/SupportingDocuments/%s"
	opPathUpdateSupportingDocumentFormat    = "./v2/RegulatoryCompliance/SupportingDocuments/%s"
)

var (
	opPathListBundle                 = client.MustParseURL("./v2/RegulatoryCompliance/Bundles")
	opPathCreateBundle               = client.MustParseURL("./v2/RegulatoryCompliance/Bundles")
	opPathListEndUserType            = client.MustParseURL("./v2/RegulatoryCompliance/EndUserTypes")
	opPathListEndUser                = client.MustParseURL("./v2/RegulatoryCompliance/EndUsers")
	opPathCreateEndUser              = client.MustParseURL("./v2/RegulatoryCompliance/EndUsers")
	opPathListRegulation             = client.MustParseURL("./v2/RegulatoryCompliance/Regulations")
	opPathListSupportingDocumentType = client.MustParseURL("./v2/RegulatoryCompliance/SupportingDocumentTypes")
	opPathListSupportingDocument     = client.MustParseURL("./v2/RegulatoryCompliance/SupportingDocuments")
	opPathCreateSupportingDocument   = client.MustParseURL("./v2/RegulatoryCompliance/SupportingDocuments")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// ListBundle request
	ListBundle(ctx context.Context, params *ListBundleParams, reqEditors ...client.RequestEditorFn) (*ListBundleResponse, error)

	// CreateBundle request with any body
	CreateBundleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateBundleResponse, error)

	// ListBundleCopy request
	ListBundleCopy(ctx context.Context, bundleSid string, params *ListBundleCopyParams, reqEditors ...client.RequestEditorFn) (*ListBundleCopyResponse, error)

	// CreateBundleCopy request with any body
	CreateBundleCopyWithBody(ctx context.Context, bundleSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateBundleCopyResponse, error)

	// ListEvaluation request
	ListEvaluation(ctx context.Context, bundleSid string, params *ListEvaluationParams, reqEditors ...client.RequestEditorFn) (*ListEvaluationResponse, error)

	// CreateEvaluation request
	CreateEvaluation(ctx context.Context, bundleSid string, reqEditors ...client.RequestEditorFn) (*CreateEvaluationResponse, error)

	// FetchEvaluation request
	FetchEvaluation(ctx context.Context, bundleSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchEvaluationResponse, error)

	// ListItemAssignment request
	ListItemAssignment(ctx context.Context, bundleSid string, params *ListItemAssignmentParams, reqEditors ...client.RequestEditorFn) (*ListItemAssignmentResponse, error)

	// CreateItemAssignment request with any body
	CreateItemAssignmentWithBody(ctx context.Context, bundleSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateItemAssignmentResponse, error)

	// DeleteItemAssignment request
	DeleteItemAssignment(ctx context.Context, bundleSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteItemAssignmentResponse, error)

	// FetchItemAssignment request
	FetchItemAssignment(ctx context.Context, bundleSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchItemAssignmentResponse, error)

	// CreateReplaceItems request with any body
	CreateReplaceItemsWithBody(ctx context.Context, bundleSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateReplaceItemsResponse, error)

	// DeleteBundle request
	DeleteBundle(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteBundleResponse, error)

	// FetchBundle request
	FetchBundle(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchBundleResponse, error)

	// UpdateBundle request with any body
	UpdateBundleWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateBundleResponse, error)

	// ListEndUserType request
	ListEndUserType(ctx context.Context, params *ListEndUserTypeParams, reqEditors ...client.RequestEditorFn) (*ListEndUserTypeResponse, error)

	// FetchEndUserType request
	FetchEndUserType(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchEndUserTypeResponse, error)

	// ListEndUser request
	ListEndUser(ctx context.Context, params *ListEndUserParams, reqEditors ...client.RequestEditorFn) (*ListEndUserResponse, error)

	// CreateEndUser request with any body
	CreateEndUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateEndUserResponse, error)

	// DeleteEndUser request
	DeleteEndUser(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteEndUserResponse, error)

	// FetchEndUser request
	FetchEndUser(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchEndUserResponse, error)

	// UpdateEndUser request with any body
	UpdateEndUserWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateEndUserResponse, error)

	// ListRegulation request
	ListRegulation(ctx context.Context, params *ListRegulationParams, reqEditors ...client.RequestEditorFn) (*ListRegulationResponse, error)

	// FetchRegulation request
	FetchRegulation(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchRegulationResponse, error)

	// ListSupportingDocumentType request
	ListSupportingDocumentType(ctx context.Context, params *ListSupportingDocumentTypeParams, reqEditors ...client.RequestEditorFn) (*ListSupportingDocumentTypeResponse, error)

	// FetchSupportingDocumentType request
	FetchSupportingDocumentType(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchSupportingDocumentTypeResponse, error)

	// ListSupportingDocument request
	ListSupportingDocument(ctx context.Context, params *ListSupportingDocumentParams, reqEditors ...client.RequestEditorFn) (*ListSupportingDocumentResponse, error)

	// CreateSupportingDocument request with any body
	CreateSupportingDocumentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSupportingDocumentResponse, error)

	// DeleteSupportingDocument request
	DeleteSupportingDocument(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSupportingDocumentResponse, error)

	// FetchSupportingDocument request
	FetchSupportingDocument(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchSupportingDocumentResponse, error)

	// UpdateSupportingDocument request with any body
	UpdateSupportingDocumentWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSupportingDocumentResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// ListBundle: GET /v2/RegulatoryCompliance/Bundles

type ListBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Results *[]NumbersV2RegulatoryComplianceBundle `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListBundleRequest generates requests for ListBundle
func newListBundleRequest(baseURL *url.URL, params *ListBundleParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListBundle)

	q := queryURL.Query()

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.RegulationSid != nil {
		if err := client.AddQueryParam(q, "RegulationSid", *params.RegulationSid); err != nil {
			return nil, err
		}
	}

	if params.IsoCountry != nil {
		if err := client.AddQueryParam(q, "IsoCountry", *params.IsoCountry); err != nil {
			return nil, err
		}
	}

	if params.NumberType != nil {
		if err := client.AddQueryParam(q, "NumberType", *params.NumberType); err != nil {
			return nil, err
		}
	}

	if params.HasValidUntilDate != nil {
		if err := client.AddQueryParam(q, "HasValidUntilDate", *params.HasValidUntilDate); err != nil {
			return nil, err
		}
	}

	if params.SortBy != nil {
		if err := client.AddQueryParam(q, "SortBy", *params.SortBy); err != nil {
			return nil, err
		}
	}

	if params.SortDirection != nil {
		if err := client.AddQueryParam(q, "SortDirection", *params.SortDirection); err != nil {
			return nil, err
		}
	}

	if params.ValidUntilDate != nil {
		if err := client.AddQueryParam(q, "ValidUntilDate", *params.ValidUntilDate); err != nil {
			return nil, err
		}
	}

	if params.ValidUntilDate != nil {
		if err := client.AddQueryParam(q, "ValidUntilDate<", *params.ValidUntilDate); err != nil {
			return nil, err
		}
	}

	if params.ValidUntilDate != nil {
		if err := client.AddQueryParam(q, "ValidUntilDate>", *params.ValidUntilDate); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListBundle returns a parsed response.
// GET /v2/RegulatoryCompliance/Bundles
func (c *Client) ListBundle(ctx context.Context, params *ListBundleParams, reqEditors ...client.RequestEditorFn) (*ListBundleResponse, error) {
	req, err := newListBundleRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Results *[]NumbersV2RegulatoryComplianceBundle `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateBundle: POST /v2/RegulatoryCompliance/Bundles

type CreateBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *NumbersV2RegulatoryComplianceBundle
}

// Status returns HTTPResponse.Status
func (r CreateBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateBundleRequestWithBody generates requests for CreateBundle with any type of body
func newCreateBundleRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateBundle)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateBundleWithBody returns a parsed response.
// POST /v2/RegulatoryCompliance/Bundles
func (c *Client) CreateBundleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateBundleResponse, error) {
	req, err := newCreateBundleRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NumbersV2RegulatoryComplianceBundle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListBundleCopy: GET /v2/RegulatoryCompliance/Bundles/{BundleSid}/Copies

type ListBundleCopyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Results *[]NumbersV2RegulatoryComplianceBundleBundleCopy `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListBundleCopyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBundleCopyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListBundleCopyRequest generates requests for ListBundleCopy
func newListBundleCopyRequest(baseURL *url.URL, bundleSid string, params *ListBundleCopyParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("BundleSid", bundleSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListBundleCopyFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListBundleCopy returns a parsed response.
// GET /v2/RegulatoryCompliance/Bundles/{BundleSid}/Copies
func (c *Client) ListBundleCopy(ctx context.Context, bundleSid string, params *ListBundleCopyParams, reqEditors ...client.RequestEditorFn) (*ListBundleCopyResponse, error) {
	req, err := newListBundleCopyRequest(c.BaseURL, bundleSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListBundleCopyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Results *[]NumbersV2RegulatoryComplianceBundleBundleCopy `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateBundleCopy: POST /v2/RegulatoryCompliance/Bundles/{BundleSid}/Copies

type CreateBundleCopyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *NumbersV2RegulatoryComplianceBundleBundleCopy
}

// Status returns HTTPResponse.Status
func (r CreateBundleCopyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBundleCopyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateBundleCopyRequestWithBody generates requests for CreateBundleCopy with any type of body
func newCreateBundleCopyRequestWithBody(baseURL *url.URL, bundleSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("BundleSid", bundleSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateBundleCopyFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateBundleCopyWithBody returns a parsed response.
// POST /v2/RegulatoryCompliance/Bundles/{BundleSid}/Copies
func (c *Client) CreateBundleCopyWithBody(ctx context.Context, bundleSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateBundleCopyResponse, error) {
	req, err := newCreateBundleCopyRequestWithBody(c.BaseURL, bundleSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateBundleCopyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NumbersV2RegulatoryComplianceBundleBundleCopy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListEvaluation: GET /v2/RegulatoryCompliance/Bundles/{BundleSid}/Evaluations

type ListEvaluationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Results *[]NumbersV2RegulatoryComplianceBundleEvaluation `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListEvaluationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEvaluationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListEvaluationRequest generates requests for ListEvaluation
func newListEvaluationRequest(baseURL *url.URL, bundleSid string, params *ListEvaluationParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("BundleSid", bundleSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListEvaluationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListEvaluation returns a parsed response.
// GET /v2/RegulatoryCompliance/Bundles/{BundleSid}/Evaluations
func (c *Client) ListEvaluation(ctx context.Context, bundleSid string, params *ListEvaluationParams, reqEditors ...client.RequestEditorFn) (*ListEvaluationResponse, error) {
	req, err := newListEvaluationRequest(c.BaseURL, bundleSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListEvaluationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Results *[]NumbersV2RegulatoryComplianceBundleEvaluation `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateEvaluation: POST /v2/RegulatoryCompliance/Bundles/{BundleSid}/Evaluations

type CreateEvaluationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *NumbersV2RegulatoryComplianceBundleEvaluation
}

// Status returns HTTPResponse.Status
func (r CreateEvaluationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEvaluationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateEvaluationRequest generates requests for CreateEvaluation
func newCreateEvaluationRequest(baseURL *url.URL, bundleSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("BundleSid", bundleSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateEvaluationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// CreateEvaluation returns a parsed response.
// POST /v2/RegulatoryCompliance/Bundles/{BundleSid}/Evaluations
func (c *Client) CreateEvaluation(ctx context.Context, bundleSid string, reqEditors ...client.RequestEditorFn) (*CreateEvaluationResponse, error) {
	req, err := newCreateEvaluationRequest(c.BaseURL, bundleSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateEvaluationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NumbersV2RegulatoryComplianceBundleEvaluation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// FetchEvaluation: GET /v2/RegulatoryCompliance/Bundles/{BundleSid}/Evaluations/{Sid}

type FetchEvaluationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NumbersV2RegulatoryComplianceBundleEvaluation
}

// Status returns HTTPResponse.Status
func (r FetchEvaluationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchEvaluationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchEvaluationRequest generates requests for FetchEvaluation
func newFetchEvaluationRequest(baseURL *url.URL, bundleSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("BundleSid", bundleSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchEvaluationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchEvaluation returns a parsed response.
// GET /v2/RegulatoryCompliance/Bundles/{BundleSid}/Evaluations/{Sid}
func (c *Client) FetchEvaluation(ctx context.Context, bundleSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchEvaluationResponse, error) {
	req, err := newFetchEvaluationRequest(c.BaseURL, bundleSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchEvaluationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NumbersV2RegulatoryComplianceBundleEvaluation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListItemAssignment: GET /v2/RegulatoryCompliance/Bundles/{BundleSid}/ItemAssignments

type ListItemAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Results *[]NumbersV2RegulatoryComplianceBundleItemAssignment `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListItemAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListItemAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListItemAssignmentRequest generates requests for ListItemAssignment
func newListItemAssignmentRequest(baseURL *url.URL, bundleSid string, params *ListItemAssignmentParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("BundleSid", bundleSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListItemAssignmentFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListItemAssignment returns a parsed response.
// GET /v2/RegulatoryCompliance/Bundles/{BundleSid}/ItemAssignments
func (c *Client) ListItemAssignment(ctx context.Context, bundleSid string, params *ListItemAssignmentParams, reqEditors ...client.RequestEditorFn) (*ListItemAssignmentResponse, error) {
	req, err := newListItemAssignmentRequest(c.BaseURL, bundleSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListItemAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Results *[]NumbersV2RegulatoryComplianceBundleItemAssignment `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateItemAssignment: POST /v2/RegulatoryCompliance/Bundles/{BundleSid}/ItemAssignments

type CreateItemAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *NumbersV2RegulatoryComplianceBundleItemAssignment
}

// Status returns HTTPResponse.Status
func (r CreateItemAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateItemAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateItemAssignmentRequestWithBody generates requests for CreateItemAssignment with any type of body
func newCreateItemAssignmentRequestWithBody(baseURL *url.URL, bundleSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("BundleSid", bundleSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateItemAssignmentFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateItemAssignmentWithBody returns a parsed response.
// POST /v2/RegulatoryCompliance/Bundles/{BundleSid}/ItemAssignments
func (c *Client) CreateItemAssignmentWithBody(ctx context.Context, bundleSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateItemAssignmentResponse, error) {
	req, err := newCreateItemAssignmentRequestWithBody(c.BaseURL, bundleSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateItemAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NumbersV2RegulatoryComplianceBundleItemAssignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteItemAssignment: DELETE /v2/RegulatoryCompliance/Bundles/{BundleSid}/ItemAssignments/{Sid}

type DeleteItemAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteItemAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteItemAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteItemAssignmentRequest generates requests for DeleteItemAssignment
func newDeleteItemAssignmentRequest(baseURL *url.URL, bundleSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("BundleSid", bundleSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteItemAssignmentFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteItemAssignment returns a parsed response.
// DELETE /v2/RegulatoryCompliance/Bundles/{BundleSid}/ItemAssignments/{Sid}
func (c *Client) DeleteItemAssignment(ctx context.Context, bundleSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteItemAssignmentResponse, error) {
	req, err := newDeleteItemAssignmentRequest(c.BaseURL, bundleSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteItemAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchItemAssignment: GET /v2/RegulatoryCompliance/Bundles/{BundleSid}/ItemAssignments/{Sid}

type FetchItemAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NumbersV2RegulatoryComplianceBundleItemAssignment
}

// Status returns HTTPResponse.Status
func (r FetchItemAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchItemAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchItemAssignmentRequest generates requests for FetchItemAssignment
func newFetchItemAssignmentRequest(baseURL *url.URL, bundleSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("BundleSid", bundleSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchItemAssignmentFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchItemAssignment returns a parsed response.
// GET /v2/RegulatoryCompliance/Bundles/{BundleSid}/ItemAssignments/{Sid}
func (c *Client) FetchItemAssignment(ctx context.Context, bundleSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchItemAssignmentResponse, error) {
	req, err := newFetchItemAssignmentRequest(c.BaseURL, bundleSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchItemAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NumbersV2RegulatoryComplianceBundleItemAssignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateReplaceItems: POST /v2/RegulatoryCompliance/Bundles/{BundleSid}/ReplaceItems

type CreateReplaceItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *NumbersV2RegulatoryComplianceBundleReplaceItems
}

// Status returns HTTPResponse.Status
func (r CreateReplaceItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateReplaceItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateReplaceItemsRequestWithBody generates requests for CreateReplaceItems with any type of body
func newCreateReplaceItemsRequestWithBody(baseURL *url.URL, bundleSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("BundleSid", bundleSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateReplaceItemsFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateReplaceItemsWithBody returns a parsed response.
// POST /v2/RegulatoryCompliance/Bundles/{BundleSid}/ReplaceItems
func (c *Client) CreateReplaceItemsWithBody(ctx context.Context, bundleSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateReplaceItemsResponse, error) {
	req, err := newCreateReplaceItemsRequestWithBody(c.BaseURL, bundleSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateReplaceItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NumbersV2RegulatoryComplianceBundleReplaceItems
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteBundle: DELETE /v2/RegulatoryCompliance/Bundles/{Sid}

type DeleteBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteBundleRequest generates requests for DeleteBundle
func newDeleteBundleRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteBundleFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteBundle returns a parsed response.
// DELETE /v2/RegulatoryCompliance/Bundles/{Sid}
func (c *Client) DeleteBundle(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteBundleResponse, error) {
	req, err := newDeleteBundleRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchBundle: GET /v2/RegulatoryCompliance/Bundles/{Sid}

type FetchBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NumbersV2RegulatoryComplianceBundle
}

// Status returns HTTPResponse.Status
func (r FetchBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchBundleRequest generates requests for FetchBundle
func newFetchBundleRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchBundleFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchBundle returns a parsed response.
// GET /v2/RegulatoryCompliance/Bundles/{Sid}
func (c *Client) FetchBundle(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchBundleResponse, error) {
	req, err := newFetchBundleRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NumbersV2RegulatoryComplianceBundle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateBundle: POST /v2/RegulatoryCompliance/Bundles/{Sid}

type UpdateBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NumbersV2RegulatoryComplianceBundle
}

// Status returns HTTPResponse.Status
func (r UpdateBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateBundleRequestWithBody generates requests for UpdateBundle with any type of body
func newUpdateBundleRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateBundleFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateBundleWithBody returns a parsed response.
// POST /v2/RegulatoryCompliance/Bundles/{Sid}
func (c *Client) UpdateBundleWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateBundleResponse, error) {
	req, err := newUpdateBundleRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NumbersV2RegulatoryComplianceBundle
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListEndUserType: GET /v2/RegulatoryCompliance/EndUserTypes

type ListEndUserTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		EndUserTypes *[]NumbersV2RegulatoryComplianceEndUserType `json:"end_user_types,omitempty"`
		Meta         *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListEndUserTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEndUserTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListEndUserTypeRequest generates requests for ListEndUserType
func newListEndUserTypeRequest(baseURL *url.URL, params *ListEndUserTypeParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListEndUserType)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListEndUserType returns a parsed response.
// GET /v2/RegulatoryCompliance/EndUserTypes
func (c *Client) ListEndUserType(ctx context.Context, params *ListEndUserTypeParams, reqEditors ...client.RequestEditorFn) (*ListEndUserTypeResponse, error) {
	req, err := newListEndUserTypeRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListEndUserTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			EndUserTypes *[]NumbersV2RegulatoryComplianceEndUserType `json:"end_user_types,omitempty"`
			Meta         *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchEndUserType: GET /v2/RegulatoryCompliance/EndUserTypes/{Sid}

type FetchEndUserTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NumbersV2RegulatoryComplianceEndUserType
}

// Status returns HTTPResponse.Status
func (r FetchEndUserTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchEndUserTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchEndUserTypeRequest generates requests for FetchEndUserType
func newFetchEndUserTypeRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchEndUserTypeFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchEndUserType returns a parsed response.
// GET /v2/RegulatoryCompliance/EndUserTypes/{Sid}
func (c *Client) FetchEndUserType(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchEndUserTypeResponse, error) {
	req, err := newFetchEndUserTypeRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchEndUserTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NumbersV2RegulatoryComplianceEndUserType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListEndUser: GET /v2/RegulatoryCompliance/EndUsers

type ListEndUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Results *[]NumbersV2RegulatoryComplianceEndUser `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListEndUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEndUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListEndUserRequest generates requests for ListEndUser
func newListEndUserRequest(baseURL *url.URL, params *ListEndUserParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListEndUser)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListEndUser returns a parsed response.
// GET /v2/RegulatoryCompliance/EndUsers
func (c *Client) ListEndUser(ctx context.Context, params *ListEndUserParams, reqEditors ...client.RequestEditorFn) (*ListEndUserResponse, error) {
	req, err := newListEndUserRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListEndUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Results *[]NumbersV2RegulatoryComplianceEndUser `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateEndUser: POST /v2/RegulatoryCompliance/EndUsers

type CreateEndUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *NumbersV2RegulatoryComplianceEndUser
}

// Status returns HTTPResponse.Status
func (r CreateEndUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEndUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateEndUserRequestWithBody generates requests for CreateEndUser with any type of body
func newCreateEndUserRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateEndUser)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateEndUserWithBody returns a parsed response.
// POST /v2/RegulatoryCompliance/EndUsers
func (c *Client) CreateEndUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateEndUserResponse, error) {
	req, err := newCreateEndUserRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateEndUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NumbersV2RegulatoryComplianceEndUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteEndUser: DELETE /v2/RegulatoryCompliance/EndUsers/{Sid}

type DeleteEndUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteEndUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEndUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteEndUserRequest generates requests for DeleteEndUser
func newDeleteEndUserRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteEndUserFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteEndUser returns a parsed response.
// DELETE /v2/RegulatoryCompliance/EndUsers/{Sid}
func (c *Client) DeleteEndUser(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteEndUserResponse, error) {
	req, err := newDeleteEndUserRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteEndUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchEndUser: GET /v2/RegulatoryCompliance/EndUsers/{Sid}

type FetchEndUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NumbersV2RegulatoryComplianceEndUser
}

// Status returns HTTPResponse.Status
func (r FetchEndUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchEndUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchEndUserRequest generates requests for FetchEndUser
func newFetchEndUserRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchEndUserFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchEndUser returns a parsed response.
// GET /v2/RegulatoryCompliance/EndUsers/{Sid}
func (c *Client) FetchEndUser(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchEndUserResponse, error) {
	req, err := newFetchEndUserRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchEndUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NumbersV2RegulatoryComplianceEndUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateEndUser: POST /v2/RegulatoryCompliance/EndUsers/{Sid}

type UpdateEndUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NumbersV2RegulatoryComplianceEndUser
}

// Status returns HTTPResponse.Status
func (r UpdateEndUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEndUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateEndUserRequestWithBody generates requests for UpdateEndUser with any type of body
func newUpdateEndUserRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateEndUserFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateEndUserWithBody returns a parsed response.
// POST /v2/RegulatoryCompliance/EndUsers/{Sid}
func (c *Client) UpdateEndUserWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateEndUserResponse, error) {
	req, err := newUpdateEndUserRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateEndUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NumbersV2RegulatoryComplianceEndUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListRegulation: GET /v2/RegulatoryCompliance/Regulations

type ListRegulationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Results *[]NumbersV2RegulatoryComplianceRegulation `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRegulationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRegulationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListRegulationRequest generates requests for ListRegulation
func newListRegulationRequest(baseURL *url.URL, params *ListRegulationParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListRegulation)

	q := queryURL.Query()

	if params.EndUserType != nil {
		if err := client.AddQueryParam(q, "EndUserType", *params.EndUserType); err != nil {
			return nil, err
		}
	}

	if params.IsoCountry != nil {
		if err := client.AddQueryParam(q, "IsoCountry", *params.IsoCountry); err != nil {
			return nil, err
		}
	}

	if params.NumberType != nil {
		if err := client.AddQueryParam(q, "NumberType", *params.NumberType); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListRegulation returns a parsed response.
// GET /v2/RegulatoryCompliance/Regulations
func (c *Client) ListRegulation(ctx context.Context, params *ListRegulationParams, reqEditors ...client.RequestEditorFn) (*ListRegulationResponse, error) {
	req, err := newListRegulationRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListRegulationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Results *[]NumbersV2RegulatoryComplianceRegulation `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchRegulation: GET /v2/RegulatoryCompliance/Regulations/{Sid}

type FetchRegulationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NumbersV2RegulatoryComplianceRegulation
}

// Status returns HTTPResponse.Status
func (r FetchRegulationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchRegulationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchRegulationRequest generates requests for FetchRegulation
func newFetchRegulationRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchRegulationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchRegulation returns a parsed response.
// GET /v2/RegulatoryCompliance/Regulations/{Sid}
func (c *Client) FetchRegulation(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchRegulationResponse, error) {
	req, err := newFetchRegulationRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchRegulationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NumbersV2RegulatoryComplianceRegulation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSupportingDocumentType: GET /v2/RegulatoryCompliance/SupportingDocumentTypes

type ListSupportingDocumentTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		SupportingDocumentTypes *[]NumbersV2RegulatoryComplianceSupportingDocumentType `json:"supporting_document_types,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSupportingDocumentTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSupportingDocumentTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSupportingDocumentTypeRequest generates requests for ListSupportingDocumentType
func newListSupportingDocumentTypeRequest(baseURL *url.URL, params *ListSupportingDocumentTypeParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListSupportingDocumentType)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSupportingDocumentType returns a parsed response.
// GET /v2/RegulatoryCompliance/SupportingDocumentTypes
func (c *Client) ListSupportingDocumentType(ctx context.Context, params *ListSupportingDocumentTypeParams, reqEditors ...client.RequestEditorFn) (*ListSupportingDocumentTypeResponse, error) {
	req, err := newListSupportingDocumentTypeRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSupportingDocumentTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			SupportingDocumentTypes *[]NumbersV2RegulatoryComplianceSupportingDocumentType `json:"supporting_document_types,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchSupportingDocumentType: GET /v2/RegulatoryCompliance/SupportingDocumentTypes/{Sid}

type FetchSupportingDocumentTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NumbersV2RegulatoryComplianceSupportingDocumentType
}

// Status returns HTTPResponse.Status
func (r FetchSupportingDocumentTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSupportingDocumentTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSupportingDocumentTypeRequest generates requests for FetchSupportingDocumentType
func newFetchSupportingDocumentTypeRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSupportingDocumentTypeFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSupportingDocumentType returns a parsed response.
// GET /v2/RegulatoryCompliance/SupportingDocumentTypes/{Sid}
func (c *Client) FetchSupportingDocumentType(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchSupportingDocumentTypeResponse, error) {
	req, err := newFetchSupportingDocumentTypeRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSupportingDocumentTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NumbersV2RegulatoryComplianceSupportingDocumentType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSupportingDocument: GET /v2/RegulatoryCompliance/SupportingDocuments

type ListSupportingDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Results *[]NumbersV2RegulatoryComplianceSupportingDocument `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSupportingDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSupportingDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSupportingDocumentRequest generates requests for ListSupportingDocument
func newListSupportingDocumentRequest(baseURL *url.URL, params *ListSupportingDocumentParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListSupportingDocument)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSupportingDocument returns a parsed response.
// GET /v2/RegulatoryCompliance/SupportingDocuments
func (c *Client) ListSupportingDocument(ctx context.Context, params *ListSupportingDocumentParams, reqEditors ...client.RequestEditorFn) (*ListSupportingDocumentResponse, error) {
	req, err := newListSupportingDocumentRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSupportingDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Results *[]NumbersV2RegulatoryComplianceSupportingDocument `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSupportingDocument: POST /v2/RegulatoryCompliance/SupportingDocuments

type CreateSupportingDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *NumbersV2RegulatoryComplianceSupportingDocument
}

// Status returns HTTPResponse.Status
func (r CreateSupportingDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSupportingDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSupportingDocumentRequestWithBody generates requests for CreateSupportingDocument with any type of body
func newCreateSupportingDocumentRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateSupportingDocument)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSupportingDocumentWithBody returns a parsed response.
// POST /v2/RegulatoryCompliance/SupportingDocuments
func (c *Client) CreateSupportingDocumentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSupportingDocumentResponse, error) {
	req, err := newCreateSupportingDocumentRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSupportingDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NumbersV2RegulatoryComplianceSupportingDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteSupportingDocument: DELETE /v2/RegulatoryCompliance/SupportingDocuments/{Sid}

type DeleteSupportingDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSupportingDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSupportingDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSupportingDocumentRequest generates requests for DeleteSupportingDocument
func newDeleteSupportingDocumentRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSupportingDocumentFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSupportingDocument returns a parsed response.
// DELETE /v2/RegulatoryCompliance/SupportingDocuments/{Sid}
func (c *Client) DeleteSupportingDocument(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSupportingDocumentResponse, error) {
	req, err := newDeleteSupportingDocumentRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSupportingDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSupportingDocument: GET /v2/RegulatoryCompliance/SupportingDocuments/{Sid}

type FetchSupportingDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NumbersV2RegulatoryComplianceSupportingDocument
}

// Status returns HTTPResponse.Status
func (r FetchSupportingDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSupportingDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSupportingDocumentRequest generates requests for FetchSupportingDocument
func newFetchSupportingDocumentRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSupportingDocumentFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSupportingDocument returns a parsed response.
// GET /v2/RegulatoryCompliance/SupportingDocuments/{Sid}
func (c *Client) FetchSupportingDocument(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchSupportingDocumentResponse, error) {
	req, err := newFetchSupportingDocumentRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSupportingDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NumbersV2RegulatoryComplianceSupportingDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSupportingDocument: POST /v2/RegulatoryCompliance/SupportingDocuments/{Sid}

type UpdateSupportingDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NumbersV2RegulatoryComplianceSupportingDocument
}

// Status returns HTTPResponse.Status
func (r UpdateSupportingDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSupportingDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSupportingDocumentRequestWithBody generates requests for UpdateSupportingDocument with any type of body
func newUpdateSupportingDocumentRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSupportingDocumentFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSupportingDocumentWithBody returns a parsed response.
// POST /v2/RegulatoryCompliance/SupportingDocuments/{Sid}
func (c *Client) UpdateSupportingDocumentWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSupportingDocumentResponse, error) {
	req, err := newUpdateSupportingDocumentRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSupportingDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NumbersV2RegulatoryComplianceSupportingDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
