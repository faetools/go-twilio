// Package conversations provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package conversations

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/faetools/client"
)

// operation paths

const (
	opPathDeleteConfigurationAddressFormat             = "./v1/Configuration/Addresses/%s"
	opPathFetchConfigurationAddressFormat              = "./v1/Configuration/Addresses/%s"
	opPathUpdateConfigurationAddressFormat             = "./v1/Configuration/Addresses/%s"
	opPathListConversationMessageFormat                = "./v1/Conversations/%s/Messages"
	opPathCreateConversationMessageFormat              = "./v1/Conversations/%s/Messages"
	opPathListConversationMessageReceiptFormat         = "./v1/Conversations/%s/Messages/%s/Receipts"
	opPathFetchConversationMessageReceiptFormat        = "./v1/Conversations/%s/Messages/%s/Receipts/%s"
	opPathDeleteConversationMessageFormat              = "./v1/Conversations/%s/Messages/%s"
	opPathFetchConversationMessageFormat               = "./v1/Conversations/%s/Messages/%s"
	opPathUpdateConversationMessageFormat              = "./v1/Conversations/%s/Messages/%s"
	opPathListConversationParticipantFormat            = "./v1/Conversations/%s/Participants"
	opPathCreateConversationParticipantFormat          = "./v1/Conversations/%s/Participants"
	opPathDeleteConversationParticipantFormat          = "./v1/Conversations/%s/Participants/%s"
	opPathFetchConversationParticipantFormat           = "./v1/Conversations/%s/Participants/%s"
	opPathUpdateConversationParticipantFormat          = "./v1/Conversations/%s/Participants/%s"
	opPathListConversationScopedWebhookFormat          = "./v1/Conversations/%s/Webhooks"
	opPathCreateConversationScopedWebhookFormat        = "./v1/Conversations/%s/Webhooks"
	opPathDeleteConversationScopedWebhookFormat        = "./v1/Conversations/%s/Webhooks/%s"
	opPathFetchConversationScopedWebhookFormat         = "./v1/Conversations/%s/Webhooks/%s"
	opPathUpdateConversationScopedWebhookFormat        = "./v1/Conversations/%s/Webhooks/%s"
	opPathDeleteConversationFormat                     = "./v1/Conversations/%s"
	opPathFetchConversationFormat                      = "./v1/Conversations/%s"
	opPathUpdateConversationFormat                     = "./v1/Conversations/%s"
	opPathDeleteCredentialFormat                       = "./v1/Credentials/%s"
	opPathFetchCredentialFormat                        = "./v1/Credentials/%s"
	opPathUpdateCredentialFormat                       = "./v1/Credentials/%s"
	opPathDeleteRoleFormat                             = "./v1/Roles/%s"
	opPathFetchRoleFormat                              = "./v1/Roles/%s"
	opPathUpdateRoleFormat                             = "./v1/Roles/%s"
	opPathListServiceBindingFormat                     = "./v1/Services/%s/Bindings"
	opPathDeleteServiceBindingFormat                   = "./v1/Services/%s/Bindings/%s"
	opPathFetchServiceBindingFormat                    = "./v1/Services/%s/Bindings/%s"
	opPathFetchServiceConfigurationFormat              = "./v1/Services/%s/Configuration"
	opPathUpdateServiceConfigurationFormat             = "./v1/Services/%s/Configuration"
	opPathFetchServiceNotificationFormat               = "./v1/Services/%s/Configuration/Notifications"
	opPathUpdateServiceNotificationFormat              = "./v1/Services/%s/Configuration/Notifications"
	opPathFetchServiceWebhookConfigurationFormat       = "./v1/Services/%s/Configuration/Webhooks"
	opPathUpdateServiceWebhookConfigurationFormat      = "./v1/Services/%s/Configuration/Webhooks"
	opPathListServiceConversationFormat                = "./v1/Services/%s/Conversations"
	opPathCreateServiceConversationFormat              = "./v1/Services/%s/Conversations"
	opPathListServiceConversationMessageFormat         = "./v1/Services/%s/Conversations/%s/Messages"
	opPathCreateServiceConversationMessageFormat       = "./v1/Services/%s/Conversations/%s/Messages"
	opPathListServiceConversationMessageReceiptFormat  = "./v1/Services/%s/Conversations/%s/Messages/%s/Receipts"
	opPathFetchServiceConversationMessageReceiptFormat = "./v1/Services/%s/Conversations/%s/Messages/%s/Receipts/%s"
	opPathDeleteServiceConversationMessageFormat       = "./v1/Services/%s/Conversations/%s/Messages/%s"
	opPathFetchServiceConversationMessageFormat        = "./v1/Services/%s/Conversations/%s/Messages/%s"
	opPathUpdateServiceConversationMessageFormat       = "./v1/Services/%s/Conversations/%s/Messages/%s"
	opPathListServiceConversationParticipantFormat     = "./v1/Services/%s/Conversations/%s/Participants"
	opPathCreateServiceConversationParticipantFormat   = "./v1/Services/%s/Conversations/%s/Participants"
	opPathDeleteServiceConversationParticipantFormat   = "./v1/Services/%s/Conversations/%s/Participants/%s"
	opPathFetchServiceConversationParticipantFormat    = "./v1/Services/%s/Conversations/%s/Participants/%s"
	opPathUpdateServiceConversationParticipantFormat   = "./v1/Services/%s/Conversations/%s/Participants/%s"
	opPathListServiceConversationScopedWebhookFormat   = "./v1/Services/%s/Conversations/%s/Webhooks"
	opPathCreateServiceConversationScopedWebhookFormat = "./v1/Services/%s/Conversations/%s/Webhooks"
	opPathDeleteServiceConversationScopedWebhookFormat = "./v1/Services/%s/Conversations/%s/Webhooks/%s"
	opPathFetchServiceConversationScopedWebhookFormat  = "./v1/Services/%s/Conversations/%s/Webhooks/%s"
	opPathUpdateServiceConversationScopedWebhookFormat = "./v1/Services/%s/Conversations/%s/Webhooks/%s"
	opPathDeleteServiceConversationFormat              = "./v1/Services/%s/Conversations/%s"
	opPathFetchServiceConversationFormat               = "./v1/Services/%s/Conversations/%s"
	opPathUpdateServiceConversationFormat              = "./v1/Services/%s/Conversations/%s"
	opPathListServiceParticipantConversationFormat     = "./v1/Services/%s/ParticipantConversations"
	opPathListServiceRoleFormat                        = "./v1/Services/%s/Roles"
	opPathCreateServiceRoleFormat                      = "./v1/Services/%s/Roles"
	opPathDeleteServiceRoleFormat                      = "./v1/Services/%s/Roles/%s"
	opPathFetchServiceRoleFormat                       = "./v1/Services/%s/Roles/%s"
	opPathUpdateServiceRoleFormat                      = "./v1/Services/%s/Roles/%s"
	opPathListServiceUserFormat                        = "./v1/Services/%s/Users"
	opPathCreateServiceUserFormat                      = "./v1/Services/%s/Users"
	opPathDeleteServiceUserFormat                      = "./v1/Services/%s/Users/%s"
	opPathFetchServiceUserFormat                       = "./v1/Services/%s/Users/%s"
	opPathUpdateServiceUserFormat                      = "./v1/Services/%s/Users/%s"
	opPathListServiceUserConversationFormat            = "./v1/Services/%s/Users/%s/Conversations"
	opPathDeleteServiceUserConversationFormat          = "./v1/Services/%s/Users/%s/Conversations/%s"
	opPathFetchServiceUserConversationFormat           = "./v1/Services/%s/Users/%s/Conversations/%s"
	opPathUpdateServiceUserConversationFormat          = "./v1/Services/%s/Users/%s/Conversations/%s"
	opPathDeleteServiceFormat                          = "./v1/Services/%s"
	opPathFetchServiceFormat                           = "./v1/Services/%s"
	opPathDeleteUserFormat                             = "./v1/Users/%s"
	opPathFetchUserFormat                              = "./v1/Users/%s"
	opPathUpdateUserFormat                             = "./v1/Users/%s"
	opPathListUserConversationFormat                   = "./v1/Users/%s/Conversations"
	opPathDeleteUserConversationFormat                 = "./v1/Users/%s/Conversations/%s"
	opPathFetchUserConversationFormat                  = "./v1/Users/%s/Conversations/%s"
	opPathUpdateUserConversationFormat                 = "./v1/Users/%s/Conversations/%s"
)

var (
	opPathFetchConfiguration          = client.MustParseURL("./v1/Configuration")
	opPathUpdateConfiguration         = client.MustParseURL("./v1/Configuration")
	opPathListConfigurationAddress    = client.MustParseURL("./v1/Configuration/Addresses")
	opPathCreateConfigurationAddress  = client.MustParseURL("./v1/Configuration/Addresses")
	opPathFetchConfigurationWebhook   = client.MustParseURL("./v1/Configuration/Webhooks")
	opPathUpdateConfigurationWebhook  = client.MustParseURL("./v1/Configuration/Webhooks")
	opPathListConversation            = client.MustParseURL("./v1/Conversations")
	opPathCreateConversation          = client.MustParseURL("./v1/Conversations")
	opPathListCredential              = client.MustParseURL("./v1/Credentials")
	opPathCreateCredential            = client.MustParseURL("./v1/Credentials")
	opPathListParticipantConversation = client.MustParseURL("./v1/ParticipantConversations")
	opPathListRole                    = client.MustParseURL("./v1/Roles")
	opPathCreateRole                  = client.MustParseURL("./v1/Roles")
	opPathListService                 = client.MustParseURL("./v1/Services")
	opPathCreateService               = client.MustParseURL("./v1/Services")
	opPathListUser                    = client.MustParseURL("./v1/Users")
	opPathCreateUser                  = client.MustParseURL("./v1/Users")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// FetchConfiguration request
	FetchConfiguration(ctx context.Context, reqEditors ...client.RequestEditorFn) (*FetchConfigurationResponse, error)

	// UpdateConfiguration request with any body
	UpdateConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConfigurationResponse, error)

	// ListConfigurationAddress request
	ListConfigurationAddress(ctx context.Context, params *ListConfigurationAddressParams, reqEditors ...client.RequestEditorFn) (*ListConfigurationAddressResponse, error)

	// CreateConfigurationAddress request with any body
	CreateConfigurationAddressWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateConfigurationAddressResponse, error)

	// DeleteConfigurationAddress request
	DeleteConfigurationAddress(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteConfigurationAddressResponse, error)

	// FetchConfigurationAddress request
	FetchConfigurationAddress(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchConfigurationAddressResponse, error)

	// UpdateConfigurationAddress request with any body
	UpdateConfigurationAddressWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConfigurationAddressResponse, error)

	// FetchConfigurationWebhook request
	FetchConfigurationWebhook(ctx context.Context, reqEditors ...client.RequestEditorFn) (*FetchConfigurationWebhookResponse, error)

	// UpdateConfigurationWebhook request with any body
	UpdateConfigurationWebhookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConfigurationWebhookResponse, error)

	// ListConversation request
	ListConversation(ctx context.Context, params *ListConversationParams, reqEditors ...client.RequestEditorFn) (*ListConversationResponse, error)

	// CreateConversation request with any body
	CreateConversationWithBody(ctx context.Context, params *CreateConversationParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateConversationResponse, error)

	// ListConversationMessage request
	ListConversationMessage(ctx context.Context, conversationSid string, params *ListConversationMessageParams, reqEditors ...client.RequestEditorFn) (*ListConversationMessageResponse, error)

	// CreateConversationMessage request with any body
	CreateConversationMessageWithBody(ctx context.Context, conversationSid string, params *CreateConversationMessageParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateConversationMessageResponse, error)

	// ListConversationMessageReceipt request
	ListConversationMessageReceipt(ctx context.Context, conversationSid string, messageSid string, params *ListConversationMessageReceiptParams, reqEditors ...client.RequestEditorFn) (*ListConversationMessageReceiptResponse, error)

	// FetchConversationMessageReceipt request
	FetchConversationMessageReceipt(ctx context.Context, conversationSid string, messageSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchConversationMessageReceiptResponse, error)

	// DeleteConversationMessage request
	DeleteConversationMessage(ctx context.Context, conversationSid string, sid string, params *DeleteConversationMessageParams, reqEditors ...client.RequestEditorFn) (*DeleteConversationMessageResponse, error)

	// FetchConversationMessage request
	FetchConversationMessage(ctx context.Context, conversationSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchConversationMessageResponse, error)

	// UpdateConversationMessage request with any body
	UpdateConversationMessageWithBody(ctx context.Context, conversationSid string, sid string, params *UpdateConversationMessageParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConversationMessageResponse, error)

	// ListConversationParticipant request
	ListConversationParticipant(ctx context.Context, conversationSid string, params *ListConversationParticipantParams, reqEditors ...client.RequestEditorFn) (*ListConversationParticipantResponse, error)

	// CreateConversationParticipant request with any body
	CreateConversationParticipantWithBody(ctx context.Context, conversationSid string, params *CreateConversationParticipantParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateConversationParticipantResponse, error)

	// DeleteConversationParticipant request
	DeleteConversationParticipant(ctx context.Context, conversationSid string, sid string, params *DeleteConversationParticipantParams, reqEditors ...client.RequestEditorFn) (*DeleteConversationParticipantResponse, error)

	// FetchConversationParticipant request
	FetchConversationParticipant(ctx context.Context, conversationSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchConversationParticipantResponse, error)

	// UpdateConversationParticipant request with any body
	UpdateConversationParticipantWithBody(ctx context.Context, conversationSid string, sid string, params *UpdateConversationParticipantParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConversationParticipantResponse, error)

	// ListConversationScopedWebhook request
	ListConversationScopedWebhook(ctx context.Context, conversationSid string, params *ListConversationScopedWebhookParams, reqEditors ...client.RequestEditorFn) (*ListConversationScopedWebhookResponse, error)

	// CreateConversationScopedWebhook request with any body
	CreateConversationScopedWebhookWithBody(ctx context.Context, conversationSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateConversationScopedWebhookResponse, error)

	// DeleteConversationScopedWebhook request
	DeleteConversationScopedWebhook(ctx context.Context, conversationSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteConversationScopedWebhookResponse, error)

	// FetchConversationScopedWebhook request
	FetchConversationScopedWebhook(ctx context.Context, conversationSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchConversationScopedWebhookResponse, error)

	// UpdateConversationScopedWebhook request with any body
	UpdateConversationScopedWebhookWithBody(ctx context.Context, conversationSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConversationScopedWebhookResponse, error)

	// DeleteConversation request
	DeleteConversation(ctx context.Context, sid string, params *DeleteConversationParams, reqEditors ...client.RequestEditorFn) (*DeleteConversationResponse, error)

	// FetchConversation request
	FetchConversation(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchConversationResponse, error)

	// UpdateConversation request with any body
	UpdateConversationWithBody(ctx context.Context, sid string, params *UpdateConversationParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConversationResponse, error)

	// ListCredential request
	ListCredential(ctx context.Context, params *ListCredentialParams, reqEditors ...client.RequestEditorFn) (*ListCredentialResponse, error)

	// CreateCredential request with any body
	CreateCredentialWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCredentialResponse, error)

	// DeleteCredential request
	DeleteCredential(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCredentialResponse, error)

	// FetchCredential request
	FetchCredential(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchCredentialResponse, error)

	// UpdateCredential request with any body
	UpdateCredentialWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateCredentialResponse, error)

	// ListParticipantConversation request
	ListParticipantConversation(ctx context.Context, params *ListParticipantConversationParams, reqEditors ...client.RequestEditorFn) (*ListParticipantConversationResponse, error)

	// ListRole request
	ListRole(ctx context.Context, params *ListRoleParams, reqEditors ...client.RequestEditorFn) (*ListRoleResponse, error)

	// CreateRole request with any body
	CreateRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateRoleResponse, error)

	// DeleteRole request
	DeleteRole(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteRoleResponse, error)

	// FetchRole request
	FetchRole(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchRoleResponse, error)

	// UpdateRole request with any body
	UpdateRoleWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateRoleResponse, error)

	// ListService request
	ListService(ctx context.Context, params *ListServiceParams, reqEditors ...client.RequestEditorFn) (*ListServiceResponse, error)

	// CreateService request with any body
	CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceResponse, error)

	// ListServiceBinding request
	ListServiceBinding(ctx context.Context, chatServiceSid string, params *ListServiceBindingParams, reqEditors ...client.RequestEditorFn) (*ListServiceBindingResponse, error)

	// DeleteServiceBinding request
	DeleteServiceBinding(ctx context.Context, chatServiceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteServiceBindingResponse, error)

	// FetchServiceBinding request
	FetchServiceBinding(ctx context.Context, chatServiceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceBindingResponse, error)

	// FetchServiceConfiguration request
	FetchServiceConfiguration(ctx context.Context, chatServiceSid string, reqEditors ...client.RequestEditorFn) (*FetchServiceConfigurationResponse, error)

	// UpdateServiceConfiguration request with any body
	UpdateServiceConfigurationWithBody(ctx context.Context, chatServiceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceConfigurationResponse, error)

	// FetchServiceNotification request
	FetchServiceNotification(ctx context.Context, chatServiceSid string, reqEditors ...client.RequestEditorFn) (*FetchServiceNotificationResponse, error)

	// UpdateServiceNotification request with any body
	UpdateServiceNotificationWithBody(ctx context.Context, chatServiceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceNotificationResponse, error)

	// FetchServiceWebhookConfiguration request
	FetchServiceWebhookConfiguration(ctx context.Context, chatServiceSid string, reqEditors ...client.RequestEditorFn) (*FetchServiceWebhookConfigurationResponse, error)

	// UpdateServiceWebhookConfiguration request with any body
	UpdateServiceWebhookConfigurationWithBody(ctx context.Context, chatServiceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceWebhookConfigurationResponse, error)

	// ListServiceConversation request
	ListServiceConversation(ctx context.Context, chatServiceSid string, params *ListServiceConversationParams, reqEditors ...client.RequestEditorFn) (*ListServiceConversationResponse, error)

	// CreateServiceConversation request with any body
	CreateServiceConversationWithBody(ctx context.Context, chatServiceSid string, params *CreateServiceConversationParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceConversationResponse, error)

	// ListServiceConversationMessage request
	ListServiceConversationMessage(ctx context.Context, chatServiceSid string, conversationSid string, params *ListServiceConversationMessageParams, reqEditors ...client.RequestEditorFn) (*ListServiceConversationMessageResponse, error)

	// CreateServiceConversationMessage request with any body
	CreateServiceConversationMessageWithBody(ctx context.Context, chatServiceSid string, conversationSid string, params *CreateServiceConversationMessageParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceConversationMessageResponse, error)

	// ListServiceConversationMessageReceipt request
	ListServiceConversationMessageReceipt(ctx context.Context, chatServiceSid string, conversationSid string, messageSid string, params *ListServiceConversationMessageReceiptParams, reqEditors ...client.RequestEditorFn) (*ListServiceConversationMessageReceiptResponse, error)

	// FetchServiceConversationMessageReceipt request
	FetchServiceConversationMessageReceipt(ctx context.Context, chatServiceSid string, conversationSid string, messageSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceConversationMessageReceiptResponse, error)

	// DeleteServiceConversationMessage request
	DeleteServiceConversationMessage(ctx context.Context, chatServiceSid string, conversationSid string, sid string, params *DeleteServiceConversationMessageParams, reqEditors ...client.RequestEditorFn) (*DeleteServiceConversationMessageResponse, error)

	// FetchServiceConversationMessage request
	FetchServiceConversationMessage(ctx context.Context, chatServiceSid string, conversationSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceConversationMessageResponse, error)

	// UpdateServiceConversationMessage request with any body
	UpdateServiceConversationMessageWithBody(ctx context.Context, chatServiceSid string, conversationSid string, sid string, params *UpdateServiceConversationMessageParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceConversationMessageResponse, error)

	// ListServiceConversationParticipant request
	ListServiceConversationParticipant(ctx context.Context, chatServiceSid string, conversationSid string, params *ListServiceConversationParticipantParams, reqEditors ...client.RequestEditorFn) (*ListServiceConversationParticipantResponse, error)

	// CreateServiceConversationParticipant request with any body
	CreateServiceConversationParticipantWithBody(ctx context.Context, chatServiceSid string, conversationSid string, params *CreateServiceConversationParticipantParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceConversationParticipantResponse, error)

	// DeleteServiceConversationParticipant request
	DeleteServiceConversationParticipant(ctx context.Context, chatServiceSid string, conversationSid string, sid string, params *DeleteServiceConversationParticipantParams, reqEditors ...client.RequestEditorFn) (*DeleteServiceConversationParticipantResponse, error)

	// FetchServiceConversationParticipant request
	FetchServiceConversationParticipant(ctx context.Context, chatServiceSid string, conversationSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceConversationParticipantResponse, error)

	// UpdateServiceConversationParticipant request with any body
	UpdateServiceConversationParticipantWithBody(ctx context.Context, chatServiceSid string, conversationSid string, sid string, params *UpdateServiceConversationParticipantParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceConversationParticipantResponse, error)

	// ListServiceConversationScopedWebhook request
	ListServiceConversationScopedWebhook(ctx context.Context, chatServiceSid string, conversationSid string, params *ListServiceConversationScopedWebhookParams, reqEditors ...client.RequestEditorFn) (*ListServiceConversationScopedWebhookResponse, error)

	// CreateServiceConversationScopedWebhook request with any body
	CreateServiceConversationScopedWebhookWithBody(ctx context.Context, chatServiceSid string, conversationSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceConversationScopedWebhookResponse, error)

	// DeleteServiceConversationScopedWebhook request
	DeleteServiceConversationScopedWebhook(ctx context.Context, chatServiceSid string, conversationSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteServiceConversationScopedWebhookResponse, error)

	// FetchServiceConversationScopedWebhook request
	FetchServiceConversationScopedWebhook(ctx context.Context, chatServiceSid string, conversationSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceConversationScopedWebhookResponse, error)

	// UpdateServiceConversationScopedWebhook request with any body
	UpdateServiceConversationScopedWebhookWithBody(ctx context.Context, chatServiceSid string, conversationSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceConversationScopedWebhookResponse, error)

	// DeleteServiceConversation request
	DeleteServiceConversation(ctx context.Context, chatServiceSid string, sid string, params *DeleteServiceConversationParams, reqEditors ...client.RequestEditorFn) (*DeleteServiceConversationResponse, error)

	// FetchServiceConversation request
	FetchServiceConversation(ctx context.Context, chatServiceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceConversationResponse, error)

	// UpdateServiceConversation request with any body
	UpdateServiceConversationWithBody(ctx context.Context, chatServiceSid string, sid string, params *UpdateServiceConversationParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceConversationResponse, error)

	// ListServiceParticipantConversation request
	ListServiceParticipantConversation(ctx context.Context, chatServiceSid string, params *ListServiceParticipantConversationParams, reqEditors ...client.RequestEditorFn) (*ListServiceParticipantConversationResponse, error)

	// ListServiceRole request
	ListServiceRole(ctx context.Context, chatServiceSid string, params *ListServiceRoleParams, reqEditors ...client.RequestEditorFn) (*ListServiceRoleResponse, error)

	// CreateServiceRole request with any body
	CreateServiceRoleWithBody(ctx context.Context, chatServiceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceRoleResponse, error)

	// DeleteServiceRole request
	DeleteServiceRole(ctx context.Context, chatServiceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteServiceRoleResponse, error)

	// FetchServiceRole request
	FetchServiceRole(ctx context.Context, chatServiceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceRoleResponse, error)

	// UpdateServiceRole request with any body
	UpdateServiceRoleWithBody(ctx context.Context, chatServiceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceRoleResponse, error)

	// ListServiceUser request
	ListServiceUser(ctx context.Context, chatServiceSid string, params *ListServiceUserParams, reqEditors ...client.RequestEditorFn) (*ListServiceUserResponse, error)

	// CreateServiceUser request with any body
	CreateServiceUserWithBody(ctx context.Context, chatServiceSid string, params *CreateServiceUserParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceUserResponse, error)

	// DeleteServiceUser request
	DeleteServiceUser(ctx context.Context, chatServiceSid string, sid string, params *DeleteServiceUserParams, reqEditors ...client.RequestEditorFn) (*DeleteServiceUserResponse, error)

	// FetchServiceUser request
	FetchServiceUser(ctx context.Context, chatServiceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceUserResponse, error)

	// UpdateServiceUser request with any body
	UpdateServiceUserWithBody(ctx context.Context, chatServiceSid string, sid string, params *UpdateServiceUserParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceUserResponse, error)

	// ListServiceUserConversation request
	ListServiceUserConversation(ctx context.Context, chatServiceSid string, userSid string, params *ListServiceUserConversationParams, reqEditors ...client.RequestEditorFn) (*ListServiceUserConversationResponse, error)

	// DeleteServiceUserConversation request
	DeleteServiceUserConversation(ctx context.Context, chatServiceSid string, userSid string, conversationSid string, reqEditors ...client.RequestEditorFn) (*DeleteServiceUserConversationResponse, error)

	// FetchServiceUserConversation request
	FetchServiceUserConversation(ctx context.Context, chatServiceSid string, userSid string, conversationSid string, reqEditors ...client.RequestEditorFn) (*FetchServiceUserConversationResponse, error)

	// UpdateServiceUserConversation request with any body
	UpdateServiceUserConversationWithBody(ctx context.Context, chatServiceSid string, userSid string, conversationSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceUserConversationResponse, error)

	// DeleteService request
	DeleteService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteServiceResponse, error)

	// FetchService request
	FetchService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceResponse, error)

	// ListUser request
	ListUser(ctx context.Context, params *ListUserParams, reqEditors ...client.RequestEditorFn) (*ListUserResponse, error)

	// CreateUser request with any body
	CreateUserWithBody(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, sid string, params *DeleteUserParams, reqEditors ...client.RequestEditorFn) (*DeleteUserResponse, error)

	// FetchUser request
	FetchUser(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchUserResponse, error)

	// UpdateUser request with any body
	UpdateUserWithBody(ctx context.Context, sid string, params *UpdateUserParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateUserResponse, error)

	// ListUserConversation request
	ListUserConversation(ctx context.Context, userSid string, params *ListUserConversationParams, reqEditors ...client.RequestEditorFn) (*ListUserConversationResponse, error)

	// DeleteUserConversation request
	DeleteUserConversation(ctx context.Context, userSid string, conversationSid string, reqEditors ...client.RequestEditorFn) (*DeleteUserConversationResponse, error)

	// FetchUserConversation request
	FetchUserConversation(ctx context.Context, userSid string, conversationSid string, reqEditors ...client.RequestEditorFn) (*FetchUserConversationResponse, error)

	// UpdateUserConversation request with any body
	UpdateUserConversationWithBody(ctx context.Context, userSid string, conversationSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateUserConversationResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// FetchConfiguration: GET /v1/Configuration

type FetchConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1Configuration
}

// Status returns HTTPResponse.Status
func (r FetchConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchConfigurationRequest generates requests for FetchConfiguration
func newFetchConfigurationRequest(baseURL *url.URL) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathFetchConfiguration)

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchConfiguration returns a parsed response.
// GET /v1/Configuration
func (c *Client) FetchConfiguration(ctx context.Context, reqEditors ...client.RequestEditorFn) (*FetchConfigurationResponse, error) {
	req, err := newFetchConfigurationRequest(c.BaseURL)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1Configuration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateConfiguration: POST /v1/Configuration

type UpdateConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1Configuration
}

// Status returns HTTPResponse.Status
func (r UpdateConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateConfigurationRequestWithBody generates requests for UpdateConfiguration with any type of body
func newUpdateConfigurationRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathUpdateConfiguration)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateConfigurationWithBody returns a parsed response.
// POST /v1/Configuration
func (c *Client) UpdateConfigurationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConfigurationResponse, error) {
	req, err := newUpdateConfigurationRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1Configuration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListConfigurationAddress: GET /v1/Configuration/Addresses

type ListConfigurationAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AddressConfigurations *[]ConversationsV1ConfigurationAddress `json:"address_configurations,omitempty"`
		Meta                  *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListConfigurationAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConfigurationAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListConfigurationAddressRequest generates requests for ListConfigurationAddress
func newListConfigurationAddressRequest(baseURL *url.URL, params *ListConfigurationAddressParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListConfigurationAddress)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListConfigurationAddress returns a parsed response.
// GET /v1/Configuration/Addresses
func (c *Client) ListConfigurationAddress(ctx context.Context, params *ListConfigurationAddressParams, reqEditors ...client.RequestEditorFn) (*ListConfigurationAddressResponse, error) {
	req, err := newListConfigurationAddressRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListConfigurationAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AddressConfigurations *[]ConversationsV1ConfigurationAddress `json:"address_configurations,omitempty"`
			Meta                  *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateConfigurationAddress: POST /v1/Configuration/Addresses

type CreateConfigurationAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ConversationsV1ConfigurationAddress
}

// Status returns HTTPResponse.Status
func (r CreateConfigurationAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConfigurationAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateConfigurationAddressRequestWithBody generates requests for CreateConfigurationAddress with any type of body
func newCreateConfigurationAddressRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateConfigurationAddress)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateConfigurationAddressWithBody returns a parsed response.
// POST /v1/Configuration/Addresses
func (c *Client) CreateConfigurationAddressWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateConfigurationAddressResponse, error) {
	req, err := newCreateConfigurationAddressRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateConfigurationAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ConversationsV1ConfigurationAddress
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteConfigurationAddress: DELETE /v1/Configuration/Addresses/{Sid}

type DeleteConfigurationAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteConfigurationAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConfigurationAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteConfigurationAddressRequest generates requests for DeleteConfigurationAddress
func newDeleteConfigurationAddressRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteConfigurationAddressFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteConfigurationAddress returns a parsed response.
// DELETE /v1/Configuration/Addresses/{Sid}
func (c *Client) DeleteConfigurationAddress(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteConfigurationAddressResponse, error) {
	req, err := newDeleteConfigurationAddressRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteConfigurationAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchConfigurationAddress: GET /v1/Configuration/Addresses/{Sid}

type FetchConfigurationAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ConfigurationAddress
}

// Status returns HTTPResponse.Status
func (r FetchConfigurationAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchConfigurationAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchConfigurationAddressRequest generates requests for FetchConfigurationAddress
func newFetchConfigurationAddressRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchConfigurationAddressFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchConfigurationAddress returns a parsed response.
// GET /v1/Configuration/Addresses/{Sid}
func (c *Client) FetchConfigurationAddress(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchConfigurationAddressResponse, error) {
	req, err := newFetchConfigurationAddressRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchConfigurationAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ConfigurationAddress
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateConfigurationAddress: POST /v1/Configuration/Addresses/{Sid}

type UpdateConfigurationAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ConfigurationAddress
}

// Status returns HTTPResponse.Status
func (r UpdateConfigurationAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConfigurationAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateConfigurationAddressRequestWithBody generates requests for UpdateConfigurationAddress with any type of body
func newUpdateConfigurationAddressRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateConfigurationAddressFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateConfigurationAddressWithBody returns a parsed response.
// POST /v1/Configuration/Addresses/{Sid}
func (c *Client) UpdateConfigurationAddressWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConfigurationAddressResponse, error) {
	req, err := newUpdateConfigurationAddressRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateConfigurationAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ConfigurationAddress
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchConfigurationWebhook: GET /v1/Configuration/Webhooks

type FetchConfigurationWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ConfigurationConfigurationWebhook
}

// Status returns HTTPResponse.Status
func (r FetchConfigurationWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchConfigurationWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchConfigurationWebhookRequest generates requests for FetchConfigurationWebhook
func newFetchConfigurationWebhookRequest(baseURL *url.URL) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathFetchConfigurationWebhook)

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchConfigurationWebhook returns a parsed response.
// GET /v1/Configuration/Webhooks
func (c *Client) FetchConfigurationWebhook(ctx context.Context, reqEditors ...client.RequestEditorFn) (*FetchConfigurationWebhookResponse, error) {
	req, err := newFetchConfigurationWebhookRequest(c.BaseURL)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchConfigurationWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ConfigurationConfigurationWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateConfigurationWebhook: POST /v1/Configuration/Webhooks

type UpdateConfigurationWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ConfigurationConfigurationWebhook
}

// Status returns HTTPResponse.Status
func (r UpdateConfigurationWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConfigurationWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateConfigurationWebhookRequestWithBody generates requests for UpdateConfigurationWebhook with any type of body
func newUpdateConfigurationWebhookRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathUpdateConfigurationWebhook)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateConfigurationWebhookWithBody returns a parsed response.
// POST /v1/Configuration/Webhooks
func (c *Client) UpdateConfigurationWebhookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConfigurationWebhookResponse, error) {
	req, err := newUpdateConfigurationWebhookRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateConfigurationWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ConfigurationConfigurationWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListConversation: GET /v1/Conversations

type ListConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Conversations *[]ConversationsV1Conversation `json:"conversations,omitempty"`
		Meta          *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListConversationRequest generates requests for ListConversation
func newListConversationRequest(baseURL *url.URL, params *ListConversationParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListConversation)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListConversation returns a parsed response.
// GET /v1/Conversations
func (c *Client) ListConversation(ctx context.Context, params *ListConversationParams, reqEditors ...client.RequestEditorFn) (*ListConversationResponse, error) {
	req, err := newListConversationRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Conversations *[]ConversationsV1Conversation `json:"conversations,omitempty"`
			Meta          *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateConversation: POST /v1/Conversations

type CreateConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ConversationsV1Conversation
}

// Status returns HTTPResponse.Status
func (r CreateConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateConversationRequestWithBody generates requests for CreateConversation with any type of body
func newCreateConversationRequestWithBody(baseURL *url.URL, params *CreateConversationParams, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateConversation)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// CreateConversationWithBody returns a parsed response.
// POST /v1/Conversations
func (c *Client) CreateConversationWithBody(ctx context.Context, params *CreateConversationParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateConversationResponse, error) {
	req, err := newCreateConversationRequestWithBody(c.BaseURL, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ConversationsV1Conversation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListConversationMessage: GET /v1/Conversations/{ConversationSid}/Messages

type ListConversationMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Messages *[]ConversationsV1ConversationConversationMessage `json:"messages,omitempty"`
		Meta     *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListConversationMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConversationMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListConversationMessageRequest generates requests for ListConversationMessage
func newListConversationMessageRequest(baseURL *url.URL, conversationSid string, params *ListConversationMessageParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListConversationMessageFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Order != nil {
		if err := client.AddQueryParam(q, "Order", *params.Order); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListConversationMessage returns a parsed response.
// GET /v1/Conversations/{ConversationSid}/Messages
func (c *Client) ListConversationMessage(ctx context.Context, conversationSid string, params *ListConversationMessageParams, reqEditors ...client.RequestEditorFn) (*ListConversationMessageResponse, error) {
	req, err := newListConversationMessageRequest(c.BaseURL, conversationSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListConversationMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Messages *[]ConversationsV1ConversationConversationMessage `json:"messages,omitempty"`
			Meta     *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateConversationMessage: POST /v1/Conversations/{ConversationSid}/Messages

type CreateConversationMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ConversationsV1ConversationConversationMessage
}

// Status returns HTTPResponse.Status
func (r CreateConversationMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConversationMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateConversationMessageRequestWithBody generates requests for CreateConversationMessage with any type of body
func newCreateConversationMessageRequestWithBody(baseURL *url.URL, conversationSid string, params *CreateConversationMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateConversationMessageFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// CreateConversationMessageWithBody returns a parsed response.
// POST /v1/Conversations/{ConversationSid}/Messages
func (c *Client) CreateConversationMessageWithBody(ctx context.Context, conversationSid string, params *CreateConversationMessageParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateConversationMessageResponse, error) {
	req, err := newCreateConversationMessageRequestWithBody(c.BaseURL, conversationSid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateConversationMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ConversationsV1ConversationConversationMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListConversationMessageReceipt: GET /v1/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts

type ListConversationMessageReceiptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DeliveryReceipts *[]ConversationsV1ConversationConversationMessageConversationMessageReceipt `json:"delivery_receipts,omitempty"`
		Meta             *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListConversationMessageReceiptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConversationMessageReceiptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListConversationMessageReceiptRequest generates requests for ListConversationMessageReceipt
func newListConversationMessageReceiptRequest(baseURL *url.URL, conversationSid string, messageSid string, params *ListConversationMessageReceiptParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("MessageSid", messageSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListConversationMessageReceiptFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListConversationMessageReceipt returns a parsed response.
// GET /v1/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts
func (c *Client) ListConversationMessageReceipt(ctx context.Context, conversationSid string, messageSid string, params *ListConversationMessageReceiptParams, reqEditors ...client.RequestEditorFn) (*ListConversationMessageReceiptResponse, error) {
	req, err := newListConversationMessageReceiptRequest(c.BaseURL, conversationSid, messageSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListConversationMessageReceiptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DeliveryReceipts *[]ConversationsV1ConversationConversationMessageConversationMessageReceipt `json:"delivery_receipts,omitempty"`
			Meta             *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchConversationMessageReceipt: GET /v1/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts/{Sid}

type FetchConversationMessageReceiptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ConversationConversationMessageConversationMessageReceipt
}

// Status returns HTTPResponse.Status
func (r FetchConversationMessageReceiptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchConversationMessageReceiptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchConversationMessageReceiptRequest generates requests for FetchConversationMessageReceipt
func newFetchConversationMessageReceiptRequest(baseURL *url.URL, conversationSid string, messageSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("MessageSid", messageSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchConversationMessageReceiptFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchConversationMessageReceipt returns a parsed response.
// GET /v1/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts/{Sid}
func (c *Client) FetchConversationMessageReceipt(ctx context.Context, conversationSid string, messageSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchConversationMessageReceiptResponse, error) {
	req, err := newFetchConversationMessageReceiptRequest(c.BaseURL, conversationSid, messageSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchConversationMessageReceiptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ConversationConversationMessageConversationMessageReceipt
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteConversationMessage: DELETE /v1/Conversations/{ConversationSid}/Messages/{Sid}

type DeleteConversationMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteConversationMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConversationMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteConversationMessageRequest generates requests for DeleteConversationMessage
func newDeleteConversationMessageRequest(baseURL *url.URL, conversationSid string, sid string, params *DeleteConversationMessageParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteConversationMessageFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// DeleteConversationMessage returns a parsed response.
// DELETE /v1/Conversations/{ConversationSid}/Messages/{Sid}
func (c *Client) DeleteConversationMessage(ctx context.Context, conversationSid string, sid string, params *DeleteConversationMessageParams, reqEditors ...client.RequestEditorFn) (*DeleteConversationMessageResponse, error) {
	req, err := newDeleteConversationMessageRequest(c.BaseURL, conversationSid, sid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteConversationMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchConversationMessage: GET /v1/Conversations/{ConversationSid}/Messages/{Sid}

type FetchConversationMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ConversationConversationMessage
}

// Status returns HTTPResponse.Status
func (r FetchConversationMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchConversationMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchConversationMessageRequest generates requests for FetchConversationMessage
func newFetchConversationMessageRequest(baseURL *url.URL, conversationSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchConversationMessageFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchConversationMessage returns a parsed response.
// GET /v1/Conversations/{ConversationSid}/Messages/{Sid}
func (c *Client) FetchConversationMessage(ctx context.Context, conversationSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchConversationMessageResponse, error) {
	req, err := newFetchConversationMessageRequest(c.BaseURL, conversationSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchConversationMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ConversationConversationMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateConversationMessage: POST /v1/Conversations/{ConversationSid}/Messages/{Sid}

type UpdateConversationMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ConversationConversationMessage
}

// Status returns HTTPResponse.Status
func (r UpdateConversationMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConversationMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateConversationMessageRequestWithBody generates requests for UpdateConversationMessage with any type of body
func newUpdateConversationMessageRequestWithBody(baseURL *url.URL, conversationSid string, sid string, params *UpdateConversationMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateConversationMessageFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// UpdateConversationMessageWithBody returns a parsed response.
// POST /v1/Conversations/{ConversationSid}/Messages/{Sid}
func (c *Client) UpdateConversationMessageWithBody(ctx context.Context, conversationSid string, sid string, params *UpdateConversationMessageParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConversationMessageResponse, error) {
	req, err := newUpdateConversationMessageRequestWithBody(c.BaseURL, conversationSid, sid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateConversationMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ConversationConversationMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListConversationParticipant: GET /v1/Conversations/{ConversationSid}/Participants

type ListConversationParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Participants *[]ConversationsV1ConversationConversationParticipant `json:"participants,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListConversationParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConversationParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListConversationParticipantRequest generates requests for ListConversationParticipant
func newListConversationParticipantRequest(baseURL *url.URL, conversationSid string, params *ListConversationParticipantParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListConversationParticipantFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListConversationParticipant returns a parsed response.
// GET /v1/Conversations/{ConversationSid}/Participants
func (c *Client) ListConversationParticipant(ctx context.Context, conversationSid string, params *ListConversationParticipantParams, reqEditors ...client.RequestEditorFn) (*ListConversationParticipantResponse, error) {
	req, err := newListConversationParticipantRequest(c.BaseURL, conversationSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListConversationParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Participants *[]ConversationsV1ConversationConversationParticipant `json:"participants,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateConversationParticipant: POST /v1/Conversations/{ConversationSid}/Participants

type CreateConversationParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ConversationsV1ConversationConversationParticipant
}

// Status returns HTTPResponse.Status
func (r CreateConversationParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConversationParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateConversationParticipantRequestWithBody generates requests for CreateConversationParticipant with any type of body
func newCreateConversationParticipantRequestWithBody(baseURL *url.URL, conversationSid string, params *CreateConversationParticipantParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateConversationParticipantFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// CreateConversationParticipantWithBody returns a parsed response.
// POST /v1/Conversations/{ConversationSid}/Participants
func (c *Client) CreateConversationParticipantWithBody(ctx context.Context, conversationSid string, params *CreateConversationParticipantParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateConversationParticipantResponse, error) {
	req, err := newCreateConversationParticipantRequestWithBody(c.BaseURL, conversationSid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateConversationParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ConversationsV1ConversationConversationParticipant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteConversationParticipant: DELETE /v1/Conversations/{ConversationSid}/Participants/{Sid}

type DeleteConversationParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteConversationParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConversationParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteConversationParticipantRequest generates requests for DeleteConversationParticipant
func newDeleteConversationParticipantRequest(baseURL *url.URL, conversationSid string, sid string, params *DeleteConversationParticipantParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteConversationParticipantFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// DeleteConversationParticipant returns a parsed response.
// DELETE /v1/Conversations/{ConversationSid}/Participants/{Sid}
func (c *Client) DeleteConversationParticipant(ctx context.Context, conversationSid string, sid string, params *DeleteConversationParticipantParams, reqEditors ...client.RequestEditorFn) (*DeleteConversationParticipantResponse, error) {
	req, err := newDeleteConversationParticipantRequest(c.BaseURL, conversationSid, sid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteConversationParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchConversationParticipant: GET /v1/Conversations/{ConversationSid}/Participants/{Sid}

type FetchConversationParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ConversationConversationParticipant
}

// Status returns HTTPResponse.Status
func (r FetchConversationParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchConversationParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchConversationParticipantRequest generates requests for FetchConversationParticipant
func newFetchConversationParticipantRequest(baseURL *url.URL, conversationSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchConversationParticipantFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchConversationParticipant returns a parsed response.
// GET /v1/Conversations/{ConversationSid}/Participants/{Sid}
func (c *Client) FetchConversationParticipant(ctx context.Context, conversationSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchConversationParticipantResponse, error) {
	req, err := newFetchConversationParticipantRequest(c.BaseURL, conversationSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchConversationParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ConversationConversationParticipant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateConversationParticipant: POST /v1/Conversations/{ConversationSid}/Participants/{Sid}

type UpdateConversationParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ConversationConversationParticipant
}

// Status returns HTTPResponse.Status
func (r UpdateConversationParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConversationParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateConversationParticipantRequestWithBody generates requests for UpdateConversationParticipant with any type of body
func newUpdateConversationParticipantRequestWithBody(baseURL *url.URL, conversationSid string, sid string, params *UpdateConversationParticipantParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateConversationParticipantFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// UpdateConversationParticipantWithBody returns a parsed response.
// POST /v1/Conversations/{ConversationSid}/Participants/{Sid}
func (c *Client) UpdateConversationParticipantWithBody(ctx context.Context, conversationSid string, sid string, params *UpdateConversationParticipantParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConversationParticipantResponse, error) {
	req, err := newUpdateConversationParticipantRequestWithBody(c.BaseURL, conversationSid, sid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateConversationParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ConversationConversationParticipant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListConversationScopedWebhook: GET /v1/Conversations/{ConversationSid}/Webhooks

type ListConversationScopedWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Webhooks *[]ConversationsV1ConversationConversationScopedWebhook `json:"webhooks,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListConversationScopedWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConversationScopedWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListConversationScopedWebhookRequest generates requests for ListConversationScopedWebhook
func newListConversationScopedWebhookRequest(baseURL *url.URL, conversationSid string, params *ListConversationScopedWebhookParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListConversationScopedWebhookFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListConversationScopedWebhook returns a parsed response.
// GET /v1/Conversations/{ConversationSid}/Webhooks
func (c *Client) ListConversationScopedWebhook(ctx context.Context, conversationSid string, params *ListConversationScopedWebhookParams, reqEditors ...client.RequestEditorFn) (*ListConversationScopedWebhookResponse, error) {
	req, err := newListConversationScopedWebhookRequest(c.BaseURL, conversationSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListConversationScopedWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Webhooks *[]ConversationsV1ConversationConversationScopedWebhook `json:"webhooks,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateConversationScopedWebhook: POST /v1/Conversations/{ConversationSid}/Webhooks

type CreateConversationScopedWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ConversationsV1ConversationConversationScopedWebhook
}

// Status returns HTTPResponse.Status
func (r CreateConversationScopedWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConversationScopedWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateConversationScopedWebhookRequestWithBody generates requests for CreateConversationScopedWebhook with any type of body
func newCreateConversationScopedWebhookRequestWithBody(baseURL *url.URL, conversationSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateConversationScopedWebhookFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateConversationScopedWebhookWithBody returns a parsed response.
// POST /v1/Conversations/{ConversationSid}/Webhooks
func (c *Client) CreateConversationScopedWebhookWithBody(ctx context.Context, conversationSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateConversationScopedWebhookResponse, error) {
	req, err := newCreateConversationScopedWebhookRequestWithBody(c.BaseURL, conversationSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateConversationScopedWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ConversationsV1ConversationConversationScopedWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteConversationScopedWebhook: DELETE /v1/Conversations/{ConversationSid}/Webhooks/{Sid}

type DeleteConversationScopedWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteConversationScopedWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConversationScopedWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteConversationScopedWebhookRequest generates requests for DeleteConversationScopedWebhook
func newDeleteConversationScopedWebhookRequest(baseURL *url.URL, conversationSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteConversationScopedWebhookFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteConversationScopedWebhook returns a parsed response.
// DELETE /v1/Conversations/{ConversationSid}/Webhooks/{Sid}
func (c *Client) DeleteConversationScopedWebhook(ctx context.Context, conversationSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteConversationScopedWebhookResponse, error) {
	req, err := newDeleteConversationScopedWebhookRequest(c.BaseURL, conversationSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteConversationScopedWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchConversationScopedWebhook: GET /v1/Conversations/{ConversationSid}/Webhooks/{Sid}

type FetchConversationScopedWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ConversationConversationScopedWebhook
}

// Status returns HTTPResponse.Status
func (r FetchConversationScopedWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchConversationScopedWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchConversationScopedWebhookRequest generates requests for FetchConversationScopedWebhook
func newFetchConversationScopedWebhookRequest(baseURL *url.URL, conversationSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchConversationScopedWebhookFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchConversationScopedWebhook returns a parsed response.
// GET /v1/Conversations/{ConversationSid}/Webhooks/{Sid}
func (c *Client) FetchConversationScopedWebhook(ctx context.Context, conversationSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchConversationScopedWebhookResponse, error) {
	req, err := newFetchConversationScopedWebhookRequest(c.BaseURL, conversationSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchConversationScopedWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ConversationConversationScopedWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateConversationScopedWebhook: POST /v1/Conversations/{ConversationSid}/Webhooks/{Sid}

type UpdateConversationScopedWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ConversationConversationScopedWebhook
}

// Status returns HTTPResponse.Status
func (r UpdateConversationScopedWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConversationScopedWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateConversationScopedWebhookRequestWithBody generates requests for UpdateConversationScopedWebhook with any type of body
func newUpdateConversationScopedWebhookRequestWithBody(baseURL *url.URL, conversationSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateConversationScopedWebhookFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateConversationScopedWebhookWithBody returns a parsed response.
// POST /v1/Conversations/{ConversationSid}/Webhooks/{Sid}
func (c *Client) UpdateConversationScopedWebhookWithBody(ctx context.Context, conversationSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConversationScopedWebhookResponse, error) {
	req, err := newUpdateConversationScopedWebhookRequestWithBody(c.BaseURL, conversationSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateConversationScopedWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ConversationConversationScopedWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteConversation: DELETE /v1/Conversations/{Sid}

type DeleteConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteConversationRequest generates requests for DeleteConversation
func newDeleteConversationRequest(baseURL *url.URL, sid string, params *DeleteConversationParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteConversationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// DeleteConversation returns a parsed response.
// DELETE /v1/Conversations/{Sid}
func (c *Client) DeleteConversation(ctx context.Context, sid string, params *DeleteConversationParams, reqEditors ...client.RequestEditorFn) (*DeleteConversationResponse, error) {
	req, err := newDeleteConversationRequest(c.BaseURL, sid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchConversation: GET /v1/Conversations/{Sid}

type FetchConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1Conversation
}

// Status returns HTTPResponse.Status
func (r FetchConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchConversationRequest generates requests for FetchConversation
func newFetchConversationRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchConversationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchConversation returns a parsed response.
// GET /v1/Conversations/{Sid}
func (c *Client) FetchConversation(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchConversationResponse, error) {
	req, err := newFetchConversationRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1Conversation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateConversation: POST /v1/Conversations/{Sid}

type UpdateConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1Conversation
}

// Status returns HTTPResponse.Status
func (r UpdateConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateConversationRequestWithBody generates requests for UpdateConversation with any type of body
func newUpdateConversationRequestWithBody(baseURL *url.URL, sid string, params *UpdateConversationParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateConversationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// UpdateConversationWithBody returns a parsed response.
// POST /v1/Conversations/{Sid}
func (c *Client) UpdateConversationWithBody(ctx context.Context, sid string, params *UpdateConversationParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConversationResponse, error) {
	req, err := newUpdateConversationRequestWithBody(c.BaseURL, sid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1Conversation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListCredential: GET /v1/Credentials

type ListCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Credentials *[]ConversationsV1Credential `json:"credentials,omitempty"`
		Meta        *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListCredentialRequest generates requests for ListCredential
func newListCredentialRequest(baseURL *url.URL, params *ListCredentialParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListCredential)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListCredential returns a parsed response.
// GET /v1/Credentials
func (c *Client) ListCredential(ctx context.Context, params *ListCredentialParams, reqEditors ...client.RequestEditorFn) (*ListCredentialResponse, error) {
	req, err := newListCredentialRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Credentials *[]ConversationsV1Credential `json:"credentials,omitempty"`
			Meta        *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateCredential: POST /v1/Credentials

type CreateCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ConversationsV1Credential
}

// Status returns HTTPResponse.Status
func (r CreateCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateCredentialRequestWithBody generates requests for CreateCredential with any type of body
func newCreateCredentialRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateCredential)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateCredentialWithBody returns a parsed response.
// POST /v1/Credentials
func (c *Client) CreateCredentialWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCredentialResponse, error) {
	req, err := newCreateCredentialRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ConversationsV1Credential
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteCredential: DELETE /v1/Credentials/{Sid}

type DeleteCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteCredentialRequest generates requests for DeleteCredential
func newDeleteCredentialRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteCredentialFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteCredential returns a parsed response.
// DELETE /v1/Credentials/{Sid}
func (c *Client) DeleteCredential(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCredentialResponse, error) {
	req, err := newDeleteCredentialRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchCredential: GET /v1/Credentials/{Sid}

type FetchCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1Credential
}

// Status returns HTTPResponse.Status
func (r FetchCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchCredentialRequest generates requests for FetchCredential
func newFetchCredentialRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchCredentialFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchCredential returns a parsed response.
// GET /v1/Credentials/{Sid}
func (c *Client) FetchCredential(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchCredentialResponse, error) {
	req, err := newFetchCredentialRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1Credential
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateCredential: POST /v1/Credentials/{Sid}

type UpdateCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1Credential
}

// Status returns HTTPResponse.Status
func (r UpdateCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateCredentialRequestWithBody generates requests for UpdateCredential with any type of body
func newUpdateCredentialRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateCredentialFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateCredentialWithBody returns a parsed response.
// POST /v1/Credentials/{Sid}
func (c *Client) UpdateCredentialWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateCredentialResponse, error) {
	req, err := newUpdateCredentialRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1Credential
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListParticipantConversation: GET /v1/ParticipantConversations

type ListParticipantConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Conversations *[]ConversationsV1ParticipantConversation `json:"conversations,omitempty"`
		Meta          *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListParticipantConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListParticipantConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListParticipantConversationRequest generates requests for ListParticipantConversation
func newListParticipantConversationRequest(baseURL *url.URL, params *ListParticipantConversationParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListParticipantConversation)

	q := queryURL.Query()

	if params.Identity != nil {
		if err := client.AddQueryParam(q, "Identity", *params.Identity); err != nil {
			return nil, err
		}
	}

	if params.Address != nil {
		if err := client.AddQueryParam(q, "Address", *params.Address); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListParticipantConversation returns a parsed response.
// GET /v1/ParticipantConversations
func (c *Client) ListParticipantConversation(ctx context.Context, params *ListParticipantConversationParams, reqEditors ...client.RequestEditorFn) (*ListParticipantConversationResponse, error) {
	req, err := newListParticipantConversationRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListParticipantConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Conversations *[]ConversationsV1ParticipantConversation `json:"conversations,omitempty"`
			Meta          *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListRole: GET /v1/Roles

type ListRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Roles *[]ConversationsV1Role `json:"roles,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListRoleRequest generates requests for ListRole
func newListRoleRequest(baseURL *url.URL, params *ListRoleParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListRole)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListRole returns a parsed response.
// GET /v1/Roles
func (c *Client) ListRole(ctx context.Context, params *ListRoleParams, reqEditors ...client.RequestEditorFn) (*ListRoleResponse, error) {
	req, err := newListRoleRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Roles *[]ConversationsV1Role `json:"roles,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateRole: POST /v1/Roles

type CreateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ConversationsV1Role
}

// Status returns HTTPResponse.Status
func (r CreateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateRoleRequestWithBody generates requests for CreateRole with any type of body
func newCreateRoleRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateRole)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateRoleWithBody returns a parsed response.
// POST /v1/Roles
func (c *Client) CreateRoleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateRoleResponse, error) {
	req, err := newCreateRoleRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ConversationsV1Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteRole: DELETE /v1/Roles/{Sid}

type DeleteRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteRoleRequest generates requests for DeleteRole
func newDeleteRoleRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteRoleFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteRole returns a parsed response.
// DELETE /v1/Roles/{Sid}
func (c *Client) DeleteRole(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteRoleResponse, error) {
	req, err := newDeleteRoleRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchRole: GET /v1/Roles/{Sid}

type FetchRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1Role
}

// Status returns HTTPResponse.Status
func (r FetchRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchRoleRequest generates requests for FetchRole
func newFetchRoleRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchRoleFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchRole returns a parsed response.
// GET /v1/Roles/{Sid}
func (c *Client) FetchRole(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchRoleResponse, error) {
	req, err := newFetchRoleRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateRole: POST /v1/Roles/{Sid}

type UpdateRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1Role
}

// Status returns HTTPResponse.Status
func (r UpdateRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateRoleRequestWithBody generates requests for UpdateRole with any type of body
func newUpdateRoleRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateRoleFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateRoleWithBody returns a parsed response.
// POST /v1/Roles/{Sid}
func (c *Client) UpdateRoleWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateRoleResponse, error) {
	req, err := newUpdateRoleRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1Role
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListService: GET /v1/Services

type ListServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Services *[]ConversationsV1Service `json:"services,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListServiceRequest generates requests for ListService
func newListServiceRequest(baseURL *url.URL, params *ListServiceParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListService)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListService returns a parsed response.
// GET /v1/Services
func (c *Client) ListService(ctx context.Context, params *ListServiceParams, reqEditors ...client.RequestEditorFn) (*ListServiceResponse, error) {
	req, err := newListServiceRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Services *[]ConversationsV1Service `json:"services,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateService: POST /v1/Services

type CreateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ConversationsV1Service
}

// Status returns HTTPResponse.Status
func (r CreateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateServiceRequestWithBody generates requests for CreateService with any type of body
func newCreateServiceRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateService)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateServiceWithBody returns a parsed response.
// POST /v1/Services
func (c *Client) CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceResponse, error) {
	req, err := newCreateServiceRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ConversationsV1Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListServiceBinding: GET /v1/Services/{ChatServiceSid}/Bindings

type ListServiceBindingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Bindings *[]ConversationsV1ServiceServiceBinding `json:"bindings,omitempty"`
		Meta     *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceBindingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceBindingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListServiceBindingRequest generates requests for ListServiceBinding
func newListServiceBindingRequest(baseURL *url.URL, chatServiceSid string, params *ListServiceBindingParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListServiceBindingFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.BindingType != nil {
		if err := client.AddQueryParam(q, "BindingType", *params.BindingType); err != nil {
			return nil, err
		}
	}

	if params.Identity != nil {
		if err := client.AddQueryParam(q, "Identity", *params.Identity); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListServiceBinding returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Bindings
func (c *Client) ListServiceBinding(ctx context.Context, chatServiceSid string, params *ListServiceBindingParams, reqEditors ...client.RequestEditorFn) (*ListServiceBindingResponse, error) {
	req, err := newListServiceBindingRequest(c.BaseURL, chatServiceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListServiceBindingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Bindings *[]ConversationsV1ServiceServiceBinding `json:"bindings,omitempty"`
			Meta     *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteServiceBinding: DELETE /v1/Services/{ChatServiceSid}/Bindings/{Sid}

type DeleteServiceBindingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteServiceBindingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceBindingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteServiceBindingRequest generates requests for DeleteServiceBinding
func newDeleteServiceBindingRequest(baseURL *url.URL, chatServiceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteServiceBindingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteServiceBinding returns a parsed response.
// DELETE /v1/Services/{ChatServiceSid}/Bindings/{Sid}
func (c *Client) DeleteServiceBinding(ctx context.Context, chatServiceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteServiceBindingResponse, error) {
	req, err := newDeleteServiceBindingRequest(c.BaseURL, chatServiceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteServiceBindingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchServiceBinding: GET /v1/Services/{ChatServiceSid}/Bindings/{Sid}

type FetchServiceBindingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceBinding
}

// Status returns HTTPResponse.Status
func (r FetchServiceBindingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchServiceBindingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchServiceBindingRequest generates requests for FetchServiceBinding
func newFetchServiceBindingRequest(baseURL *url.URL, chatServiceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchServiceBindingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchServiceBinding returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Bindings/{Sid}
func (c *Client) FetchServiceBinding(ctx context.Context, chatServiceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceBindingResponse, error) {
	req, err := newFetchServiceBindingRequest(c.BaseURL, chatServiceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchServiceBindingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceBinding
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchServiceConfiguration: GET /v1/Services/{ChatServiceSid}/Configuration

type FetchServiceConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceConfiguration
}

// Status returns HTTPResponse.Status
func (r FetchServiceConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchServiceConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchServiceConfigurationRequest generates requests for FetchServiceConfiguration
func newFetchServiceConfigurationRequest(baseURL *url.URL, chatServiceSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchServiceConfigurationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchServiceConfiguration returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Configuration
func (c *Client) FetchServiceConfiguration(ctx context.Context, chatServiceSid string, reqEditors ...client.RequestEditorFn) (*FetchServiceConfigurationResponse, error) {
	req, err := newFetchServiceConfigurationRequest(c.BaseURL, chatServiceSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchServiceConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateServiceConfiguration: POST /v1/Services/{ChatServiceSid}/Configuration

type UpdateServiceConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceConfiguration
}

// Status returns HTTPResponse.Status
func (r UpdateServiceConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateServiceConfigurationRequestWithBody generates requests for UpdateServiceConfiguration with any type of body
func newUpdateServiceConfigurationRequestWithBody(baseURL *url.URL, chatServiceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateServiceConfigurationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateServiceConfigurationWithBody returns a parsed response.
// POST /v1/Services/{ChatServiceSid}/Configuration
func (c *Client) UpdateServiceConfigurationWithBody(ctx context.Context, chatServiceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceConfigurationResponse, error) {
	req, err := newUpdateServiceConfigurationRequestWithBody(c.BaseURL, chatServiceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateServiceConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchServiceNotification: GET /v1/Services/{ChatServiceSid}/Configuration/Notifications

type FetchServiceNotificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceConfigurationServiceNotification
}

// Status returns HTTPResponse.Status
func (r FetchServiceNotificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchServiceNotificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchServiceNotificationRequest generates requests for FetchServiceNotification
func newFetchServiceNotificationRequest(baseURL *url.URL, chatServiceSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchServiceNotificationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchServiceNotification returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Configuration/Notifications
func (c *Client) FetchServiceNotification(ctx context.Context, chatServiceSid string, reqEditors ...client.RequestEditorFn) (*FetchServiceNotificationResponse, error) {
	req, err := newFetchServiceNotificationRequest(c.BaseURL, chatServiceSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchServiceNotificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceConfigurationServiceNotification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateServiceNotification: POST /v1/Services/{ChatServiceSid}/Configuration/Notifications

type UpdateServiceNotificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceConfigurationServiceNotification
}

// Status returns HTTPResponse.Status
func (r UpdateServiceNotificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceNotificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateServiceNotificationRequestWithBody generates requests for UpdateServiceNotification with any type of body
func newUpdateServiceNotificationRequestWithBody(baseURL *url.URL, chatServiceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateServiceNotificationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateServiceNotificationWithBody returns a parsed response.
// POST /v1/Services/{ChatServiceSid}/Configuration/Notifications
func (c *Client) UpdateServiceNotificationWithBody(ctx context.Context, chatServiceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceNotificationResponse, error) {
	req, err := newUpdateServiceNotificationRequestWithBody(c.BaseURL, chatServiceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateServiceNotificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceConfigurationServiceNotification
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchServiceWebhookConfiguration: GET /v1/Services/{ChatServiceSid}/Configuration/Webhooks

type FetchServiceWebhookConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceConfigurationServiceWebhookConfiguration
}

// Status returns HTTPResponse.Status
func (r FetchServiceWebhookConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchServiceWebhookConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchServiceWebhookConfigurationRequest generates requests for FetchServiceWebhookConfiguration
func newFetchServiceWebhookConfigurationRequest(baseURL *url.URL, chatServiceSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchServiceWebhookConfigurationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchServiceWebhookConfiguration returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Configuration/Webhooks
func (c *Client) FetchServiceWebhookConfiguration(ctx context.Context, chatServiceSid string, reqEditors ...client.RequestEditorFn) (*FetchServiceWebhookConfigurationResponse, error) {
	req, err := newFetchServiceWebhookConfigurationRequest(c.BaseURL, chatServiceSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchServiceWebhookConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceConfigurationServiceWebhookConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateServiceWebhookConfiguration: POST /v1/Services/{ChatServiceSid}/Configuration/Webhooks

type UpdateServiceWebhookConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceConfigurationServiceWebhookConfiguration
}

// Status returns HTTPResponse.Status
func (r UpdateServiceWebhookConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceWebhookConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateServiceWebhookConfigurationRequestWithBody generates requests for UpdateServiceWebhookConfiguration with any type of body
func newUpdateServiceWebhookConfigurationRequestWithBody(baseURL *url.URL, chatServiceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateServiceWebhookConfigurationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateServiceWebhookConfigurationWithBody returns a parsed response.
// POST /v1/Services/{ChatServiceSid}/Configuration/Webhooks
func (c *Client) UpdateServiceWebhookConfigurationWithBody(ctx context.Context, chatServiceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceWebhookConfigurationResponse, error) {
	req, err := newUpdateServiceWebhookConfigurationRequestWithBody(c.BaseURL, chatServiceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateServiceWebhookConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceConfigurationServiceWebhookConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListServiceConversation: GET /v1/Services/{ChatServiceSid}/Conversations

type ListServiceConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Conversations *[]ConversationsV1ServiceServiceConversation `json:"conversations,omitempty"`
		Meta          *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListServiceConversationRequest generates requests for ListServiceConversation
func newListServiceConversationRequest(baseURL *url.URL, chatServiceSid string, params *ListServiceConversationParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListServiceConversationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListServiceConversation returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Conversations
func (c *Client) ListServiceConversation(ctx context.Context, chatServiceSid string, params *ListServiceConversationParams, reqEditors ...client.RequestEditorFn) (*ListServiceConversationResponse, error) {
	req, err := newListServiceConversationRequest(c.BaseURL, chatServiceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListServiceConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Conversations *[]ConversationsV1ServiceServiceConversation `json:"conversations,omitempty"`
			Meta          *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateServiceConversation: POST /v1/Services/{ChatServiceSid}/Conversations

type CreateServiceConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ConversationsV1ServiceServiceConversation
}

// Status returns HTTPResponse.Status
func (r CreateServiceConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateServiceConversationRequestWithBody generates requests for CreateServiceConversation with any type of body
func newCreateServiceConversationRequestWithBody(baseURL *url.URL, chatServiceSid string, params *CreateServiceConversationParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateServiceConversationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// CreateServiceConversationWithBody returns a parsed response.
// POST /v1/Services/{ChatServiceSid}/Conversations
func (c *Client) CreateServiceConversationWithBody(ctx context.Context, chatServiceSid string, params *CreateServiceConversationParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceConversationResponse, error) {
	req, err := newCreateServiceConversationRequestWithBody(c.BaseURL, chatServiceSid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateServiceConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ConversationsV1ServiceServiceConversation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListServiceConversationMessage: GET /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages

type ListServiceConversationMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Messages *[]ConversationsV1ServiceServiceConversationServiceConversationMessage `json:"messages,omitempty"`
		Meta     *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceConversationMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceConversationMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListServiceConversationMessageRequest generates requests for ListServiceConversationMessage
func newListServiceConversationMessageRequest(baseURL *url.URL, chatServiceSid string, conversationSid string, params *ListServiceConversationMessageParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListServiceConversationMessageFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Order != nil {
		if err := client.AddQueryParam(q, "Order", *params.Order); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListServiceConversationMessage returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages
func (c *Client) ListServiceConversationMessage(ctx context.Context, chatServiceSid string, conversationSid string, params *ListServiceConversationMessageParams, reqEditors ...client.RequestEditorFn) (*ListServiceConversationMessageResponse, error) {
	req, err := newListServiceConversationMessageRequest(c.BaseURL, chatServiceSid, conversationSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListServiceConversationMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Messages *[]ConversationsV1ServiceServiceConversationServiceConversationMessage `json:"messages,omitempty"`
			Meta     *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateServiceConversationMessage: POST /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages

type CreateServiceConversationMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ConversationsV1ServiceServiceConversationServiceConversationMessage
}

// Status returns HTTPResponse.Status
func (r CreateServiceConversationMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceConversationMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateServiceConversationMessageRequestWithBody generates requests for CreateServiceConversationMessage with any type of body
func newCreateServiceConversationMessageRequestWithBody(baseURL *url.URL, chatServiceSid string, conversationSid string, params *CreateServiceConversationMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateServiceConversationMessageFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// CreateServiceConversationMessageWithBody returns a parsed response.
// POST /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages
func (c *Client) CreateServiceConversationMessageWithBody(ctx context.Context, chatServiceSid string, conversationSid string, params *CreateServiceConversationMessageParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceConversationMessageResponse, error) {
	req, err := newCreateServiceConversationMessageRequestWithBody(c.BaseURL, chatServiceSid, conversationSid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateServiceConversationMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ConversationsV1ServiceServiceConversationServiceConversationMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListServiceConversationMessageReceipt: GET /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts

type ListServiceConversationMessageReceiptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DeliveryReceipts *[]ConversationsV1ServiceServiceConversationServiceConversationMessageServiceConversationMessageReceipt `json:"delivery_receipts,omitempty"`
		Meta             *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceConversationMessageReceiptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceConversationMessageReceiptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListServiceConversationMessageReceiptRequest generates requests for ListServiceConversationMessageReceipt
func newListServiceConversationMessageReceiptRequest(baseURL *url.URL, chatServiceSid string, conversationSid string, messageSid string, params *ListServiceConversationMessageReceiptParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("MessageSid", messageSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListServiceConversationMessageReceiptFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListServiceConversationMessageReceipt returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts
func (c *Client) ListServiceConversationMessageReceipt(ctx context.Context, chatServiceSid string, conversationSid string, messageSid string, params *ListServiceConversationMessageReceiptParams, reqEditors ...client.RequestEditorFn) (*ListServiceConversationMessageReceiptResponse, error) {
	req, err := newListServiceConversationMessageReceiptRequest(c.BaseURL, chatServiceSid, conversationSid, messageSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListServiceConversationMessageReceiptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DeliveryReceipts *[]ConversationsV1ServiceServiceConversationServiceConversationMessageServiceConversationMessageReceipt `json:"delivery_receipts,omitempty"`
			Meta             *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchServiceConversationMessageReceipt: GET /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts/{Sid}

type FetchServiceConversationMessageReceiptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceConversationServiceConversationMessageServiceConversationMessageReceipt
}

// Status returns HTTPResponse.Status
func (r FetchServiceConversationMessageReceiptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchServiceConversationMessageReceiptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchServiceConversationMessageReceiptRequest generates requests for FetchServiceConversationMessageReceipt
func newFetchServiceConversationMessageReceiptRequest(baseURL *url.URL, chatServiceSid string, conversationSid string, messageSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("MessageSid", messageSid)
	if err != nil {
		return nil, err
	}

	pathParam3, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchServiceConversationMessageReceiptFormat, pathParam0, pathParam1, pathParam2, pathParam3)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchServiceConversationMessageReceipt returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{MessageSid}/Receipts/{Sid}
func (c *Client) FetchServiceConversationMessageReceipt(ctx context.Context, chatServiceSid string, conversationSid string, messageSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceConversationMessageReceiptResponse, error) {
	req, err := newFetchServiceConversationMessageReceiptRequest(c.BaseURL, chatServiceSid, conversationSid, messageSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchServiceConversationMessageReceiptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceConversationServiceConversationMessageServiceConversationMessageReceipt
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteServiceConversationMessage: DELETE /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{Sid}

type DeleteServiceConversationMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteServiceConversationMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceConversationMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteServiceConversationMessageRequest generates requests for DeleteServiceConversationMessage
func newDeleteServiceConversationMessageRequest(baseURL *url.URL, chatServiceSid string, conversationSid string, sid string, params *DeleteServiceConversationMessageParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteServiceConversationMessageFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// DeleteServiceConversationMessage returns a parsed response.
// DELETE /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{Sid}
func (c *Client) DeleteServiceConversationMessage(ctx context.Context, chatServiceSid string, conversationSid string, sid string, params *DeleteServiceConversationMessageParams, reqEditors ...client.RequestEditorFn) (*DeleteServiceConversationMessageResponse, error) {
	req, err := newDeleteServiceConversationMessageRequest(c.BaseURL, chatServiceSid, conversationSid, sid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteServiceConversationMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchServiceConversationMessage: GET /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{Sid}

type FetchServiceConversationMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceConversationServiceConversationMessage
}

// Status returns HTTPResponse.Status
func (r FetchServiceConversationMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchServiceConversationMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchServiceConversationMessageRequest generates requests for FetchServiceConversationMessage
func newFetchServiceConversationMessageRequest(baseURL *url.URL, chatServiceSid string, conversationSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchServiceConversationMessageFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchServiceConversationMessage returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{Sid}
func (c *Client) FetchServiceConversationMessage(ctx context.Context, chatServiceSid string, conversationSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceConversationMessageResponse, error) {
	req, err := newFetchServiceConversationMessageRequest(c.BaseURL, chatServiceSid, conversationSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchServiceConversationMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceConversationServiceConversationMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateServiceConversationMessage: POST /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{Sid}

type UpdateServiceConversationMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceConversationServiceConversationMessage
}

// Status returns HTTPResponse.Status
func (r UpdateServiceConversationMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceConversationMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateServiceConversationMessageRequestWithBody generates requests for UpdateServiceConversationMessage with any type of body
func newUpdateServiceConversationMessageRequestWithBody(baseURL *url.URL, chatServiceSid string, conversationSid string, sid string, params *UpdateServiceConversationMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateServiceConversationMessageFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// UpdateServiceConversationMessageWithBody returns a parsed response.
// POST /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Messages/{Sid}
func (c *Client) UpdateServiceConversationMessageWithBody(ctx context.Context, chatServiceSid string, conversationSid string, sid string, params *UpdateServiceConversationMessageParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceConversationMessageResponse, error) {
	req, err := newUpdateServiceConversationMessageRequestWithBody(c.BaseURL, chatServiceSid, conversationSid, sid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateServiceConversationMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceConversationServiceConversationMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListServiceConversationParticipant: GET /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants

type ListServiceConversationParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Participants *[]ConversationsV1ServiceServiceConversationServiceConversationParticipant `json:"participants,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceConversationParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceConversationParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListServiceConversationParticipantRequest generates requests for ListServiceConversationParticipant
func newListServiceConversationParticipantRequest(baseURL *url.URL, chatServiceSid string, conversationSid string, params *ListServiceConversationParticipantParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListServiceConversationParticipantFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListServiceConversationParticipant returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants
func (c *Client) ListServiceConversationParticipant(ctx context.Context, chatServiceSid string, conversationSid string, params *ListServiceConversationParticipantParams, reqEditors ...client.RequestEditorFn) (*ListServiceConversationParticipantResponse, error) {
	req, err := newListServiceConversationParticipantRequest(c.BaseURL, chatServiceSid, conversationSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListServiceConversationParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Participants *[]ConversationsV1ServiceServiceConversationServiceConversationParticipant `json:"participants,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateServiceConversationParticipant: POST /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants

type CreateServiceConversationParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ConversationsV1ServiceServiceConversationServiceConversationParticipant
}

// Status returns HTTPResponse.Status
func (r CreateServiceConversationParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceConversationParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateServiceConversationParticipantRequestWithBody generates requests for CreateServiceConversationParticipant with any type of body
func newCreateServiceConversationParticipantRequestWithBody(baseURL *url.URL, chatServiceSid string, conversationSid string, params *CreateServiceConversationParticipantParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateServiceConversationParticipantFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// CreateServiceConversationParticipantWithBody returns a parsed response.
// POST /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants
func (c *Client) CreateServiceConversationParticipantWithBody(ctx context.Context, chatServiceSid string, conversationSid string, params *CreateServiceConversationParticipantParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceConversationParticipantResponse, error) {
	req, err := newCreateServiceConversationParticipantRequestWithBody(c.BaseURL, chatServiceSid, conversationSid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateServiceConversationParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ConversationsV1ServiceServiceConversationServiceConversationParticipant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteServiceConversationParticipant: DELETE /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants/{Sid}

type DeleteServiceConversationParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteServiceConversationParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceConversationParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteServiceConversationParticipantRequest generates requests for DeleteServiceConversationParticipant
func newDeleteServiceConversationParticipantRequest(baseURL *url.URL, chatServiceSid string, conversationSid string, sid string, params *DeleteServiceConversationParticipantParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteServiceConversationParticipantFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// DeleteServiceConversationParticipant returns a parsed response.
// DELETE /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants/{Sid}
func (c *Client) DeleteServiceConversationParticipant(ctx context.Context, chatServiceSid string, conversationSid string, sid string, params *DeleteServiceConversationParticipantParams, reqEditors ...client.RequestEditorFn) (*DeleteServiceConversationParticipantResponse, error) {
	req, err := newDeleteServiceConversationParticipantRequest(c.BaseURL, chatServiceSid, conversationSid, sid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteServiceConversationParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchServiceConversationParticipant: GET /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants/{Sid}

type FetchServiceConversationParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceConversationServiceConversationParticipant
}

// Status returns HTTPResponse.Status
func (r FetchServiceConversationParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchServiceConversationParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchServiceConversationParticipantRequest generates requests for FetchServiceConversationParticipant
func newFetchServiceConversationParticipantRequest(baseURL *url.URL, chatServiceSid string, conversationSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchServiceConversationParticipantFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchServiceConversationParticipant returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants/{Sid}
func (c *Client) FetchServiceConversationParticipant(ctx context.Context, chatServiceSid string, conversationSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceConversationParticipantResponse, error) {
	req, err := newFetchServiceConversationParticipantRequest(c.BaseURL, chatServiceSid, conversationSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchServiceConversationParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceConversationServiceConversationParticipant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateServiceConversationParticipant: POST /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants/{Sid}

type UpdateServiceConversationParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceConversationServiceConversationParticipant
}

// Status returns HTTPResponse.Status
func (r UpdateServiceConversationParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceConversationParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateServiceConversationParticipantRequestWithBody generates requests for UpdateServiceConversationParticipant with any type of body
func newUpdateServiceConversationParticipantRequestWithBody(baseURL *url.URL, chatServiceSid string, conversationSid string, sid string, params *UpdateServiceConversationParticipantParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateServiceConversationParticipantFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// UpdateServiceConversationParticipantWithBody returns a parsed response.
// POST /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Participants/{Sid}
func (c *Client) UpdateServiceConversationParticipantWithBody(ctx context.Context, chatServiceSid string, conversationSid string, sid string, params *UpdateServiceConversationParticipantParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceConversationParticipantResponse, error) {
	req, err := newUpdateServiceConversationParticipantRequestWithBody(c.BaseURL, chatServiceSid, conversationSid, sid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateServiceConversationParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceConversationServiceConversationParticipant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListServiceConversationScopedWebhook: GET /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks

type ListServiceConversationScopedWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Webhooks *[]ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook `json:"webhooks,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceConversationScopedWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceConversationScopedWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListServiceConversationScopedWebhookRequest generates requests for ListServiceConversationScopedWebhook
func newListServiceConversationScopedWebhookRequest(baseURL *url.URL, chatServiceSid string, conversationSid string, params *ListServiceConversationScopedWebhookParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListServiceConversationScopedWebhookFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListServiceConversationScopedWebhook returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks
func (c *Client) ListServiceConversationScopedWebhook(ctx context.Context, chatServiceSid string, conversationSid string, params *ListServiceConversationScopedWebhookParams, reqEditors ...client.RequestEditorFn) (*ListServiceConversationScopedWebhookResponse, error) {
	req, err := newListServiceConversationScopedWebhookRequest(c.BaseURL, chatServiceSid, conversationSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListServiceConversationScopedWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Webhooks *[]ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook `json:"webhooks,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateServiceConversationScopedWebhook: POST /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks

type CreateServiceConversationScopedWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook
}

// Status returns HTTPResponse.Status
func (r CreateServiceConversationScopedWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceConversationScopedWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateServiceConversationScopedWebhookRequestWithBody generates requests for CreateServiceConversationScopedWebhook with any type of body
func newCreateServiceConversationScopedWebhookRequestWithBody(baseURL *url.URL, chatServiceSid string, conversationSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateServiceConversationScopedWebhookFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateServiceConversationScopedWebhookWithBody returns a parsed response.
// POST /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks
func (c *Client) CreateServiceConversationScopedWebhookWithBody(ctx context.Context, chatServiceSid string, conversationSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceConversationScopedWebhookResponse, error) {
	req, err := newCreateServiceConversationScopedWebhookRequestWithBody(c.BaseURL, chatServiceSid, conversationSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateServiceConversationScopedWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteServiceConversationScopedWebhook: DELETE /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks/{Sid}

type DeleteServiceConversationScopedWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteServiceConversationScopedWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceConversationScopedWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteServiceConversationScopedWebhookRequest generates requests for DeleteServiceConversationScopedWebhook
func newDeleteServiceConversationScopedWebhookRequest(baseURL *url.URL, chatServiceSid string, conversationSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteServiceConversationScopedWebhookFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteServiceConversationScopedWebhook returns a parsed response.
// DELETE /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks/{Sid}
func (c *Client) DeleteServiceConversationScopedWebhook(ctx context.Context, chatServiceSid string, conversationSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteServiceConversationScopedWebhookResponse, error) {
	req, err := newDeleteServiceConversationScopedWebhookRequest(c.BaseURL, chatServiceSid, conversationSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteServiceConversationScopedWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchServiceConversationScopedWebhook: GET /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks/{Sid}

type FetchServiceConversationScopedWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook
}

// Status returns HTTPResponse.Status
func (r FetchServiceConversationScopedWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchServiceConversationScopedWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchServiceConversationScopedWebhookRequest generates requests for FetchServiceConversationScopedWebhook
func newFetchServiceConversationScopedWebhookRequest(baseURL *url.URL, chatServiceSid string, conversationSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchServiceConversationScopedWebhookFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchServiceConversationScopedWebhook returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks/{Sid}
func (c *Client) FetchServiceConversationScopedWebhook(ctx context.Context, chatServiceSid string, conversationSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceConversationScopedWebhookResponse, error) {
	req, err := newFetchServiceConversationScopedWebhookRequest(c.BaseURL, chatServiceSid, conversationSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchServiceConversationScopedWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateServiceConversationScopedWebhook: POST /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks/{Sid}

type UpdateServiceConversationScopedWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook
}

// Status returns HTTPResponse.Status
func (r UpdateServiceConversationScopedWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceConversationScopedWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateServiceConversationScopedWebhookRequestWithBody generates requests for UpdateServiceConversationScopedWebhook with any type of body
func newUpdateServiceConversationScopedWebhookRequestWithBody(baseURL *url.URL, chatServiceSid string, conversationSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateServiceConversationScopedWebhookFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateServiceConversationScopedWebhookWithBody returns a parsed response.
// POST /v1/Services/{ChatServiceSid}/Conversations/{ConversationSid}/Webhooks/{Sid}
func (c *Client) UpdateServiceConversationScopedWebhookWithBody(ctx context.Context, chatServiceSid string, conversationSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceConversationScopedWebhookResponse, error) {
	req, err := newUpdateServiceConversationScopedWebhookRequestWithBody(c.BaseURL, chatServiceSid, conversationSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateServiceConversationScopedWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteServiceConversation: DELETE /v1/Services/{ChatServiceSid}/Conversations/{Sid}

type DeleteServiceConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteServiceConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteServiceConversationRequest generates requests for DeleteServiceConversation
func newDeleteServiceConversationRequest(baseURL *url.URL, chatServiceSid string, sid string, params *DeleteServiceConversationParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteServiceConversationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// DeleteServiceConversation returns a parsed response.
// DELETE /v1/Services/{ChatServiceSid}/Conversations/{Sid}
func (c *Client) DeleteServiceConversation(ctx context.Context, chatServiceSid string, sid string, params *DeleteServiceConversationParams, reqEditors ...client.RequestEditorFn) (*DeleteServiceConversationResponse, error) {
	req, err := newDeleteServiceConversationRequest(c.BaseURL, chatServiceSid, sid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteServiceConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchServiceConversation: GET /v1/Services/{ChatServiceSid}/Conversations/{Sid}

type FetchServiceConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceConversation
}

// Status returns HTTPResponse.Status
func (r FetchServiceConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchServiceConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchServiceConversationRequest generates requests for FetchServiceConversation
func newFetchServiceConversationRequest(baseURL *url.URL, chatServiceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchServiceConversationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchServiceConversation returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Conversations/{Sid}
func (c *Client) FetchServiceConversation(ctx context.Context, chatServiceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceConversationResponse, error) {
	req, err := newFetchServiceConversationRequest(c.BaseURL, chatServiceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchServiceConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceConversation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateServiceConversation: POST /v1/Services/{ChatServiceSid}/Conversations/{Sid}

type UpdateServiceConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceConversation
}

// Status returns HTTPResponse.Status
func (r UpdateServiceConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateServiceConversationRequestWithBody generates requests for UpdateServiceConversation with any type of body
func newUpdateServiceConversationRequestWithBody(baseURL *url.URL, chatServiceSid string, sid string, params *UpdateServiceConversationParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateServiceConversationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// UpdateServiceConversationWithBody returns a parsed response.
// POST /v1/Services/{ChatServiceSid}/Conversations/{Sid}
func (c *Client) UpdateServiceConversationWithBody(ctx context.Context, chatServiceSid string, sid string, params *UpdateServiceConversationParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceConversationResponse, error) {
	req, err := newUpdateServiceConversationRequestWithBody(c.BaseURL, chatServiceSid, sid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateServiceConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceConversation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListServiceParticipantConversation: GET /v1/Services/{ChatServiceSid}/ParticipantConversations

type ListServiceParticipantConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Conversations *[]ConversationsV1ServiceServiceParticipantConversation `json:"conversations,omitempty"`
		Meta          *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceParticipantConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceParticipantConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListServiceParticipantConversationRequest generates requests for ListServiceParticipantConversation
func newListServiceParticipantConversationRequest(baseURL *url.URL, chatServiceSid string, params *ListServiceParticipantConversationParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListServiceParticipantConversationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Identity != nil {
		if err := client.AddQueryParam(q, "Identity", *params.Identity); err != nil {
			return nil, err
		}
	}

	if params.Address != nil {
		if err := client.AddQueryParam(q, "Address", *params.Address); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListServiceParticipantConversation returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/ParticipantConversations
func (c *Client) ListServiceParticipantConversation(ctx context.Context, chatServiceSid string, params *ListServiceParticipantConversationParams, reqEditors ...client.RequestEditorFn) (*ListServiceParticipantConversationResponse, error) {
	req, err := newListServiceParticipantConversationRequest(c.BaseURL, chatServiceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListServiceParticipantConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Conversations *[]ConversationsV1ServiceServiceParticipantConversation `json:"conversations,omitempty"`
			Meta          *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListServiceRole: GET /v1/Services/{ChatServiceSid}/Roles

type ListServiceRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Roles *[]ConversationsV1ServiceServiceRole `json:"roles,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListServiceRoleRequest generates requests for ListServiceRole
func newListServiceRoleRequest(baseURL *url.URL, chatServiceSid string, params *ListServiceRoleParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListServiceRoleFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListServiceRole returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Roles
func (c *Client) ListServiceRole(ctx context.Context, chatServiceSid string, params *ListServiceRoleParams, reqEditors ...client.RequestEditorFn) (*ListServiceRoleResponse, error) {
	req, err := newListServiceRoleRequest(c.BaseURL, chatServiceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListServiceRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Roles *[]ConversationsV1ServiceServiceRole `json:"roles,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateServiceRole: POST /v1/Services/{ChatServiceSid}/Roles

type CreateServiceRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ConversationsV1ServiceServiceRole
}

// Status returns HTTPResponse.Status
func (r CreateServiceRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateServiceRoleRequestWithBody generates requests for CreateServiceRole with any type of body
func newCreateServiceRoleRequestWithBody(baseURL *url.URL, chatServiceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateServiceRoleFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateServiceRoleWithBody returns a parsed response.
// POST /v1/Services/{ChatServiceSid}/Roles
func (c *Client) CreateServiceRoleWithBody(ctx context.Context, chatServiceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceRoleResponse, error) {
	req, err := newCreateServiceRoleRequestWithBody(c.BaseURL, chatServiceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateServiceRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ConversationsV1ServiceServiceRole
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteServiceRole: DELETE /v1/Services/{ChatServiceSid}/Roles/{Sid}

type DeleteServiceRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteServiceRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteServiceRoleRequest generates requests for DeleteServiceRole
func newDeleteServiceRoleRequest(baseURL *url.URL, chatServiceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteServiceRoleFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteServiceRole returns a parsed response.
// DELETE /v1/Services/{ChatServiceSid}/Roles/{Sid}
func (c *Client) DeleteServiceRole(ctx context.Context, chatServiceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteServiceRoleResponse, error) {
	req, err := newDeleteServiceRoleRequest(c.BaseURL, chatServiceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteServiceRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchServiceRole: GET /v1/Services/{ChatServiceSid}/Roles/{Sid}

type FetchServiceRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceRole
}

// Status returns HTTPResponse.Status
func (r FetchServiceRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchServiceRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchServiceRoleRequest generates requests for FetchServiceRole
func newFetchServiceRoleRequest(baseURL *url.URL, chatServiceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchServiceRoleFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchServiceRole returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Roles/{Sid}
func (c *Client) FetchServiceRole(ctx context.Context, chatServiceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceRoleResponse, error) {
	req, err := newFetchServiceRoleRequest(c.BaseURL, chatServiceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchServiceRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceRole
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateServiceRole: POST /v1/Services/{ChatServiceSid}/Roles/{Sid}

type UpdateServiceRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceRole
}

// Status returns HTTPResponse.Status
func (r UpdateServiceRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateServiceRoleRequestWithBody generates requests for UpdateServiceRole with any type of body
func newUpdateServiceRoleRequestWithBody(baseURL *url.URL, chatServiceSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateServiceRoleFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateServiceRoleWithBody returns a parsed response.
// POST /v1/Services/{ChatServiceSid}/Roles/{Sid}
func (c *Client) UpdateServiceRoleWithBody(ctx context.Context, chatServiceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceRoleResponse, error) {
	req, err := newUpdateServiceRoleRequestWithBody(c.BaseURL, chatServiceSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateServiceRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceRole
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListServiceUser: GET /v1/Services/{ChatServiceSid}/Users

type ListServiceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Users *[]ConversationsV1ServiceServiceUser `json:"users,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListServiceUserRequest generates requests for ListServiceUser
func newListServiceUserRequest(baseURL *url.URL, chatServiceSid string, params *ListServiceUserParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListServiceUserFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListServiceUser returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Users
func (c *Client) ListServiceUser(ctx context.Context, chatServiceSid string, params *ListServiceUserParams, reqEditors ...client.RequestEditorFn) (*ListServiceUserResponse, error) {
	req, err := newListServiceUserRequest(c.BaseURL, chatServiceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListServiceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Users *[]ConversationsV1ServiceServiceUser `json:"users,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateServiceUser: POST /v1/Services/{ChatServiceSid}/Users

type CreateServiceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ConversationsV1ServiceServiceUser
}

// Status returns HTTPResponse.Status
func (r CreateServiceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateServiceUserRequestWithBody generates requests for CreateServiceUser with any type of body
func newCreateServiceUserRequestWithBody(baseURL *url.URL, chatServiceSid string, params *CreateServiceUserParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateServiceUserFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// CreateServiceUserWithBody returns a parsed response.
// POST /v1/Services/{ChatServiceSid}/Users
func (c *Client) CreateServiceUserWithBody(ctx context.Context, chatServiceSid string, params *CreateServiceUserParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceUserResponse, error) {
	req, err := newCreateServiceUserRequestWithBody(c.BaseURL, chatServiceSid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateServiceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ConversationsV1ServiceServiceUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteServiceUser: DELETE /v1/Services/{ChatServiceSid}/Users/{Sid}

type DeleteServiceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteServiceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteServiceUserRequest generates requests for DeleteServiceUser
func newDeleteServiceUserRequest(baseURL *url.URL, chatServiceSid string, sid string, params *DeleteServiceUserParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteServiceUserFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// DeleteServiceUser returns a parsed response.
// DELETE /v1/Services/{ChatServiceSid}/Users/{Sid}
func (c *Client) DeleteServiceUser(ctx context.Context, chatServiceSid string, sid string, params *DeleteServiceUserParams, reqEditors ...client.RequestEditorFn) (*DeleteServiceUserResponse, error) {
	req, err := newDeleteServiceUserRequest(c.BaseURL, chatServiceSid, sid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteServiceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchServiceUser: GET /v1/Services/{ChatServiceSid}/Users/{Sid}

type FetchServiceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceUser
}

// Status returns HTTPResponse.Status
func (r FetchServiceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchServiceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchServiceUserRequest generates requests for FetchServiceUser
func newFetchServiceUserRequest(baseURL *url.URL, chatServiceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchServiceUserFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchServiceUser returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Users/{Sid}
func (c *Client) FetchServiceUser(ctx context.Context, chatServiceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceUserResponse, error) {
	req, err := newFetchServiceUserRequest(c.BaseURL, chatServiceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchServiceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateServiceUser: POST /v1/Services/{ChatServiceSid}/Users/{Sid}

type UpdateServiceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceUser
}

// Status returns HTTPResponse.Status
func (r UpdateServiceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateServiceUserRequestWithBody generates requests for UpdateServiceUser with any type of body
func newUpdateServiceUserRequestWithBody(baseURL *url.URL, chatServiceSid string, sid string, params *UpdateServiceUserParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateServiceUserFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// UpdateServiceUserWithBody returns a parsed response.
// POST /v1/Services/{ChatServiceSid}/Users/{Sid}
func (c *Client) UpdateServiceUserWithBody(ctx context.Context, chatServiceSid string, sid string, params *UpdateServiceUserParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceUserResponse, error) {
	req, err := newUpdateServiceUserRequestWithBody(c.BaseURL, chatServiceSid, sid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateServiceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListServiceUserConversation: GET /v1/Services/{ChatServiceSid}/Users/{UserSid}/Conversations

type ListServiceUserConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Conversations *[]ConversationsV1ServiceServiceUserServiceUserConversation `json:"conversations,omitempty"`
		Meta          *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceUserConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceUserConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListServiceUserConversationRequest generates requests for ListServiceUserConversation
func newListServiceUserConversationRequest(baseURL *url.URL, chatServiceSid string, userSid string, params *ListServiceUserConversationParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("UserSid", userSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListServiceUserConversationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListServiceUserConversation returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Users/{UserSid}/Conversations
func (c *Client) ListServiceUserConversation(ctx context.Context, chatServiceSid string, userSid string, params *ListServiceUserConversationParams, reqEditors ...client.RequestEditorFn) (*ListServiceUserConversationResponse, error) {
	req, err := newListServiceUserConversationRequest(c.BaseURL, chatServiceSid, userSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListServiceUserConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Conversations *[]ConversationsV1ServiceServiceUserServiceUserConversation `json:"conversations,omitempty"`
			Meta          *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteServiceUserConversation: DELETE /v1/Services/{ChatServiceSid}/Users/{UserSid}/Conversations/{ConversationSid}

type DeleteServiceUserConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteServiceUserConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceUserConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteServiceUserConversationRequest generates requests for DeleteServiceUserConversation
func newDeleteServiceUserConversationRequest(baseURL *url.URL, chatServiceSid string, userSid string, conversationSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("UserSid", userSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteServiceUserConversationFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteServiceUserConversation returns a parsed response.
// DELETE /v1/Services/{ChatServiceSid}/Users/{UserSid}/Conversations/{ConversationSid}
func (c *Client) DeleteServiceUserConversation(ctx context.Context, chatServiceSid string, userSid string, conversationSid string, reqEditors ...client.RequestEditorFn) (*DeleteServiceUserConversationResponse, error) {
	req, err := newDeleteServiceUserConversationRequest(c.BaseURL, chatServiceSid, userSid, conversationSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteServiceUserConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchServiceUserConversation: GET /v1/Services/{ChatServiceSid}/Users/{UserSid}/Conversations/{ConversationSid}

type FetchServiceUserConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceUserServiceUserConversation
}

// Status returns HTTPResponse.Status
func (r FetchServiceUserConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchServiceUserConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchServiceUserConversationRequest generates requests for FetchServiceUserConversation
func newFetchServiceUserConversationRequest(baseURL *url.URL, chatServiceSid string, userSid string, conversationSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("UserSid", userSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchServiceUserConversationFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchServiceUserConversation returns a parsed response.
// GET /v1/Services/{ChatServiceSid}/Users/{UserSid}/Conversations/{ConversationSid}
func (c *Client) FetchServiceUserConversation(ctx context.Context, chatServiceSid string, userSid string, conversationSid string, reqEditors ...client.RequestEditorFn) (*FetchServiceUserConversationResponse, error) {
	req, err := newFetchServiceUserConversationRequest(c.BaseURL, chatServiceSid, userSid, conversationSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchServiceUserConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceUserServiceUserConversation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateServiceUserConversation: POST /v1/Services/{ChatServiceSid}/Users/{UserSid}/Conversations/{ConversationSid}

type UpdateServiceUserConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1ServiceServiceUserServiceUserConversation
}

// Status returns HTTPResponse.Status
func (r UpdateServiceUserConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceUserConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateServiceUserConversationRequestWithBody generates requests for UpdateServiceUserConversation with any type of body
func newUpdateServiceUserConversationRequestWithBody(baseURL *url.URL, chatServiceSid string, userSid string, conversationSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ChatServiceSid", chatServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("UserSid", userSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateServiceUserConversationFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateServiceUserConversationWithBody returns a parsed response.
// POST /v1/Services/{ChatServiceSid}/Users/{UserSid}/Conversations/{ConversationSid}
func (c *Client) UpdateServiceUserConversationWithBody(ctx context.Context, chatServiceSid string, userSid string, conversationSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceUserConversationResponse, error) {
	req, err := newUpdateServiceUserConversationRequestWithBody(c.BaseURL, chatServiceSid, userSid, conversationSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateServiceUserConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1ServiceServiceUserServiceUserConversation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteService: DELETE /v1/Services/{Sid}

type DeleteServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteServiceRequest generates requests for DeleteService
func newDeleteServiceRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteServiceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteService returns a parsed response.
// DELETE /v1/Services/{Sid}
func (c *Client) DeleteService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteServiceResponse, error) {
	req, err := newDeleteServiceRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchService: GET /v1/Services/{Sid}

type FetchServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1Service
}

// Status returns HTTPResponse.Status
func (r FetchServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchServiceRequest generates requests for FetchService
func newFetchServiceRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchServiceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchService returns a parsed response.
// GET /v1/Services/{Sid}
func (c *Client) FetchService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceResponse, error) {
	req, err := newFetchServiceRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListUser: GET /v1/Users

type ListUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Users *[]ConversationsV1User `json:"users,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListUserRequest generates requests for ListUser
func newListUserRequest(baseURL *url.URL, params *ListUserParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListUser)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListUser returns a parsed response.
// GET /v1/Users
func (c *Client) ListUser(ctx context.Context, params *ListUserParams, reqEditors ...client.RequestEditorFn) (*ListUserResponse, error) {
	req, err := newListUserRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Users *[]ConversationsV1User `json:"users,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateUser: POST /v1/Users

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ConversationsV1User
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateUserRequestWithBody generates requests for CreateUser with any type of body
func newCreateUserRequestWithBody(baseURL *url.URL, params *CreateUserParams, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateUser)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// CreateUserWithBody returns a parsed response.
// POST /v1/Users
func (c *Client) CreateUserWithBody(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateUserResponse, error) {
	req, err := newCreateUserRequestWithBody(c.BaseURL, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ConversationsV1User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteUser: DELETE /v1/Users/{Sid}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteUserRequest generates requests for DeleteUser
func newDeleteUserRequest(baseURL *url.URL, sid string, params *DeleteUserParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteUserFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// DeleteUser returns a parsed response.
// DELETE /v1/Users/{Sid}
func (c *Client) DeleteUser(ctx context.Context, sid string, params *DeleteUserParams, reqEditors ...client.RequestEditorFn) (*DeleteUserResponse, error) {
	req, err := newDeleteUserRequest(c.BaseURL, sid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchUser: GET /v1/Users/{Sid}

type FetchUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1User
}

// Status returns HTTPResponse.Status
func (r FetchUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchUserRequest generates requests for FetchUser
func newFetchUserRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchUserFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchUser returns a parsed response.
// GET /v1/Users/{Sid}
func (c *Client) FetchUser(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchUserResponse, error) {
	req, err := newFetchUserRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateUser: POST /v1/Users/{Sid}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1User
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func newUpdateUserRequestWithBody(baseURL *url.URL, sid string, params *UpdateUserParams, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateUserFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	if params.XTwilioWebhookEnabled != nil {
		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Twilio-Webhook-Enabled", runtime.ParamLocationHeader, *params.XTwilioWebhookEnabled)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-Twilio-Webhook-Enabled", headerParam0)
	}

	return req, nil
}

// UpdateUserWithBody returns a parsed response.
// POST /v1/Users/{Sid}
func (c *Client) UpdateUserWithBody(ctx context.Context, sid string, params *UpdateUserParams, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateUserResponse, error) {
	req, err := newUpdateUserRequestWithBody(c.BaseURL, sid, params, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListUserConversation: GET /v1/Users/{UserSid}/Conversations

type ListUserConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Conversations *[]ConversationsV1UserUserConversation `json:"conversations,omitempty"`
		Meta          *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUserConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListUserConversationRequest generates requests for ListUserConversation
func newListUserConversationRequest(baseURL *url.URL, userSid string, params *ListUserConversationParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("UserSid", userSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListUserConversationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListUserConversation returns a parsed response.
// GET /v1/Users/{UserSid}/Conversations
func (c *Client) ListUserConversation(ctx context.Context, userSid string, params *ListUserConversationParams, reqEditors ...client.RequestEditorFn) (*ListUserConversationResponse, error) {
	req, err := newListUserConversationRequest(c.BaseURL, userSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListUserConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Conversations *[]ConversationsV1UserUserConversation `json:"conversations,omitempty"`
			Meta          *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteUserConversation: DELETE /v1/Users/{UserSid}/Conversations/{ConversationSid}

type DeleteUserConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteUserConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteUserConversationRequest generates requests for DeleteUserConversation
func newDeleteUserConversationRequest(baseURL *url.URL, userSid string, conversationSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("UserSid", userSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteUserConversationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteUserConversation returns a parsed response.
// DELETE /v1/Users/{UserSid}/Conversations/{ConversationSid}
func (c *Client) DeleteUserConversation(ctx context.Context, userSid string, conversationSid string, reqEditors ...client.RequestEditorFn) (*DeleteUserConversationResponse, error) {
	req, err := newDeleteUserConversationRequest(c.BaseURL, userSid, conversationSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteUserConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchUserConversation: GET /v1/Users/{UserSid}/Conversations/{ConversationSid}

type FetchUserConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1UserUserConversation
}

// Status returns HTTPResponse.Status
func (r FetchUserConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchUserConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchUserConversationRequest generates requests for FetchUserConversation
func newFetchUserConversationRequest(baseURL *url.URL, userSid string, conversationSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("UserSid", userSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchUserConversationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchUserConversation returns a parsed response.
// GET /v1/Users/{UserSid}/Conversations/{ConversationSid}
func (c *Client) FetchUserConversation(ctx context.Context, userSid string, conversationSid string, reqEditors ...client.RequestEditorFn) (*FetchUserConversationResponse, error) {
	req, err := newFetchUserConversationRequest(c.BaseURL, userSid, conversationSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchUserConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1UserUserConversation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateUserConversation: POST /v1/Users/{UserSid}/Conversations/{ConversationSid}

type UpdateUserConversationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConversationsV1UserUserConversation
}

// Status returns HTTPResponse.Status
func (r UpdateUserConversationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserConversationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateUserConversationRequestWithBody generates requests for UpdateUserConversation with any type of body
func newUpdateUserConversationRequestWithBody(baseURL *url.URL, userSid string, conversationSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("UserSid", userSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConversationSid", conversationSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateUserConversationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateUserConversationWithBody returns a parsed response.
// POST /v1/Users/{UserSid}/Conversations/{ConversationSid}
func (c *Client) UpdateUserConversationWithBody(ctx context.Context, userSid string, conversationSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateUserConversationResponse, error) {
	req, err := newUpdateUserConversationRequestWithBody(c.BaseURL, userSid, conversationSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateUserConversationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConversationsV1UserUserConversation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
