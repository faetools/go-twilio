// Package messaging provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package messaging

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/faetools/client"
)

// operation paths

const (
	opPathListUsAppToPersonFormat         = "./v1/Services/%s/Compliance/Usa2p"
	opPathCreateUsAppToPersonFormat       = "./v1/Services/%s/Compliance/Usa2p"
	opPathFetchUsAppToPersonUsecaseFormat = "./v1/Services/%s/Compliance/Usa2p/Usecases"
	opPathDeleteUsAppToPersonFormat       = "./v1/Services/%s/Compliance/Usa2p/%s"
	opPathFetchUsAppToPersonFormat        = "./v1/Services/%s/Compliance/Usa2p/%s"
	opPathListAlphaSenderFormat           = "./v1/Services/%s/AlphaSenders"
	opPathCreateAlphaSenderFormat         = "./v1/Services/%s/AlphaSenders"
	opPathDeleteAlphaSenderFormat         = "./v1/Services/%s/AlphaSenders/%s"
	opPathFetchAlphaSenderFormat          = "./v1/Services/%s/AlphaSenders/%s"
	opPathListPhoneNumberFormat           = "./v1/Services/%s/PhoneNumbers"
	opPathCreatePhoneNumberFormat         = "./v1/Services/%s/PhoneNumbers"
	opPathDeletePhoneNumberFormat         = "./v1/Services/%s/PhoneNumbers/%s"
	opPathFetchPhoneNumberFormat          = "./v1/Services/%s/PhoneNumbers/%s"
	opPathListShortCodeFormat             = "./v1/Services/%s/ShortCodes"
	opPathCreateShortCodeFormat           = "./v1/Services/%s/ShortCodes"
	opPathDeleteShortCodeFormat           = "./v1/Services/%s/ShortCodes/%s"
	opPathFetchShortCodeFormat            = "./v1/Services/%s/ShortCodes/%s"
	opPathDeleteServiceFormat             = "./v1/Services/%s"
	opPathFetchServiceFormat              = "./v1/Services/%s"
	opPathUpdateServiceFormat             = "./v1/Services/%s"
	opPathListBrandVettingFormat          = "./v1/a2p/BrandRegistrations/%s/Vettings"
	opPathCreateBrandVettingFormat        = "./v1/a2p/BrandRegistrations/%s/Vettings"
	opPathFetchBrandVettingFormat         = "./v1/a2p/BrandRegistrations/%s/Vettings/%s"
	opPathFetchBrandRegistrationsFormat   = "./v1/a2p/BrandRegistrations/%s"
	opPathUpdateBrandRegistrationsFormat  = "./v1/a2p/BrandRegistrations/%s"
)

var (
	opPathFetchDeactivation        = client.MustParseURL("./v1/Deactivations")
	opPathListService              = client.MustParseURL("./v1/Services")
	opPathCreateService            = client.MustParseURL("./v1/Services")
	opPathCreateExternalCampaign   = client.MustParseURL("./v1/Services/PreregisteredUsa2p")
	opPathFetchUsecase             = client.MustParseURL("./v1/Services/Usecases")
	opPathListBrandRegistrations   = client.MustParseURL("./v1/a2p/BrandRegistrations")
	opPathCreateBrandRegistrations = client.MustParseURL("./v1/a2p/BrandRegistrations")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// FetchDeactivation request
	FetchDeactivation(ctx context.Context, params *FetchDeactivationParams, reqEditors ...client.RequestEditorFn) (*FetchDeactivationResponse, error)

	// ListService request
	ListService(ctx context.Context, params *ListServiceParams, reqEditors ...client.RequestEditorFn) (*ListServiceResponse, error)

	// CreateService request with any body
	CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceResponse, error)

	// CreateExternalCampaign request with any body
	CreateExternalCampaignWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateExternalCampaignResponse, error)

	// FetchUsecase request
	FetchUsecase(ctx context.Context, reqEditors ...client.RequestEditorFn) (*FetchUsecaseResponse, error)

	// ListUsAppToPerson request
	ListUsAppToPerson(ctx context.Context, messagingServiceSid string, params *ListUsAppToPersonParams, reqEditors ...client.RequestEditorFn) (*ListUsAppToPersonResponse, error)

	// CreateUsAppToPerson request with any body
	CreateUsAppToPersonWithBody(ctx context.Context, messagingServiceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateUsAppToPersonResponse, error)

	// FetchUsAppToPersonUsecase request
	FetchUsAppToPersonUsecase(ctx context.Context, messagingServiceSid string, params *FetchUsAppToPersonUsecaseParams, reqEditors ...client.RequestEditorFn) (*FetchUsAppToPersonUsecaseResponse, error)

	// DeleteUsAppToPerson request
	DeleteUsAppToPerson(ctx context.Context, messagingServiceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteUsAppToPersonResponse, error)

	// FetchUsAppToPerson request
	FetchUsAppToPerson(ctx context.Context, messagingServiceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchUsAppToPersonResponse, error)

	// ListAlphaSender request
	ListAlphaSender(ctx context.Context, serviceSid string, params *ListAlphaSenderParams, reqEditors ...client.RequestEditorFn) (*ListAlphaSenderResponse, error)

	// CreateAlphaSender request with any body
	CreateAlphaSenderWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateAlphaSenderResponse, error)

	// DeleteAlphaSender request
	DeleteAlphaSender(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteAlphaSenderResponse, error)

	// FetchAlphaSender request
	FetchAlphaSender(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchAlphaSenderResponse, error)

	// ListPhoneNumber request
	ListPhoneNumber(ctx context.Context, serviceSid string, params *ListPhoneNumberParams, reqEditors ...client.RequestEditorFn) (*ListPhoneNumberResponse, error)

	// CreatePhoneNumber request with any body
	CreatePhoneNumberWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreatePhoneNumberResponse, error)

	// DeletePhoneNumber request
	DeletePhoneNumber(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeletePhoneNumberResponse, error)

	// FetchPhoneNumber request
	FetchPhoneNumber(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchPhoneNumberResponse, error)

	// ListShortCode request
	ListShortCode(ctx context.Context, serviceSid string, params *ListShortCodeParams, reqEditors ...client.RequestEditorFn) (*ListShortCodeResponse, error)

	// CreateShortCode request with any body
	CreateShortCodeWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateShortCodeResponse, error)

	// DeleteShortCode request
	DeleteShortCode(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteShortCodeResponse, error)

	// FetchShortCode request
	FetchShortCode(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchShortCodeResponse, error)

	// DeleteService request
	DeleteService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteServiceResponse, error)

	// FetchService request
	FetchService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceResponse, error)

	// UpdateService request with any body
	UpdateServiceWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceResponse, error)

	// ListBrandRegistrations request
	ListBrandRegistrations(ctx context.Context, params *ListBrandRegistrationsParams, reqEditors ...client.RequestEditorFn) (*ListBrandRegistrationsResponse, error)

	// CreateBrandRegistrations request with any body
	CreateBrandRegistrationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateBrandRegistrationsResponse, error)

	// ListBrandVetting request
	ListBrandVetting(ctx context.Context, brandSid string, params *ListBrandVettingParams, reqEditors ...client.RequestEditorFn) (*ListBrandVettingResponse, error)

	// CreateBrandVetting request with any body
	CreateBrandVettingWithBody(ctx context.Context, brandSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateBrandVettingResponse, error)

	// FetchBrandVetting request
	FetchBrandVetting(ctx context.Context, brandSid string, brandVettingSid string, reqEditors ...client.RequestEditorFn) (*FetchBrandVettingResponse, error)

	// FetchBrandRegistrations request
	FetchBrandRegistrations(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchBrandRegistrationsResponse, error)

	// UpdateBrandRegistrations request
	UpdateBrandRegistrations(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*UpdateBrandRegistrationsResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// FetchDeactivation: GET /v1/Deactivations

type FetchDeactivationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON307      *MessagingV1Deactivation
}

// Status returns HTTPResponse.Status
func (r FetchDeactivationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchDeactivationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchDeactivationRequest generates requests for FetchDeactivation
func newFetchDeactivationRequest(baseURL *url.URL, params *FetchDeactivationParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathFetchDeactivation)

	q := queryURL.Query()

	if params.Date != nil {
		if err := client.AddQueryParam(q, "Date", *params.Date); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchDeactivation returns a parsed response.
// GET /v1/Deactivations
func (c *Client) FetchDeactivation(ctx context.Context, params *FetchDeactivationParams, reqEditors ...client.RequestEditorFn) (*FetchDeactivationResponse, error) {
	req, err := newFetchDeactivationRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchDeactivationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest MessagingV1Deactivation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest
	}

	return response, nil
}

// ListService: GET /v1/Services

type ListServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Services *[]MessagingV1Service `json:"services,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListServiceRequest generates requests for ListService
func newListServiceRequest(baseURL *url.URL, params *ListServiceParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListService)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListService returns a parsed response.
// GET /v1/Services
func (c *Client) ListService(ctx context.Context, params *ListServiceParams, reqEditors ...client.RequestEditorFn) (*ListServiceResponse, error) {
	req, err := newListServiceRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Services *[]MessagingV1Service `json:"services,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateService: POST /v1/Services

type CreateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MessagingV1Service
}

// Status returns HTTPResponse.Status
func (r CreateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateServiceRequestWithBody generates requests for CreateService with any type of body
func newCreateServiceRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateService)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateServiceWithBody returns a parsed response.
// POST /v1/Services
func (c *Client) CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceResponse, error) {
	req, err := newCreateServiceRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MessagingV1Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// CreateExternalCampaign: POST /v1/Services/PreregisteredUsa2p

type CreateExternalCampaignResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MessagingV1ExternalCampaign
}

// Status returns HTTPResponse.Status
func (r CreateExternalCampaignResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateExternalCampaignResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateExternalCampaignRequestWithBody generates requests for CreateExternalCampaign with any type of body
func newCreateExternalCampaignRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateExternalCampaign)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateExternalCampaignWithBody returns a parsed response.
// POST /v1/Services/PreregisteredUsa2p
func (c *Client) CreateExternalCampaignWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateExternalCampaignResponse, error) {
	req, err := newCreateExternalCampaignRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateExternalCampaignResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MessagingV1ExternalCampaign
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// FetchUsecase: GET /v1/Services/Usecases

type FetchUsecaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessagingV1Usecase
}

// Status returns HTTPResponse.Status
func (r FetchUsecaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchUsecaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchUsecaseRequest generates requests for FetchUsecase
func newFetchUsecaseRequest(baseURL *url.URL) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathFetchUsecase)

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchUsecase returns a parsed response.
// GET /v1/Services/Usecases
func (c *Client) FetchUsecase(ctx context.Context, reqEditors ...client.RequestEditorFn) (*FetchUsecaseResponse, error) {
	req, err := newFetchUsecaseRequest(c.BaseURL)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchUsecaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessagingV1Usecase
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListUsAppToPerson: GET /v1/Services/{MessagingServiceSid}/Compliance/Usa2p

type ListUsAppToPersonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Compliance *[]MessagingV1ServiceUsAppToPerson `json:"compliance,omitempty"`
		Meta       *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUsAppToPersonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsAppToPersonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListUsAppToPersonRequest generates requests for ListUsAppToPerson
func newListUsAppToPersonRequest(baseURL *url.URL, messagingServiceSid string, params *ListUsAppToPersonParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("MessagingServiceSid", messagingServiceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListUsAppToPersonFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListUsAppToPerson returns a parsed response.
// GET /v1/Services/{MessagingServiceSid}/Compliance/Usa2p
func (c *Client) ListUsAppToPerson(ctx context.Context, messagingServiceSid string, params *ListUsAppToPersonParams, reqEditors ...client.RequestEditorFn) (*ListUsAppToPersonResponse, error) {
	req, err := newListUsAppToPersonRequest(c.BaseURL, messagingServiceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListUsAppToPersonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Compliance *[]MessagingV1ServiceUsAppToPerson `json:"compliance,omitempty"`
			Meta       *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateUsAppToPerson: POST /v1/Services/{MessagingServiceSid}/Compliance/Usa2p

type CreateUsAppToPersonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MessagingV1ServiceUsAppToPerson
}

// Status returns HTTPResponse.Status
func (r CreateUsAppToPersonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUsAppToPersonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateUsAppToPersonRequestWithBody generates requests for CreateUsAppToPerson with any type of body
func newCreateUsAppToPersonRequestWithBody(baseURL *url.URL, messagingServiceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("MessagingServiceSid", messagingServiceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateUsAppToPersonFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateUsAppToPersonWithBody returns a parsed response.
// POST /v1/Services/{MessagingServiceSid}/Compliance/Usa2p
func (c *Client) CreateUsAppToPersonWithBody(ctx context.Context, messagingServiceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateUsAppToPersonResponse, error) {
	req, err := newCreateUsAppToPersonRequestWithBody(c.BaseURL, messagingServiceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateUsAppToPersonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MessagingV1ServiceUsAppToPerson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// FetchUsAppToPersonUsecase: GET /v1/Services/{MessagingServiceSid}/Compliance/Usa2p/Usecases

type FetchUsAppToPersonUsecaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessagingV1ServiceUsAppToPersonUsecase
}

// Status returns HTTPResponse.Status
func (r FetchUsAppToPersonUsecaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchUsAppToPersonUsecaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchUsAppToPersonUsecaseRequest generates requests for FetchUsAppToPersonUsecase
func newFetchUsAppToPersonUsecaseRequest(baseURL *url.URL, messagingServiceSid string, params *FetchUsAppToPersonUsecaseParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("MessagingServiceSid", messagingServiceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchUsAppToPersonUsecaseFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.BrandRegistrationSid != nil {
		if err := client.AddQueryParam(q, "BrandRegistrationSid", *params.BrandRegistrationSid); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchUsAppToPersonUsecase returns a parsed response.
// GET /v1/Services/{MessagingServiceSid}/Compliance/Usa2p/Usecases
func (c *Client) FetchUsAppToPersonUsecase(ctx context.Context, messagingServiceSid string, params *FetchUsAppToPersonUsecaseParams, reqEditors ...client.RequestEditorFn) (*FetchUsAppToPersonUsecaseResponse, error) {
	req, err := newFetchUsAppToPersonUsecaseRequest(c.BaseURL, messagingServiceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchUsAppToPersonUsecaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessagingV1ServiceUsAppToPersonUsecase
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteUsAppToPerson: DELETE /v1/Services/{MessagingServiceSid}/Compliance/Usa2p/{Sid}

type DeleteUsAppToPersonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteUsAppToPersonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUsAppToPersonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteUsAppToPersonRequest generates requests for DeleteUsAppToPerson
func newDeleteUsAppToPersonRequest(baseURL *url.URL, messagingServiceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("MessagingServiceSid", messagingServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteUsAppToPersonFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteUsAppToPerson returns a parsed response.
// DELETE /v1/Services/{MessagingServiceSid}/Compliance/Usa2p/{Sid}
func (c *Client) DeleteUsAppToPerson(ctx context.Context, messagingServiceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteUsAppToPersonResponse, error) {
	req, err := newDeleteUsAppToPersonRequest(c.BaseURL, messagingServiceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteUsAppToPersonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchUsAppToPerson: GET /v1/Services/{MessagingServiceSid}/Compliance/Usa2p/{Sid}

type FetchUsAppToPersonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessagingV1ServiceUsAppToPerson
}

// Status returns HTTPResponse.Status
func (r FetchUsAppToPersonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchUsAppToPersonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchUsAppToPersonRequest generates requests for FetchUsAppToPerson
func newFetchUsAppToPersonRequest(baseURL *url.URL, messagingServiceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("MessagingServiceSid", messagingServiceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchUsAppToPersonFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchUsAppToPerson returns a parsed response.
// GET /v1/Services/{MessagingServiceSid}/Compliance/Usa2p/{Sid}
func (c *Client) FetchUsAppToPerson(ctx context.Context, messagingServiceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchUsAppToPersonResponse, error) {
	req, err := newFetchUsAppToPersonRequest(c.BaseURL, messagingServiceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchUsAppToPersonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessagingV1ServiceUsAppToPerson
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListAlphaSender: GET /v1/Services/{ServiceSid}/AlphaSenders

type ListAlphaSenderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AlphaSenders *[]MessagingV1ServiceAlphaSender `json:"alpha_senders,omitempty"`
		Meta         *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAlphaSenderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAlphaSenderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListAlphaSenderRequest generates requests for ListAlphaSender
func newListAlphaSenderRequest(baseURL *url.URL, serviceSid string, params *ListAlphaSenderParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListAlphaSenderFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListAlphaSender returns a parsed response.
// GET /v1/Services/{ServiceSid}/AlphaSenders
func (c *Client) ListAlphaSender(ctx context.Context, serviceSid string, params *ListAlphaSenderParams, reqEditors ...client.RequestEditorFn) (*ListAlphaSenderResponse, error) {
	req, err := newListAlphaSenderRequest(c.BaseURL, serviceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListAlphaSenderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AlphaSenders *[]MessagingV1ServiceAlphaSender `json:"alpha_senders,omitempty"`
			Meta         *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateAlphaSender: POST /v1/Services/{ServiceSid}/AlphaSenders

type CreateAlphaSenderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MessagingV1ServiceAlphaSender
}

// Status returns HTTPResponse.Status
func (r CreateAlphaSenderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAlphaSenderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateAlphaSenderRequestWithBody generates requests for CreateAlphaSender with any type of body
func newCreateAlphaSenderRequestWithBody(baseURL *url.URL, serviceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateAlphaSenderFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateAlphaSenderWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/AlphaSenders
func (c *Client) CreateAlphaSenderWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateAlphaSenderResponse, error) {
	req, err := newCreateAlphaSenderRequestWithBody(c.BaseURL, serviceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateAlphaSenderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MessagingV1ServiceAlphaSender
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteAlphaSender: DELETE /v1/Services/{ServiceSid}/AlphaSenders/{Sid}

type DeleteAlphaSenderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteAlphaSenderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAlphaSenderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteAlphaSenderRequest generates requests for DeleteAlphaSender
func newDeleteAlphaSenderRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteAlphaSenderFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteAlphaSender returns a parsed response.
// DELETE /v1/Services/{ServiceSid}/AlphaSenders/{Sid}
func (c *Client) DeleteAlphaSender(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteAlphaSenderResponse, error) {
	req, err := newDeleteAlphaSenderRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteAlphaSenderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchAlphaSender: GET /v1/Services/{ServiceSid}/AlphaSenders/{Sid}

type FetchAlphaSenderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessagingV1ServiceAlphaSender
}

// Status returns HTTPResponse.Status
func (r FetchAlphaSenderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchAlphaSenderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchAlphaSenderRequest generates requests for FetchAlphaSender
func newFetchAlphaSenderRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchAlphaSenderFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchAlphaSender returns a parsed response.
// GET /v1/Services/{ServiceSid}/AlphaSenders/{Sid}
func (c *Client) FetchAlphaSender(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchAlphaSenderResponse, error) {
	req, err := newFetchAlphaSenderRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchAlphaSenderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessagingV1ServiceAlphaSender
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListPhoneNumber: GET /v1/Services/{ServiceSid}/PhoneNumbers

type ListPhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		PhoneNumbers *[]MessagingV1ServicePhoneNumber `json:"phone_numbers,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListPhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListPhoneNumberRequest generates requests for ListPhoneNumber
func newListPhoneNumberRequest(baseURL *url.URL, serviceSid string, params *ListPhoneNumberParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListPhoneNumberFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListPhoneNumber returns a parsed response.
// GET /v1/Services/{ServiceSid}/PhoneNumbers
func (c *Client) ListPhoneNumber(ctx context.Context, serviceSid string, params *ListPhoneNumberParams, reqEditors ...client.RequestEditorFn) (*ListPhoneNumberResponse, error) {
	req, err := newListPhoneNumberRequest(c.BaseURL, serviceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListPhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			PhoneNumbers *[]MessagingV1ServicePhoneNumber `json:"phone_numbers,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreatePhoneNumber: POST /v1/Services/{ServiceSid}/PhoneNumbers

type CreatePhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MessagingV1ServicePhoneNumber
}

// Status returns HTTPResponse.Status
func (r CreatePhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreatePhoneNumberRequestWithBody generates requests for CreatePhoneNumber with any type of body
func newCreatePhoneNumberRequestWithBody(baseURL *url.URL, serviceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreatePhoneNumberFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreatePhoneNumberWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/PhoneNumbers
func (c *Client) CreatePhoneNumberWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreatePhoneNumberResponse, error) {
	req, err := newCreatePhoneNumberRequestWithBody(c.BaseURL, serviceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreatePhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MessagingV1ServicePhoneNumber
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeletePhoneNumber: DELETE /v1/Services/{ServiceSid}/PhoneNumbers/{Sid}

type DeletePhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeletePhoneNumberRequest generates requests for DeletePhoneNumber
func newDeletePhoneNumberRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeletePhoneNumberFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeletePhoneNumber returns a parsed response.
// DELETE /v1/Services/{ServiceSid}/PhoneNumbers/{Sid}
func (c *Client) DeletePhoneNumber(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeletePhoneNumberResponse, error) {
	req, err := newDeletePhoneNumberRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeletePhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchPhoneNumber: GET /v1/Services/{ServiceSid}/PhoneNumbers/{Sid}

type FetchPhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessagingV1ServicePhoneNumber
}

// Status returns HTTPResponse.Status
func (r FetchPhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchPhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchPhoneNumberRequest generates requests for FetchPhoneNumber
func newFetchPhoneNumberRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchPhoneNumberFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchPhoneNumber returns a parsed response.
// GET /v1/Services/{ServiceSid}/PhoneNumbers/{Sid}
func (c *Client) FetchPhoneNumber(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchPhoneNumberResponse, error) {
	req, err := newFetchPhoneNumberRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchPhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessagingV1ServicePhoneNumber
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListShortCode: GET /v1/Services/{ServiceSid}/ShortCodes

type ListShortCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		ShortCodes *[]MessagingV1ServiceShortCode `json:"short_codes,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListShortCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListShortCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListShortCodeRequest generates requests for ListShortCode
func newListShortCodeRequest(baseURL *url.URL, serviceSid string, params *ListShortCodeParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListShortCodeFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListShortCode returns a parsed response.
// GET /v1/Services/{ServiceSid}/ShortCodes
func (c *Client) ListShortCode(ctx context.Context, serviceSid string, params *ListShortCodeParams, reqEditors ...client.RequestEditorFn) (*ListShortCodeResponse, error) {
	req, err := newListShortCodeRequest(c.BaseURL, serviceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListShortCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			ShortCodes *[]MessagingV1ServiceShortCode `json:"short_codes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateShortCode: POST /v1/Services/{ServiceSid}/ShortCodes

type CreateShortCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MessagingV1ServiceShortCode
}

// Status returns HTTPResponse.Status
func (r CreateShortCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateShortCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateShortCodeRequestWithBody generates requests for CreateShortCode with any type of body
func newCreateShortCodeRequestWithBody(baseURL *url.URL, serviceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateShortCodeFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateShortCodeWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/ShortCodes
func (c *Client) CreateShortCodeWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateShortCodeResponse, error) {
	req, err := newCreateShortCodeRequestWithBody(c.BaseURL, serviceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateShortCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MessagingV1ServiceShortCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteShortCode: DELETE /v1/Services/{ServiceSid}/ShortCodes/{Sid}

type DeleteShortCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteShortCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteShortCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteShortCodeRequest generates requests for DeleteShortCode
func newDeleteShortCodeRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteShortCodeFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteShortCode returns a parsed response.
// DELETE /v1/Services/{ServiceSid}/ShortCodes/{Sid}
func (c *Client) DeleteShortCode(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteShortCodeResponse, error) {
	req, err := newDeleteShortCodeRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteShortCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchShortCode: GET /v1/Services/{ServiceSid}/ShortCodes/{Sid}

type FetchShortCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessagingV1ServiceShortCode
}

// Status returns HTTPResponse.Status
func (r FetchShortCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchShortCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchShortCodeRequest generates requests for FetchShortCode
func newFetchShortCodeRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchShortCodeFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchShortCode returns a parsed response.
// GET /v1/Services/{ServiceSid}/ShortCodes/{Sid}
func (c *Client) FetchShortCode(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchShortCodeResponse, error) {
	req, err := newFetchShortCodeRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchShortCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessagingV1ServiceShortCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteService: DELETE /v1/Services/{Sid}

type DeleteServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteServiceRequest generates requests for DeleteService
func newDeleteServiceRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteServiceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteService returns a parsed response.
// DELETE /v1/Services/{Sid}
func (c *Client) DeleteService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteServiceResponse, error) {
	req, err := newDeleteServiceRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchService: GET /v1/Services/{Sid}

type FetchServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessagingV1Service
}

// Status returns HTTPResponse.Status
func (r FetchServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchServiceRequest generates requests for FetchService
func newFetchServiceRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchServiceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchService returns a parsed response.
// GET /v1/Services/{Sid}
func (c *Client) FetchService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceResponse, error) {
	req, err := newFetchServiceRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessagingV1Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateService: POST /v1/Services/{Sid}

type UpdateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessagingV1Service
}

// Status returns HTTPResponse.Status
func (r UpdateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateServiceRequestWithBody generates requests for UpdateService with any type of body
func newUpdateServiceRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateServiceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateServiceWithBody returns a parsed response.
// POST /v1/Services/{Sid}
func (c *Client) UpdateServiceWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceResponse, error) {
	req, err := newUpdateServiceRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessagingV1Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListBrandRegistrations: GET /v1/a2p/BrandRegistrations

type ListBrandRegistrationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]MessagingV1BrandRegistrations `json:"data,omitempty"`
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListBrandRegistrationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBrandRegistrationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListBrandRegistrationsRequest generates requests for ListBrandRegistrations
func newListBrandRegistrationsRequest(baseURL *url.URL, params *ListBrandRegistrationsParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListBrandRegistrations)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListBrandRegistrations returns a parsed response.
// GET /v1/a2p/BrandRegistrations
func (c *Client) ListBrandRegistrations(ctx context.Context, params *ListBrandRegistrationsParams, reqEditors ...client.RequestEditorFn) (*ListBrandRegistrationsResponse, error) {
	req, err := newListBrandRegistrationsRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListBrandRegistrationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]MessagingV1BrandRegistrations `json:"data,omitempty"`
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateBrandRegistrations: POST /v1/a2p/BrandRegistrations

type CreateBrandRegistrationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MessagingV1BrandRegistrations
}

// Status returns HTTPResponse.Status
func (r CreateBrandRegistrationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBrandRegistrationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateBrandRegistrationsRequestWithBody generates requests for CreateBrandRegistrations with any type of body
func newCreateBrandRegistrationsRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateBrandRegistrations)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateBrandRegistrationsWithBody returns a parsed response.
// POST /v1/a2p/BrandRegistrations
func (c *Client) CreateBrandRegistrationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateBrandRegistrationsResponse, error) {
	req, err := newCreateBrandRegistrationsRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateBrandRegistrationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MessagingV1BrandRegistrations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListBrandVetting: GET /v1/a2p/BrandRegistrations/{BrandSid}/Vettings

type ListBrandVettingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]MessagingV1BrandRegistrationsBrandVetting `json:"data,omitempty"`
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListBrandVettingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBrandVettingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListBrandVettingRequest generates requests for ListBrandVetting
func newListBrandVettingRequest(baseURL *url.URL, brandSid string, params *ListBrandVettingParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("BrandSid", brandSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListBrandVettingFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.VettingProvider != nil {
		if err := client.AddQueryParam(q, "VettingProvider", *params.VettingProvider); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListBrandVetting returns a parsed response.
// GET /v1/a2p/BrandRegistrations/{BrandSid}/Vettings
func (c *Client) ListBrandVetting(ctx context.Context, brandSid string, params *ListBrandVettingParams, reqEditors ...client.RequestEditorFn) (*ListBrandVettingResponse, error) {
	req, err := newListBrandVettingRequest(c.BaseURL, brandSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListBrandVettingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]MessagingV1BrandRegistrationsBrandVetting `json:"data,omitempty"`
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateBrandVetting: POST /v1/a2p/BrandRegistrations/{BrandSid}/Vettings

type CreateBrandVettingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MessagingV1BrandRegistrationsBrandVetting
}

// Status returns HTTPResponse.Status
func (r CreateBrandVettingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBrandVettingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateBrandVettingRequestWithBody generates requests for CreateBrandVetting with any type of body
func newCreateBrandVettingRequestWithBody(baseURL *url.URL, brandSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("BrandSid", brandSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateBrandVettingFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateBrandVettingWithBody returns a parsed response.
// POST /v1/a2p/BrandRegistrations/{BrandSid}/Vettings
func (c *Client) CreateBrandVettingWithBody(ctx context.Context, brandSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateBrandVettingResponse, error) {
	req, err := newCreateBrandVettingRequestWithBody(c.BaseURL, brandSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateBrandVettingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MessagingV1BrandRegistrationsBrandVetting
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// FetchBrandVetting: GET /v1/a2p/BrandRegistrations/{BrandSid}/Vettings/{BrandVettingSid}

type FetchBrandVettingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessagingV1BrandRegistrationsBrandVetting
}

// Status returns HTTPResponse.Status
func (r FetchBrandVettingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchBrandVettingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchBrandVettingRequest generates requests for FetchBrandVetting
func newFetchBrandVettingRequest(baseURL *url.URL, brandSid string, brandVettingSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("BrandSid", brandSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("BrandVettingSid", brandVettingSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchBrandVettingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchBrandVetting returns a parsed response.
// GET /v1/a2p/BrandRegistrations/{BrandSid}/Vettings/{BrandVettingSid}
func (c *Client) FetchBrandVetting(ctx context.Context, brandSid string, brandVettingSid string, reqEditors ...client.RequestEditorFn) (*FetchBrandVettingResponse, error) {
	req, err := newFetchBrandVettingRequest(c.BaseURL, brandSid, brandVettingSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchBrandVettingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessagingV1BrandRegistrationsBrandVetting
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchBrandRegistrations: GET /v1/a2p/BrandRegistrations/{Sid}

type FetchBrandRegistrationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessagingV1BrandRegistrations
}

// Status returns HTTPResponse.Status
func (r FetchBrandRegistrationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchBrandRegistrationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchBrandRegistrationsRequest generates requests for FetchBrandRegistrations
func newFetchBrandRegistrationsRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchBrandRegistrationsFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchBrandRegistrations returns a parsed response.
// GET /v1/a2p/BrandRegistrations/{Sid}
func (c *Client) FetchBrandRegistrations(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchBrandRegistrationsResponse, error) {
	req, err := newFetchBrandRegistrationsRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchBrandRegistrationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessagingV1BrandRegistrations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateBrandRegistrations: POST /v1/a2p/BrandRegistrations/{Sid}

type UpdateBrandRegistrationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *MessagingV1BrandRegistrations
}

// Status returns HTTPResponse.Status
func (r UpdateBrandRegistrationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBrandRegistrationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateBrandRegistrationsRequest generates requests for UpdateBrandRegistrations
func newUpdateBrandRegistrationsRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateBrandRegistrationsFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// UpdateBrandRegistrations returns a parsed response.
// POST /v1/a2p/BrandRegistrations/{Sid}
func (c *Client) UpdateBrandRegistrations(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*UpdateBrandRegistrationsResponse, error) {
	req, err := newUpdateBrandRegistrationsRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateBrandRegistrationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest MessagingV1BrandRegistrations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest
	}

	return response, nil
}
