// Package voice provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package voice

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/faetools/client"
)

// operation paths

const (
	opPathDeleteArchivedCallFormat                = "./v1/Archives/%s/Calls/%s"
	opPathDeleteByocTrunkFormat                   = "./v1/ByocTrunks/%s"
	opPathFetchByocTrunkFormat                    = "./v1/ByocTrunks/%s"
	opPathUpdateByocTrunkFormat                   = "./v1/ByocTrunks/%s"
	opPathListConnectionPolicyTargetFormat        = "./v1/ConnectionPolicies/%s/Targets"
	opPathCreateConnectionPolicyTargetFormat      = "./v1/ConnectionPolicies/%s/Targets"
	opPathDeleteConnectionPolicyTargetFormat      = "./v1/ConnectionPolicies/%s/Targets/%s"
	opPathFetchConnectionPolicyTargetFormat       = "./v1/ConnectionPolicies/%s/Targets/%s"
	opPathUpdateConnectionPolicyTargetFormat      = "./v1/ConnectionPolicies/%s/Targets/%s"
	opPathDeleteConnectionPolicyFormat            = "./v1/ConnectionPolicies/%s"
	opPathFetchConnectionPolicyFormat             = "./v1/ConnectionPolicies/%s"
	opPathUpdateConnectionPolicyFormat            = "./v1/ConnectionPolicies/%s"
	opPathFetchDialingPermissionsCountryFormat    = "./v1/DialingPermissions/Countries/%s"
	opPathListDialingPermissionsHrsPrefixesFormat = "./v1/DialingPermissions/Countries/%s/HighRiskSpecialPrefixes"
	opPathDeleteIpRecordFormat                    = "./v1/IpRecords/%s"
	opPathFetchIpRecordFormat                     = "./v1/IpRecords/%s"
	opPathUpdateIpRecordFormat                    = "./v1/IpRecords/%s"
	opPathDeleteSourceIpMappingFormat             = "./v1/SourceIpMappings/%s"
	opPathFetchSourceIpMappingFormat              = "./v1/SourceIpMappings/%s"
	opPathUpdateSourceIpMappingFormat             = "./v1/SourceIpMappings/%s"
)

var (
	opPathListByocTrunk                             = client.MustParseURL("./v1/ByocTrunks")
	opPathCreateByocTrunk                           = client.MustParseURL("./v1/ByocTrunks")
	opPathListConnectionPolicy                      = client.MustParseURL("./v1/ConnectionPolicies")
	opPathCreateConnectionPolicy                    = client.MustParseURL("./v1/ConnectionPolicies")
	opPathCreateDialingPermissionsCountryBulkUpdate = client.MustParseURL("./v1/DialingPermissions/BulkCountryUpdates")
	opPathListDialingPermissionsCountry             = client.MustParseURL("./v1/DialingPermissions/Countries")
	opPathListIpRecord                              = client.MustParseURL("./v1/IpRecords")
	opPathCreateIpRecord                            = client.MustParseURL("./v1/IpRecords")
	opPathFetchDialingPermissionsSettings           = client.MustParseURL("./v1/Settings")
	opPathUpdateDialingPermissionsSettings          = client.MustParseURL("./v1/Settings")
	opPathListSourceIpMapping                       = client.MustParseURL("./v1/SourceIpMappings")
	opPathCreateSourceIpMapping                     = client.MustParseURL("./v1/SourceIpMappings")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// DeleteArchivedCall request
	DeleteArchivedCall(ctx context.Context, date openapi_types.Date, sid string, reqEditors ...client.RequestEditorFn) (*DeleteArchivedCallResponse, error)

	// ListByocTrunk request
	ListByocTrunk(ctx context.Context, params *ListByocTrunkParams, reqEditors ...client.RequestEditorFn) (*ListByocTrunkResponse, error)

	// CreateByocTrunk request with any body
	CreateByocTrunkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateByocTrunkResponse, error)

	// DeleteByocTrunk request
	DeleteByocTrunk(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteByocTrunkResponse, error)

	// FetchByocTrunk request
	FetchByocTrunk(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchByocTrunkResponse, error)

	// UpdateByocTrunk request with any body
	UpdateByocTrunkWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateByocTrunkResponse, error)

	// ListConnectionPolicy request
	ListConnectionPolicy(ctx context.Context, params *ListConnectionPolicyParams, reqEditors ...client.RequestEditorFn) (*ListConnectionPolicyResponse, error)

	// CreateConnectionPolicy request with any body
	CreateConnectionPolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateConnectionPolicyResponse, error)

	// ListConnectionPolicyTarget request
	ListConnectionPolicyTarget(ctx context.Context, connectionPolicySid string, params *ListConnectionPolicyTargetParams, reqEditors ...client.RequestEditorFn) (*ListConnectionPolicyTargetResponse, error)

	// CreateConnectionPolicyTarget request with any body
	CreateConnectionPolicyTargetWithBody(ctx context.Context, connectionPolicySid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateConnectionPolicyTargetResponse, error)

	// DeleteConnectionPolicyTarget request
	DeleteConnectionPolicyTarget(ctx context.Context, connectionPolicySid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteConnectionPolicyTargetResponse, error)

	// FetchConnectionPolicyTarget request
	FetchConnectionPolicyTarget(ctx context.Context, connectionPolicySid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchConnectionPolicyTargetResponse, error)

	// UpdateConnectionPolicyTarget request with any body
	UpdateConnectionPolicyTargetWithBody(ctx context.Context, connectionPolicySid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConnectionPolicyTargetResponse, error)

	// DeleteConnectionPolicy request
	DeleteConnectionPolicy(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteConnectionPolicyResponse, error)

	// FetchConnectionPolicy request
	FetchConnectionPolicy(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchConnectionPolicyResponse, error)

	// UpdateConnectionPolicy request with any body
	UpdateConnectionPolicyWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConnectionPolicyResponse, error)

	// CreateDialingPermissionsCountryBulkUpdate request with any body
	CreateDialingPermissionsCountryBulkUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateDialingPermissionsCountryBulkUpdateResponse, error)

	// ListDialingPermissionsCountry request
	ListDialingPermissionsCountry(ctx context.Context, params *ListDialingPermissionsCountryParams, reqEditors ...client.RequestEditorFn) (*ListDialingPermissionsCountryResponse, error)

	// FetchDialingPermissionsCountry request
	FetchDialingPermissionsCountry(ctx context.Context, isoCode string, reqEditors ...client.RequestEditorFn) (*FetchDialingPermissionsCountryResponse, error)

	// ListDialingPermissionsHrsPrefixes request
	ListDialingPermissionsHrsPrefixes(ctx context.Context, isoCode string, params *ListDialingPermissionsHrsPrefixesParams, reqEditors ...client.RequestEditorFn) (*ListDialingPermissionsHrsPrefixesResponse, error)

	// ListIpRecord request
	ListIpRecord(ctx context.Context, params *ListIpRecordParams, reqEditors ...client.RequestEditorFn) (*ListIpRecordResponse, error)

	// CreateIpRecord request with any body
	CreateIpRecordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateIpRecordResponse, error)

	// DeleteIpRecord request
	DeleteIpRecord(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteIpRecordResponse, error)

	// FetchIpRecord request
	FetchIpRecord(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchIpRecordResponse, error)

	// UpdateIpRecord request with any body
	UpdateIpRecordWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateIpRecordResponse, error)

	// FetchDialingPermissionsSettings request
	FetchDialingPermissionsSettings(ctx context.Context, reqEditors ...client.RequestEditorFn) (*FetchDialingPermissionsSettingsResponse, error)

	// UpdateDialingPermissionsSettings request with any body
	UpdateDialingPermissionsSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateDialingPermissionsSettingsResponse, error)

	// ListSourceIpMapping request
	ListSourceIpMapping(ctx context.Context, params *ListSourceIpMappingParams, reqEditors ...client.RequestEditorFn) (*ListSourceIpMappingResponse, error)

	// CreateSourceIpMapping request with any body
	CreateSourceIpMappingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSourceIpMappingResponse, error)

	// DeleteSourceIpMapping request
	DeleteSourceIpMapping(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSourceIpMappingResponse, error)

	// FetchSourceIpMapping request
	FetchSourceIpMapping(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchSourceIpMappingResponse, error)

	// UpdateSourceIpMapping request with any body
	UpdateSourceIpMappingWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSourceIpMappingResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// DeleteArchivedCall: DELETE /v1/Archives/{Date}/Calls/{Sid}

type DeleteArchivedCallResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteArchivedCallResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteArchivedCallResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteArchivedCallRequest generates requests for DeleteArchivedCall
func newDeleteArchivedCallRequest(baseURL *url.URL, date openapi_types.Date, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Date", date)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteArchivedCallFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteArchivedCall returns a parsed response.
// DELETE /v1/Archives/{Date}/Calls/{Sid}
func (c *Client) DeleteArchivedCall(ctx context.Context, date openapi_types.Date, sid string, reqEditors ...client.RequestEditorFn) (*DeleteArchivedCallResponse, error) {
	req, err := newDeleteArchivedCallRequest(c.BaseURL, date, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteArchivedCallResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ListByocTrunk: GET /v1/ByocTrunks

type ListByocTrunkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ByocTrunks *[]VoiceV1ByocTrunk `json:"byoc_trunks,omitempty"`
		Meta       *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListByocTrunkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListByocTrunkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListByocTrunkRequest generates requests for ListByocTrunk
func newListByocTrunkRequest(baseURL *url.URL, params *ListByocTrunkParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListByocTrunk)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListByocTrunk returns a parsed response.
// GET /v1/ByocTrunks
func (c *Client) ListByocTrunk(ctx context.Context, params *ListByocTrunkParams, reqEditors ...client.RequestEditorFn) (*ListByocTrunkResponse, error) {
	req, err := newListByocTrunkRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListByocTrunkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ByocTrunks *[]VoiceV1ByocTrunk `json:"byoc_trunks,omitempty"`
			Meta       *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateByocTrunk: POST /v1/ByocTrunks

type CreateByocTrunkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VoiceV1ByocTrunk
}

// Status returns HTTPResponse.Status
func (r CreateByocTrunkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateByocTrunkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateByocTrunkRequestWithBody generates requests for CreateByocTrunk with any type of body
func newCreateByocTrunkRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateByocTrunk)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateByocTrunkWithBody returns a parsed response.
// POST /v1/ByocTrunks
func (c *Client) CreateByocTrunkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateByocTrunkResponse, error) {
	req, err := newCreateByocTrunkRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateByocTrunkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VoiceV1ByocTrunk
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteByocTrunk: DELETE /v1/ByocTrunks/{Sid}

type DeleteByocTrunkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteByocTrunkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteByocTrunkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteByocTrunkRequest generates requests for DeleteByocTrunk
func newDeleteByocTrunkRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteByocTrunkFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteByocTrunk returns a parsed response.
// DELETE /v1/ByocTrunks/{Sid}
func (c *Client) DeleteByocTrunk(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteByocTrunkResponse, error) {
	req, err := newDeleteByocTrunkRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteByocTrunkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchByocTrunk: GET /v1/ByocTrunks/{Sid}

type FetchByocTrunkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoiceV1ByocTrunk
}

// Status returns HTTPResponse.Status
func (r FetchByocTrunkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchByocTrunkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchByocTrunkRequest generates requests for FetchByocTrunk
func newFetchByocTrunkRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchByocTrunkFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchByocTrunk returns a parsed response.
// GET /v1/ByocTrunks/{Sid}
func (c *Client) FetchByocTrunk(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchByocTrunkResponse, error) {
	req, err := newFetchByocTrunkRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchByocTrunkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoiceV1ByocTrunk
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateByocTrunk: POST /v1/ByocTrunks/{Sid}

type UpdateByocTrunkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoiceV1ByocTrunk
}

// Status returns HTTPResponse.Status
func (r UpdateByocTrunkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateByocTrunkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateByocTrunkRequestWithBody generates requests for UpdateByocTrunk with any type of body
func newUpdateByocTrunkRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateByocTrunkFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateByocTrunkWithBody returns a parsed response.
// POST /v1/ByocTrunks/{Sid}
func (c *Client) UpdateByocTrunkWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateByocTrunkResponse, error) {
	req, err := newUpdateByocTrunkRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateByocTrunkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoiceV1ByocTrunk
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListConnectionPolicy: GET /v1/ConnectionPolicies

type ListConnectionPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ConnectionPolicies *[]VoiceV1ConnectionPolicy `json:"connection_policies,omitempty"`
		Meta               *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListConnectionPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConnectionPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListConnectionPolicyRequest generates requests for ListConnectionPolicy
func newListConnectionPolicyRequest(baseURL *url.URL, params *ListConnectionPolicyParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListConnectionPolicy)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListConnectionPolicy returns a parsed response.
// GET /v1/ConnectionPolicies
func (c *Client) ListConnectionPolicy(ctx context.Context, params *ListConnectionPolicyParams, reqEditors ...client.RequestEditorFn) (*ListConnectionPolicyResponse, error) {
	req, err := newListConnectionPolicyRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListConnectionPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ConnectionPolicies *[]VoiceV1ConnectionPolicy `json:"connection_policies,omitempty"`
			Meta               *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateConnectionPolicy: POST /v1/ConnectionPolicies

type CreateConnectionPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VoiceV1ConnectionPolicy
}

// Status returns HTTPResponse.Status
func (r CreateConnectionPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConnectionPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateConnectionPolicyRequestWithBody generates requests for CreateConnectionPolicy with any type of body
func newCreateConnectionPolicyRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateConnectionPolicy)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateConnectionPolicyWithBody returns a parsed response.
// POST /v1/ConnectionPolicies
func (c *Client) CreateConnectionPolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateConnectionPolicyResponse, error) {
	req, err := newCreateConnectionPolicyRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateConnectionPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VoiceV1ConnectionPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListConnectionPolicyTarget: GET /v1/ConnectionPolicies/{ConnectionPolicySid}/Targets

type ListConnectionPolicyTargetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Targets *[]VoiceV1ConnectionPolicyConnectionPolicyTarget `json:"targets,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListConnectionPolicyTargetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConnectionPolicyTargetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListConnectionPolicyTargetRequest generates requests for ListConnectionPolicyTarget
func newListConnectionPolicyTargetRequest(baseURL *url.URL, connectionPolicySid string, params *ListConnectionPolicyTargetParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConnectionPolicySid", connectionPolicySid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListConnectionPolicyTargetFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListConnectionPolicyTarget returns a parsed response.
// GET /v1/ConnectionPolicies/{ConnectionPolicySid}/Targets
func (c *Client) ListConnectionPolicyTarget(ctx context.Context, connectionPolicySid string, params *ListConnectionPolicyTargetParams, reqEditors ...client.RequestEditorFn) (*ListConnectionPolicyTargetResponse, error) {
	req, err := newListConnectionPolicyTargetRequest(c.BaseURL, connectionPolicySid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListConnectionPolicyTargetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Targets *[]VoiceV1ConnectionPolicyConnectionPolicyTarget `json:"targets,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateConnectionPolicyTarget: POST /v1/ConnectionPolicies/{ConnectionPolicySid}/Targets

type CreateConnectionPolicyTargetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VoiceV1ConnectionPolicyConnectionPolicyTarget
}

// Status returns HTTPResponse.Status
func (r CreateConnectionPolicyTargetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConnectionPolicyTargetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateConnectionPolicyTargetRequestWithBody generates requests for CreateConnectionPolicyTarget with any type of body
func newCreateConnectionPolicyTargetRequestWithBody(baseURL *url.URL, connectionPolicySid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConnectionPolicySid", connectionPolicySid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateConnectionPolicyTargetFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateConnectionPolicyTargetWithBody returns a parsed response.
// POST /v1/ConnectionPolicies/{ConnectionPolicySid}/Targets
func (c *Client) CreateConnectionPolicyTargetWithBody(ctx context.Context, connectionPolicySid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateConnectionPolicyTargetResponse, error) {
	req, err := newCreateConnectionPolicyTargetRequestWithBody(c.BaseURL, connectionPolicySid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateConnectionPolicyTargetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VoiceV1ConnectionPolicyConnectionPolicyTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteConnectionPolicyTarget: DELETE /v1/ConnectionPolicies/{ConnectionPolicySid}/Targets/{Sid}

type DeleteConnectionPolicyTargetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteConnectionPolicyTargetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConnectionPolicyTargetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteConnectionPolicyTargetRequest generates requests for DeleteConnectionPolicyTarget
func newDeleteConnectionPolicyTargetRequest(baseURL *url.URL, connectionPolicySid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConnectionPolicySid", connectionPolicySid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteConnectionPolicyTargetFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteConnectionPolicyTarget returns a parsed response.
// DELETE /v1/ConnectionPolicies/{ConnectionPolicySid}/Targets/{Sid}
func (c *Client) DeleteConnectionPolicyTarget(ctx context.Context, connectionPolicySid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteConnectionPolicyTargetResponse, error) {
	req, err := newDeleteConnectionPolicyTargetRequest(c.BaseURL, connectionPolicySid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteConnectionPolicyTargetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchConnectionPolicyTarget: GET /v1/ConnectionPolicies/{ConnectionPolicySid}/Targets/{Sid}

type FetchConnectionPolicyTargetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoiceV1ConnectionPolicyConnectionPolicyTarget
}

// Status returns HTTPResponse.Status
func (r FetchConnectionPolicyTargetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchConnectionPolicyTargetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchConnectionPolicyTargetRequest generates requests for FetchConnectionPolicyTarget
func newFetchConnectionPolicyTargetRequest(baseURL *url.URL, connectionPolicySid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConnectionPolicySid", connectionPolicySid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchConnectionPolicyTargetFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchConnectionPolicyTarget returns a parsed response.
// GET /v1/ConnectionPolicies/{ConnectionPolicySid}/Targets/{Sid}
func (c *Client) FetchConnectionPolicyTarget(ctx context.Context, connectionPolicySid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchConnectionPolicyTargetResponse, error) {
	req, err := newFetchConnectionPolicyTargetRequest(c.BaseURL, connectionPolicySid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchConnectionPolicyTargetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoiceV1ConnectionPolicyConnectionPolicyTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateConnectionPolicyTarget: POST /v1/ConnectionPolicies/{ConnectionPolicySid}/Targets/{Sid}

type UpdateConnectionPolicyTargetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoiceV1ConnectionPolicyConnectionPolicyTarget
}

// Status returns HTTPResponse.Status
func (r UpdateConnectionPolicyTargetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConnectionPolicyTargetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateConnectionPolicyTargetRequestWithBody generates requests for UpdateConnectionPolicyTarget with any type of body
func newUpdateConnectionPolicyTargetRequestWithBody(baseURL *url.URL, connectionPolicySid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ConnectionPolicySid", connectionPolicySid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateConnectionPolicyTargetFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateConnectionPolicyTargetWithBody returns a parsed response.
// POST /v1/ConnectionPolicies/{ConnectionPolicySid}/Targets/{Sid}
func (c *Client) UpdateConnectionPolicyTargetWithBody(ctx context.Context, connectionPolicySid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConnectionPolicyTargetResponse, error) {
	req, err := newUpdateConnectionPolicyTargetRequestWithBody(c.BaseURL, connectionPolicySid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateConnectionPolicyTargetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoiceV1ConnectionPolicyConnectionPolicyTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteConnectionPolicy: DELETE /v1/ConnectionPolicies/{Sid}

type DeleteConnectionPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteConnectionPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConnectionPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteConnectionPolicyRequest generates requests for DeleteConnectionPolicy
func newDeleteConnectionPolicyRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteConnectionPolicyFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteConnectionPolicy returns a parsed response.
// DELETE /v1/ConnectionPolicies/{Sid}
func (c *Client) DeleteConnectionPolicy(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteConnectionPolicyResponse, error) {
	req, err := newDeleteConnectionPolicyRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteConnectionPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchConnectionPolicy: GET /v1/ConnectionPolicies/{Sid}

type FetchConnectionPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoiceV1ConnectionPolicy
}

// Status returns HTTPResponse.Status
func (r FetchConnectionPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchConnectionPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchConnectionPolicyRequest generates requests for FetchConnectionPolicy
func newFetchConnectionPolicyRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchConnectionPolicyFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchConnectionPolicy returns a parsed response.
// GET /v1/ConnectionPolicies/{Sid}
func (c *Client) FetchConnectionPolicy(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchConnectionPolicyResponse, error) {
	req, err := newFetchConnectionPolicyRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchConnectionPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoiceV1ConnectionPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateConnectionPolicy: POST /v1/ConnectionPolicies/{Sid}

type UpdateConnectionPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoiceV1ConnectionPolicy
}

// Status returns HTTPResponse.Status
func (r UpdateConnectionPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConnectionPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateConnectionPolicyRequestWithBody generates requests for UpdateConnectionPolicy with any type of body
func newUpdateConnectionPolicyRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateConnectionPolicyFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateConnectionPolicyWithBody returns a parsed response.
// POST /v1/ConnectionPolicies/{Sid}
func (c *Client) UpdateConnectionPolicyWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConnectionPolicyResponse, error) {
	req, err := newUpdateConnectionPolicyRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateConnectionPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoiceV1ConnectionPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateDialingPermissionsCountryBulkUpdate: POST /v1/DialingPermissions/BulkCountryUpdates

type CreateDialingPermissionsCountryBulkUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VoiceV1DialingPermissionsDialingPermissionsCountryBulkUpdate
}

// Status returns HTTPResponse.Status
func (r CreateDialingPermissionsCountryBulkUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDialingPermissionsCountryBulkUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateDialingPermissionsCountryBulkUpdateRequestWithBody generates requests for CreateDialingPermissionsCountryBulkUpdate with any type of body
func newCreateDialingPermissionsCountryBulkUpdateRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateDialingPermissionsCountryBulkUpdate)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateDialingPermissionsCountryBulkUpdateWithBody returns a parsed response.
// POST /v1/DialingPermissions/BulkCountryUpdates
func (c *Client) CreateDialingPermissionsCountryBulkUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateDialingPermissionsCountryBulkUpdateResponse, error) {
	req, err := newCreateDialingPermissionsCountryBulkUpdateRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateDialingPermissionsCountryBulkUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VoiceV1DialingPermissionsDialingPermissionsCountryBulkUpdate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListDialingPermissionsCountry: GET /v1/DialingPermissions/Countries

type ListDialingPermissionsCountryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Content *[]VoiceV1DialingPermissionsDialingPermissionsCountry `json:"content,omitempty"`
		Meta    *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDialingPermissionsCountryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDialingPermissionsCountryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListDialingPermissionsCountryRequest generates requests for ListDialingPermissionsCountry
func newListDialingPermissionsCountryRequest(baseURL *url.URL, params *ListDialingPermissionsCountryParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListDialingPermissionsCountry)

	q := queryURL.Query()

	if params.IsoCode != nil {
		if err := client.AddQueryParam(q, "IsoCode", *params.IsoCode); err != nil {
			return nil, err
		}
	}

	if params.Continent != nil {
		if err := client.AddQueryParam(q, "Continent", *params.Continent); err != nil {
			return nil, err
		}
	}

	if params.CountryCode != nil {
		if err := client.AddQueryParam(q, "CountryCode", *params.CountryCode); err != nil {
			return nil, err
		}
	}

	if params.LowRiskNumbersEnabled != nil {
		if err := client.AddQueryParam(q, "LowRiskNumbersEnabled", *params.LowRiskNumbersEnabled); err != nil {
			return nil, err
		}
	}

	if params.HighRiskSpecialNumbersEnabled != nil {
		if err := client.AddQueryParam(q, "HighRiskSpecialNumbersEnabled", *params.HighRiskSpecialNumbersEnabled); err != nil {
			return nil, err
		}
	}

	if params.HighRiskTollfraudNumbersEnabled != nil {
		if err := client.AddQueryParam(q, "HighRiskTollfraudNumbersEnabled", *params.HighRiskTollfraudNumbersEnabled); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListDialingPermissionsCountry returns a parsed response.
// GET /v1/DialingPermissions/Countries
func (c *Client) ListDialingPermissionsCountry(ctx context.Context, params *ListDialingPermissionsCountryParams, reqEditors ...client.RequestEditorFn) (*ListDialingPermissionsCountryResponse, error) {
	req, err := newListDialingPermissionsCountryRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListDialingPermissionsCountryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Content *[]VoiceV1DialingPermissionsDialingPermissionsCountry `json:"content,omitempty"`
			Meta    *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchDialingPermissionsCountry: GET /v1/DialingPermissions/Countries/{IsoCode}

type FetchDialingPermissionsCountryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoiceV1DialingPermissionsDialingPermissionsCountryInstance
}

// Status returns HTTPResponse.Status
func (r FetchDialingPermissionsCountryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchDialingPermissionsCountryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchDialingPermissionsCountryRequest generates requests for FetchDialingPermissionsCountry
func newFetchDialingPermissionsCountryRequest(baseURL *url.URL, isoCode string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("IsoCode", isoCode)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchDialingPermissionsCountryFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchDialingPermissionsCountry returns a parsed response.
// GET /v1/DialingPermissions/Countries/{IsoCode}
func (c *Client) FetchDialingPermissionsCountry(ctx context.Context, isoCode string, reqEditors ...client.RequestEditorFn) (*FetchDialingPermissionsCountryResponse, error) {
	req, err := newFetchDialingPermissionsCountryRequest(c.BaseURL, isoCode)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchDialingPermissionsCountryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoiceV1DialingPermissionsDialingPermissionsCountryInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListDialingPermissionsHrsPrefixes: GET /v1/DialingPermissions/Countries/{IsoCode}/HighRiskSpecialPrefixes

type ListDialingPermissionsHrsPrefixesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Content *[]VoiceV1DialingPermissionsDialingPermissionsCountryDialingPermissionsHrsPrefixes `json:"content,omitempty"`
		Meta    *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDialingPermissionsHrsPrefixesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDialingPermissionsHrsPrefixesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListDialingPermissionsHrsPrefixesRequest generates requests for ListDialingPermissionsHrsPrefixes
func newListDialingPermissionsHrsPrefixesRequest(baseURL *url.URL, isoCode string, params *ListDialingPermissionsHrsPrefixesParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("IsoCode", isoCode)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListDialingPermissionsHrsPrefixesFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListDialingPermissionsHrsPrefixes returns a parsed response.
// GET /v1/DialingPermissions/Countries/{IsoCode}/HighRiskSpecialPrefixes
func (c *Client) ListDialingPermissionsHrsPrefixes(ctx context.Context, isoCode string, params *ListDialingPermissionsHrsPrefixesParams, reqEditors ...client.RequestEditorFn) (*ListDialingPermissionsHrsPrefixesResponse, error) {
	req, err := newListDialingPermissionsHrsPrefixesRequest(c.BaseURL, isoCode, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListDialingPermissionsHrsPrefixesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Content *[]VoiceV1DialingPermissionsDialingPermissionsCountryDialingPermissionsHrsPrefixes `json:"content,omitempty"`
			Meta    *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListIpRecord: GET /v1/IpRecords

type ListIpRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IpRecords *[]VoiceV1IpRecord `json:"ip_records,omitempty"`
		Meta      *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListIpRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIpRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListIpRecordRequest generates requests for ListIpRecord
func newListIpRecordRequest(baseURL *url.URL, params *ListIpRecordParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListIpRecord)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListIpRecord returns a parsed response.
// GET /v1/IpRecords
func (c *Client) ListIpRecord(ctx context.Context, params *ListIpRecordParams, reqEditors ...client.RequestEditorFn) (*ListIpRecordResponse, error) {
	req, err := newListIpRecordRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListIpRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IpRecords *[]VoiceV1IpRecord `json:"ip_records,omitempty"`
			Meta      *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateIpRecord: POST /v1/IpRecords

type CreateIpRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VoiceV1IpRecord
}

// Status returns HTTPResponse.Status
func (r CreateIpRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIpRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateIpRecordRequestWithBody generates requests for CreateIpRecord with any type of body
func newCreateIpRecordRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateIpRecord)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateIpRecordWithBody returns a parsed response.
// POST /v1/IpRecords
func (c *Client) CreateIpRecordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateIpRecordResponse, error) {
	req, err := newCreateIpRecordRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateIpRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VoiceV1IpRecord
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteIpRecord: DELETE /v1/IpRecords/{Sid}

type DeleteIpRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteIpRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIpRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteIpRecordRequest generates requests for DeleteIpRecord
func newDeleteIpRecordRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteIpRecordFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteIpRecord returns a parsed response.
// DELETE /v1/IpRecords/{Sid}
func (c *Client) DeleteIpRecord(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteIpRecordResponse, error) {
	req, err := newDeleteIpRecordRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteIpRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchIpRecord: GET /v1/IpRecords/{Sid}

type FetchIpRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoiceV1IpRecord
}

// Status returns HTTPResponse.Status
func (r FetchIpRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchIpRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchIpRecordRequest generates requests for FetchIpRecord
func newFetchIpRecordRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchIpRecordFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchIpRecord returns a parsed response.
// GET /v1/IpRecords/{Sid}
func (c *Client) FetchIpRecord(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchIpRecordResponse, error) {
	req, err := newFetchIpRecordRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchIpRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoiceV1IpRecord
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateIpRecord: POST /v1/IpRecords/{Sid}

type UpdateIpRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoiceV1IpRecord
}

// Status returns HTTPResponse.Status
func (r UpdateIpRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateIpRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateIpRecordRequestWithBody generates requests for UpdateIpRecord with any type of body
func newUpdateIpRecordRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateIpRecordFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateIpRecordWithBody returns a parsed response.
// POST /v1/IpRecords/{Sid}
func (c *Client) UpdateIpRecordWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateIpRecordResponse, error) {
	req, err := newUpdateIpRecordRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateIpRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoiceV1IpRecord
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchDialingPermissionsSettings: GET /v1/Settings

type FetchDialingPermissionsSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoiceV1DialingPermissionsDialingPermissionsSettings
}

// Status returns HTTPResponse.Status
func (r FetchDialingPermissionsSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchDialingPermissionsSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchDialingPermissionsSettingsRequest generates requests for FetchDialingPermissionsSettings
func newFetchDialingPermissionsSettingsRequest(baseURL *url.URL) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathFetchDialingPermissionsSettings)

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchDialingPermissionsSettings returns a parsed response.
// GET /v1/Settings
func (c *Client) FetchDialingPermissionsSettings(ctx context.Context, reqEditors ...client.RequestEditorFn) (*FetchDialingPermissionsSettingsResponse, error) {
	req, err := newFetchDialingPermissionsSettingsRequest(c.BaseURL)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchDialingPermissionsSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoiceV1DialingPermissionsDialingPermissionsSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateDialingPermissionsSettings: POST /v1/Settings

type UpdateDialingPermissionsSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *VoiceV1DialingPermissionsDialingPermissionsSettings
}

// Status returns HTTPResponse.Status
func (r UpdateDialingPermissionsSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDialingPermissionsSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateDialingPermissionsSettingsRequestWithBody generates requests for UpdateDialingPermissionsSettings with any type of body
func newUpdateDialingPermissionsSettingsRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathUpdateDialingPermissionsSettings)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateDialingPermissionsSettingsWithBody returns a parsed response.
// POST /v1/Settings
func (c *Client) UpdateDialingPermissionsSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateDialingPermissionsSettingsResponse, error) {
	req, err := newUpdateDialingPermissionsSettingsRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateDialingPermissionsSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest VoiceV1DialingPermissionsDialingPermissionsSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest
	}

	return response, nil
}

// ListSourceIpMapping: GET /v1/SourceIpMappings

type ListSourceIpMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		SourceIpMappings *[]VoiceV1SourceIpMapping `json:"source_ip_mappings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSourceIpMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSourceIpMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSourceIpMappingRequest generates requests for ListSourceIpMapping
func newListSourceIpMappingRequest(baseURL *url.URL, params *ListSourceIpMappingParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListSourceIpMapping)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSourceIpMapping returns a parsed response.
// GET /v1/SourceIpMappings
func (c *Client) ListSourceIpMapping(ctx context.Context, params *ListSourceIpMappingParams, reqEditors ...client.RequestEditorFn) (*ListSourceIpMappingResponse, error) {
	req, err := newListSourceIpMappingRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSourceIpMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			SourceIpMappings *[]VoiceV1SourceIpMapping `json:"source_ip_mappings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSourceIpMapping: POST /v1/SourceIpMappings

type CreateSourceIpMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VoiceV1SourceIpMapping
}

// Status returns HTTPResponse.Status
func (r CreateSourceIpMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSourceIpMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSourceIpMappingRequestWithBody generates requests for CreateSourceIpMapping with any type of body
func newCreateSourceIpMappingRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateSourceIpMapping)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSourceIpMappingWithBody returns a parsed response.
// POST /v1/SourceIpMappings
func (c *Client) CreateSourceIpMappingWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSourceIpMappingResponse, error) {
	req, err := newCreateSourceIpMappingRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSourceIpMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VoiceV1SourceIpMapping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteSourceIpMapping: DELETE /v1/SourceIpMappings/{Sid}

type DeleteSourceIpMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSourceIpMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSourceIpMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSourceIpMappingRequest generates requests for DeleteSourceIpMapping
func newDeleteSourceIpMappingRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSourceIpMappingFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSourceIpMapping returns a parsed response.
// DELETE /v1/SourceIpMappings/{Sid}
func (c *Client) DeleteSourceIpMapping(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSourceIpMappingResponse, error) {
	req, err := newDeleteSourceIpMappingRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSourceIpMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSourceIpMapping: GET /v1/SourceIpMappings/{Sid}

type FetchSourceIpMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoiceV1SourceIpMapping
}

// Status returns HTTPResponse.Status
func (r FetchSourceIpMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSourceIpMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSourceIpMappingRequest generates requests for FetchSourceIpMapping
func newFetchSourceIpMappingRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSourceIpMappingFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSourceIpMapping returns a parsed response.
// GET /v1/SourceIpMappings/{Sid}
func (c *Client) FetchSourceIpMapping(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchSourceIpMappingResponse, error) {
	req, err := newFetchSourceIpMappingRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSourceIpMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoiceV1SourceIpMapping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSourceIpMapping: POST /v1/SourceIpMappings/{Sid}

type UpdateSourceIpMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VoiceV1SourceIpMapping
}

// Status returns HTTPResponse.Status
func (r UpdateSourceIpMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSourceIpMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSourceIpMappingRequestWithBody generates requests for UpdateSourceIpMapping with any type of body
func newUpdateSourceIpMappingRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSourceIpMappingFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSourceIpMappingWithBody returns a parsed response.
// POST /v1/SourceIpMappings/{Sid}
func (c *Client) UpdateSourceIpMappingWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSourceIpMappingResponse, error) {
	req, err := newUpdateSourceIpMappingRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSourceIpMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VoiceV1SourceIpMapping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
