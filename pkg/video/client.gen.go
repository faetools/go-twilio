// Package video provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package video

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/faetools/client"
)

// operation paths

const (
	opPathDeleteCompositionHookFormat               = "./v1/CompositionHooks/%s"
	opPathFetchCompositionHookFormat                = "./v1/CompositionHooks/%s"
	opPathUpdateCompositionHookFormat               = "./v1/CompositionHooks/%s"
	opPathDeleteCompositionFormat                   = "./v1/Compositions/%s"
	opPathFetchCompositionFormat                    = "./v1/Compositions/%s"
	opPathDeleteRecordingFormat                     = "./v1/Recordings/%s"
	opPathFetchRecordingFormat                      = "./v1/Recordings/%s"
	opPathListRoomParticipantFormat                 = "./v1/Rooms/%s/Participants"
	opPathListRoomParticipantPublishedTrackFormat   = "./v1/Rooms/%s/Participants/%s/PublishedTracks"
	opPathFetchRoomParticipantPublishedTrackFormat  = "./v1/Rooms/%s/Participants/%s/PublishedTracks/%s"
	opPathFetchRoomParticipantSubscribeRuleFormat   = "./v1/Rooms/%s/Participants/%s/SubscribeRules"
	opPathUpdateRoomParticipantSubscribeRuleFormat  = "./v1/Rooms/%s/Participants/%s/SubscribeRules"
	opPathListRoomParticipantSubscribedTrackFormat  = "./v1/Rooms/%s/Participants/%s/SubscribedTracks"
	opPathFetchRoomParticipantSubscribedTrackFormat = "./v1/Rooms/%s/Participants/%s/SubscribedTracks/%s"
	opPathFetchRoomParticipantFormat                = "./v1/Rooms/%s/Participants/%s"
	opPathUpdateRoomParticipantFormat               = "./v1/Rooms/%s/Participants/%s"
	opPathFetchRoomRecordingRuleFormat              = "./v1/Rooms/%s/RecordingRules"
	opPathUpdateRoomRecordingRuleFormat             = "./v1/Rooms/%s/RecordingRules"
	opPathListRoomRecordingFormat                   = "./v1/Rooms/%s/Recordings"
	opPathDeleteRoomRecordingFormat                 = "./v1/Rooms/%s/Recordings/%s"
	opPathFetchRoomRecordingFormat                  = "./v1/Rooms/%s/Recordings/%s"
	opPathFetchRoomFormat                           = "./v1/Rooms/%s"
	opPathUpdateRoomFormat                          = "./v1/Rooms/%s"
)

var (
	opPathListCompositionHook       = client.MustParseURL("./v1/CompositionHooks")
	opPathCreateCompositionHook     = client.MustParseURL("./v1/CompositionHooks")
	opPathFetchCompositionSettings  = client.MustParseURL("./v1/CompositionSettings/Default")
	opPathCreateCompositionSettings = client.MustParseURL("./v1/CompositionSettings/Default")
	opPathListComposition           = client.MustParseURL("./v1/Compositions")
	opPathCreateComposition         = client.MustParseURL("./v1/Compositions")
	opPathFetchRecordingSettings    = client.MustParseURL("./v1/RecordingSettings/Default")
	opPathCreateRecordingSettings   = client.MustParseURL("./v1/RecordingSettings/Default")
	opPathListRecording             = client.MustParseURL("./v1/Recordings")
	opPathListRoom                  = client.MustParseURL("./v1/Rooms")
	opPathCreateRoom                = client.MustParseURL("./v1/Rooms")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// ListCompositionHook request
	ListCompositionHook(ctx context.Context, params *ListCompositionHookParams, reqEditors ...client.RequestEditorFn) (*ListCompositionHookResponse, error)

	// CreateCompositionHook request with any body
	CreateCompositionHookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCompositionHookResponse, error)

	// DeleteCompositionHook request
	DeleteCompositionHook(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCompositionHookResponse, error)

	// FetchCompositionHook request
	FetchCompositionHook(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchCompositionHookResponse, error)

	// UpdateCompositionHook request with any body
	UpdateCompositionHookWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateCompositionHookResponse, error)

	// FetchCompositionSettings request
	FetchCompositionSettings(ctx context.Context, reqEditors ...client.RequestEditorFn) (*FetchCompositionSettingsResponse, error)

	// CreateCompositionSettings request with any body
	CreateCompositionSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCompositionSettingsResponse, error)

	// ListComposition request
	ListComposition(ctx context.Context, params *ListCompositionParams, reqEditors ...client.RequestEditorFn) (*ListCompositionResponse, error)

	// CreateComposition request with any body
	CreateCompositionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCompositionResponse, error)

	// DeleteComposition request
	DeleteComposition(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCompositionResponse, error)

	// FetchComposition request
	FetchComposition(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchCompositionResponse, error)

	// FetchRecordingSettings request
	FetchRecordingSettings(ctx context.Context, reqEditors ...client.RequestEditorFn) (*FetchRecordingSettingsResponse, error)

	// CreateRecordingSettings request with any body
	CreateRecordingSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateRecordingSettingsResponse, error)

	// ListRecording request
	ListRecording(ctx context.Context, params *ListRecordingParams, reqEditors ...client.RequestEditorFn) (*ListRecordingResponse, error)

	// DeleteRecording request
	DeleteRecording(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteRecordingResponse, error)

	// FetchRecording request
	FetchRecording(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchRecordingResponse, error)

	// ListRoom request
	ListRoom(ctx context.Context, params *ListRoomParams, reqEditors ...client.RequestEditorFn) (*ListRoomResponse, error)

	// CreateRoom request with any body
	CreateRoomWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateRoomResponse, error)

	// ListRoomParticipant request
	ListRoomParticipant(ctx context.Context, roomSid string, params *ListRoomParticipantParams, reqEditors ...client.RequestEditorFn) (*ListRoomParticipantResponse, error)

	// ListRoomParticipantPublishedTrack request
	ListRoomParticipantPublishedTrack(ctx context.Context, roomSid string, participantSid string, params *ListRoomParticipantPublishedTrackParams, reqEditors ...client.RequestEditorFn) (*ListRoomParticipantPublishedTrackResponse, error)

	// FetchRoomParticipantPublishedTrack request
	FetchRoomParticipantPublishedTrack(ctx context.Context, roomSid string, participantSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchRoomParticipantPublishedTrackResponse, error)

	// FetchRoomParticipantSubscribeRule request
	FetchRoomParticipantSubscribeRule(ctx context.Context, roomSid string, participantSid string, reqEditors ...client.RequestEditorFn) (*FetchRoomParticipantSubscribeRuleResponse, error)

	// UpdateRoomParticipantSubscribeRule request with any body
	UpdateRoomParticipantSubscribeRuleWithBody(ctx context.Context, roomSid string, participantSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateRoomParticipantSubscribeRuleResponse, error)

	// ListRoomParticipantSubscribedTrack request
	ListRoomParticipantSubscribedTrack(ctx context.Context, roomSid string, participantSid string, params *ListRoomParticipantSubscribedTrackParams, reqEditors ...client.RequestEditorFn) (*ListRoomParticipantSubscribedTrackResponse, error)

	// FetchRoomParticipantSubscribedTrack request
	FetchRoomParticipantSubscribedTrack(ctx context.Context, roomSid string, participantSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchRoomParticipantSubscribedTrackResponse, error)

	// FetchRoomParticipant request
	FetchRoomParticipant(ctx context.Context, roomSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchRoomParticipantResponse, error)

	// UpdateRoomParticipant request with any body
	UpdateRoomParticipantWithBody(ctx context.Context, roomSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateRoomParticipantResponse, error)

	// FetchRoomRecordingRule request
	FetchRoomRecordingRule(ctx context.Context, roomSid string, reqEditors ...client.RequestEditorFn) (*FetchRoomRecordingRuleResponse, error)

	// UpdateRoomRecordingRule request with any body
	UpdateRoomRecordingRuleWithBody(ctx context.Context, roomSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateRoomRecordingRuleResponse, error)

	// ListRoomRecording request
	ListRoomRecording(ctx context.Context, roomSid string, params *ListRoomRecordingParams, reqEditors ...client.RequestEditorFn) (*ListRoomRecordingResponse, error)

	// DeleteRoomRecording request
	DeleteRoomRecording(ctx context.Context, roomSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteRoomRecordingResponse, error)

	// FetchRoomRecording request
	FetchRoomRecording(ctx context.Context, roomSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchRoomRecordingResponse, error)

	// FetchRoom request
	FetchRoom(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchRoomResponse, error)

	// UpdateRoom request with any body
	UpdateRoomWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateRoomResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// ListCompositionHook: GET /v1/CompositionHooks

type ListCompositionHookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CompositionHooks *[]VideoV1CompositionHook `json:"composition_hooks,omitempty"`
		Meta             *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCompositionHookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCompositionHookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListCompositionHookRequest generates requests for ListCompositionHook
func newListCompositionHookRequest(baseURL *url.URL, params *ListCompositionHookParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListCompositionHook)

	q := queryURL.Query()

	if params.Enabled != nil {
		if err := client.AddQueryParam(q, "Enabled", *params.Enabled); err != nil {
			return nil, err
		}
	}

	if params.DateCreatedAfter != nil {
		if err := client.AddQueryParam(q, "DateCreatedAfter", *params.DateCreatedAfter); err != nil {
			return nil, err
		}
	}

	if params.DateCreatedBefore != nil {
		if err := client.AddQueryParam(q, "DateCreatedBefore", *params.DateCreatedBefore); err != nil {
			return nil, err
		}
	}

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListCompositionHook returns a parsed response.
// GET /v1/CompositionHooks
func (c *Client) ListCompositionHook(ctx context.Context, params *ListCompositionHookParams, reqEditors ...client.RequestEditorFn) (*ListCompositionHookResponse, error) {
	req, err := newListCompositionHookRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListCompositionHookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CompositionHooks *[]VideoV1CompositionHook `json:"composition_hooks,omitempty"`
			Meta             *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateCompositionHook: POST /v1/CompositionHooks

type CreateCompositionHookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VideoV1CompositionHook
}

// Status returns HTTPResponse.Status
func (r CreateCompositionHookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCompositionHookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateCompositionHookRequestWithBody generates requests for CreateCompositionHook with any type of body
func newCreateCompositionHookRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateCompositionHook)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateCompositionHookWithBody returns a parsed response.
// POST /v1/CompositionHooks
func (c *Client) CreateCompositionHookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCompositionHookResponse, error) {
	req, err := newCreateCompositionHookRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateCompositionHookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VideoV1CompositionHook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteCompositionHook: DELETE /v1/CompositionHooks/{Sid}

type DeleteCompositionHookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCompositionHookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCompositionHookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteCompositionHookRequest generates requests for DeleteCompositionHook
func newDeleteCompositionHookRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteCompositionHookFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteCompositionHook returns a parsed response.
// DELETE /v1/CompositionHooks/{Sid}
func (c *Client) DeleteCompositionHook(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCompositionHookResponse, error) {
	req, err := newDeleteCompositionHookRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteCompositionHookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchCompositionHook: GET /v1/CompositionHooks/{Sid}

type FetchCompositionHookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VideoV1CompositionHook
}

// Status returns HTTPResponse.Status
func (r FetchCompositionHookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchCompositionHookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchCompositionHookRequest generates requests for FetchCompositionHook
func newFetchCompositionHookRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchCompositionHookFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchCompositionHook returns a parsed response.
// GET /v1/CompositionHooks/{Sid}
func (c *Client) FetchCompositionHook(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchCompositionHookResponse, error) {
	req, err := newFetchCompositionHookRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchCompositionHookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VideoV1CompositionHook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateCompositionHook: POST /v1/CompositionHooks/{Sid}

type UpdateCompositionHookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VideoV1CompositionHook
}

// Status returns HTTPResponse.Status
func (r UpdateCompositionHookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCompositionHookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateCompositionHookRequestWithBody generates requests for UpdateCompositionHook with any type of body
func newUpdateCompositionHookRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateCompositionHookFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateCompositionHookWithBody returns a parsed response.
// POST /v1/CompositionHooks/{Sid}
func (c *Client) UpdateCompositionHookWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateCompositionHookResponse, error) {
	req, err := newUpdateCompositionHookRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateCompositionHookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VideoV1CompositionHook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchCompositionSettings: GET /v1/CompositionSettings/Default

type FetchCompositionSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VideoV1CompositionSettings
}

// Status returns HTTPResponse.Status
func (r FetchCompositionSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchCompositionSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchCompositionSettingsRequest generates requests for FetchCompositionSettings
func newFetchCompositionSettingsRequest(baseURL *url.URL) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathFetchCompositionSettings)

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchCompositionSettings returns a parsed response.
// GET /v1/CompositionSettings/Default
func (c *Client) FetchCompositionSettings(ctx context.Context, reqEditors ...client.RequestEditorFn) (*FetchCompositionSettingsResponse, error) {
	req, err := newFetchCompositionSettingsRequest(c.BaseURL)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchCompositionSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VideoV1CompositionSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateCompositionSettings: POST /v1/CompositionSettings/Default

type CreateCompositionSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VideoV1CompositionSettings
}

// Status returns HTTPResponse.Status
func (r CreateCompositionSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCompositionSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateCompositionSettingsRequestWithBody generates requests for CreateCompositionSettings with any type of body
func newCreateCompositionSettingsRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateCompositionSettings)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateCompositionSettingsWithBody returns a parsed response.
// POST /v1/CompositionSettings/Default
func (c *Client) CreateCompositionSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCompositionSettingsResponse, error) {
	req, err := newCreateCompositionSettingsRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateCompositionSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VideoV1CompositionSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListComposition: GET /v1/Compositions

type ListCompositionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Compositions *[]VideoV1Composition `json:"compositions,omitempty"`
		Meta         *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCompositionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCompositionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListCompositionRequest generates requests for ListComposition
func newListCompositionRequest(baseURL *url.URL, params *ListCompositionParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListComposition)

	q := queryURL.Query()

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.DateCreatedAfter != nil {
		if err := client.AddQueryParam(q, "DateCreatedAfter", *params.DateCreatedAfter); err != nil {
			return nil, err
		}
	}

	if params.DateCreatedBefore != nil {
		if err := client.AddQueryParam(q, "DateCreatedBefore", *params.DateCreatedBefore); err != nil {
			return nil, err
		}
	}

	if params.RoomSid != nil {
		if err := client.AddQueryParam(q, "RoomSid", *params.RoomSid); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListComposition returns a parsed response.
// GET /v1/Compositions
func (c *Client) ListComposition(ctx context.Context, params *ListCompositionParams, reqEditors ...client.RequestEditorFn) (*ListCompositionResponse, error) {
	req, err := newListCompositionRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListCompositionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Compositions *[]VideoV1Composition `json:"compositions,omitempty"`
			Meta         *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateComposition: POST /v1/Compositions

type CreateCompositionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VideoV1Composition
}

// Status returns HTTPResponse.Status
func (r CreateCompositionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCompositionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateCompositionRequestWithBody generates requests for CreateComposition with any type of body
func newCreateCompositionRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateComposition)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateCompositionWithBody returns a parsed response.
// POST /v1/Compositions
func (c *Client) CreateCompositionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCompositionResponse, error) {
	req, err := newCreateCompositionRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateCompositionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VideoV1Composition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteComposition: DELETE /v1/Compositions/{Sid}

type DeleteCompositionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCompositionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCompositionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteCompositionRequest generates requests for DeleteComposition
func newDeleteCompositionRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteCompositionFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteComposition returns a parsed response.
// DELETE /v1/Compositions/{Sid}
func (c *Client) DeleteComposition(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCompositionResponse, error) {
	req, err := newDeleteCompositionRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteCompositionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchComposition: GET /v1/Compositions/{Sid}

type FetchCompositionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VideoV1Composition
}

// Status returns HTTPResponse.Status
func (r FetchCompositionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchCompositionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchCompositionRequest generates requests for FetchComposition
func newFetchCompositionRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchCompositionFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchComposition returns a parsed response.
// GET /v1/Compositions/{Sid}
func (c *Client) FetchComposition(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchCompositionResponse, error) {
	req, err := newFetchCompositionRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchCompositionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VideoV1Composition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchRecordingSettings: GET /v1/RecordingSettings/Default

type FetchRecordingSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VideoV1RecordingSettings
}

// Status returns HTTPResponse.Status
func (r FetchRecordingSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchRecordingSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchRecordingSettingsRequest generates requests for FetchRecordingSettings
func newFetchRecordingSettingsRequest(baseURL *url.URL) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathFetchRecordingSettings)

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchRecordingSettings returns a parsed response.
// GET /v1/RecordingSettings/Default
func (c *Client) FetchRecordingSettings(ctx context.Context, reqEditors ...client.RequestEditorFn) (*FetchRecordingSettingsResponse, error) {
	req, err := newFetchRecordingSettingsRequest(c.BaseURL)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchRecordingSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VideoV1RecordingSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateRecordingSettings: POST /v1/RecordingSettings/Default

type CreateRecordingSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VideoV1RecordingSettings
}

// Status returns HTTPResponse.Status
func (r CreateRecordingSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRecordingSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateRecordingSettingsRequestWithBody generates requests for CreateRecordingSettings with any type of body
func newCreateRecordingSettingsRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateRecordingSettings)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateRecordingSettingsWithBody returns a parsed response.
// POST /v1/RecordingSettings/Default
func (c *Client) CreateRecordingSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateRecordingSettingsResponse, error) {
	req, err := newCreateRecordingSettingsRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateRecordingSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VideoV1RecordingSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListRecording: GET /v1/Recordings

type ListRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Recordings *[]VideoV1Recording `json:"recordings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListRecordingRequest generates requests for ListRecording
func newListRecordingRequest(baseURL *url.URL, params *ListRecordingParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListRecording)

	q := queryURL.Query()

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.SourceSid != nil {
		if err := client.AddQueryParam(q, "SourceSid", *params.SourceSid); err != nil {
			return nil, err
		}
	}

	if params.GroupingSid != nil {
		if err := client.AddQueryParam(q, "GroupingSid", *params.GroupingSid); err != nil {
			return nil, err
		}
	}

	if params.DateCreatedAfter != nil {
		if err := client.AddQueryParam(q, "DateCreatedAfter", *params.DateCreatedAfter); err != nil {
			return nil, err
		}
	}

	if params.DateCreatedBefore != nil {
		if err := client.AddQueryParam(q, "DateCreatedBefore", *params.DateCreatedBefore); err != nil {
			return nil, err
		}
	}

	if params.MediaType != nil {
		if err := client.AddQueryParam(q, "MediaType", *params.MediaType); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListRecording returns a parsed response.
// GET /v1/Recordings
func (c *Client) ListRecording(ctx context.Context, params *ListRecordingParams, reqEditors ...client.RequestEditorFn) (*ListRecordingResponse, error) {
	req, err := newListRecordingRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Recordings *[]VideoV1Recording `json:"recordings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteRecording: DELETE /v1/Recordings/{Sid}

type DeleteRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteRecordingRequest generates requests for DeleteRecording
func newDeleteRecordingRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteRecordingFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteRecording returns a parsed response.
// DELETE /v1/Recordings/{Sid}
func (c *Client) DeleteRecording(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteRecordingResponse, error) {
	req, err := newDeleteRecordingRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchRecording: GET /v1/Recordings/{Sid}

type FetchRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VideoV1Recording
}

// Status returns HTTPResponse.Status
func (r FetchRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchRecordingRequest generates requests for FetchRecording
func newFetchRecordingRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchRecordingFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchRecording returns a parsed response.
// GET /v1/Recordings/{Sid}
func (c *Client) FetchRecording(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchRecordingResponse, error) {
	req, err := newFetchRecordingRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VideoV1Recording
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListRoom: GET /v1/Rooms

type ListRoomResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Rooms *[]VideoV1Room `json:"rooms,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRoomResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRoomResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListRoomRequest generates requests for ListRoom
func newListRoomRequest(baseURL *url.URL, params *ListRoomParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListRoom)

	q := queryURL.Query()

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.UniqueName != nil {
		if err := client.AddQueryParam(q, "UniqueName", *params.UniqueName); err != nil {
			return nil, err
		}
	}

	if params.DateCreatedAfter != nil {
		if err := client.AddQueryParam(q, "DateCreatedAfter", *params.DateCreatedAfter); err != nil {
			return nil, err
		}
	}

	if params.DateCreatedBefore != nil {
		if err := client.AddQueryParam(q, "DateCreatedBefore", *params.DateCreatedBefore); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListRoom returns a parsed response.
// GET /v1/Rooms
func (c *Client) ListRoom(ctx context.Context, params *ListRoomParams, reqEditors ...client.RequestEditorFn) (*ListRoomResponse, error) {
	req, err := newListRoomRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListRoomResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Rooms *[]VideoV1Room `json:"rooms,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateRoom: POST /v1/Rooms

type CreateRoomResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VideoV1Room
}

// Status returns HTTPResponse.Status
func (r CreateRoomResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRoomResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateRoomRequestWithBody generates requests for CreateRoom with any type of body
func newCreateRoomRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateRoom)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateRoomWithBody returns a parsed response.
// POST /v1/Rooms
func (c *Client) CreateRoomWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateRoomResponse, error) {
	req, err := newCreateRoomRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateRoomResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VideoV1Room
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListRoomParticipant: GET /v1/Rooms/{RoomSid}/Participants

type ListRoomParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Participants *[]VideoV1RoomRoomParticipant `json:"participants,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRoomParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRoomParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListRoomParticipantRequest generates requests for ListRoomParticipant
func newListRoomParticipantRequest(baseURL *url.URL, roomSid string, params *ListRoomParticipantParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("RoomSid", roomSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListRoomParticipantFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.Identity != nil {
		if err := client.AddQueryParam(q, "Identity", *params.Identity); err != nil {
			return nil, err
		}
	}

	if params.DateCreatedAfter != nil {
		if err := client.AddQueryParam(q, "DateCreatedAfter", *params.DateCreatedAfter); err != nil {
			return nil, err
		}
	}

	if params.DateCreatedBefore != nil {
		if err := client.AddQueryParam(q, "DateCreatedBefore", *params.DateCreatedBefore); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListRoomParticipant returns a parsed response.
// GET /v1/Rooms/{RoomSid}/Participants
func (c *Client) ListRoomParticipant(ctx context.Context, roomSid string, params *ListRoomParticipantParams, reqEditors ...client.RequestEditorFn) (*ListRoomParticipantResponse, error) {
	req, err := newListRoomParticipantRequest(c.BaseURL, roomSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListRoomParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Participants *[]VideoV1RoomRoomParticipant `json:"participants,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListRoomParticipantPublishedTrack: GET /v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/PublishedTracks

type ListRoomParticipantPublishedTrackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		PublishedTracks *[]VideoV1RoomRoomParticipantRoomParticipantPublishedTrack `json:"published_tracks,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRoomParticipantPublishedTrackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRoomParticipantPublishedTrackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListRoomParticipantPublishedTrackRequest generates requests for ListRoomParticipantPublishedTrack
func newListRoomParticipantPublishedTrackRequest(baseURL *url.URL, roomSid string, participantSid string, params *ListRoomParticipantPublishedTrackParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("RoomSid", roomSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ParticipantSid", participantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListRoomParticipantPublishedTrackFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListRoomParticipantPublishedTrack returns a parsed response.
// GET /v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/PublishedTracks
func (c *Client) ListRoomParticipantPublishedTrack(ctx context.Context, roomSid string, participantSid string, params *ListRoomParticipantPublishedTrackParams, reqEditors ...client.RequestEditorFn) (*ListRoomParticipantPublishedTrackResponse, error) {
	req, err := newListRoomParticipantPublishedTrackRequest(c.BaseURL, roomSid, participantSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListRoomParticipantPublishedTrackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			PublishedTracks *[]VideoV1RoomRoomParticipantRoomParticipantPublishedTrack `json:"published_tracks,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchRoomParticipantPublishedTrack: GET /v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/PublishedTracks/{Sid}

type FetchRoomParticipantPublishedTrackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VideoV1RoomRoomParticipantRoomParticipantPublishedTrack
}

// Status returns HTTPResponse.Status
func (r FetchRoomParticipantPublishedTrackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchRoomParticipantPublishedTrackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchRoomParticipantPublishedTrackRequest generates requests for FetchRoomParticipantPublishedTrack
func newFetchRoomParticipantPublishedTrackRequest(baseURL *url.URL, roomSid string, participantSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("RoomSid", roomSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ParticipantSid", participantSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchRoomParticipantPublishedTrackFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchRoomParticipantPublishedTrack returns a parsed response.
// GET /v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/PublishedTracks/{Sid}
func (c *Client) FetchRoomParticipantPublishedTrack(ctx context.Context, roomSid string, participantSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchRoomParticipantPublishedTrackResponse, error) {
	req, err := newFetchRoomParticipantPublishedTrackRequest(c.BaseURL, roomSid, participantSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchRoomParticipantPublishedTrackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VideoV1RoomRoomParticipantRoomParticipantPublishedTrack
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchRoomParticipantSubscribeRule: GET /v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/SubscribeRules

type FetchRoomParticipantSubscribeRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VideoV1RoomRoomParticipantRoomParticipantSubscribeRule
}

// Status returns HTTPResponse.Status
func (r FetchRoomParticipantSubscribeRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchRoomParticipantSubscribeRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchRoomParticipantSubscribeRuleRequest generates requests for FetchRoomParticipantSubscribeRule
func newFetchRoomParticipantSubscribeRuleRequest(baseURL *url.URL, roomSid string, participantSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("RoomSid", roomSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ParticipantSid", participantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchRoomParticipantSubscribeRuleFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchRoomParticipantSubscribeRule returns a parsed response.
// GET /v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/SubscribeRules
func (c *Client) FetchRoomParticipantSubscribeRule(ctx context.Context, roomSid string, participantSid string, reqEditors ...client.RequestEditorFn) (*FetchRoomParticipantSubscribeRuleResponse, error) {
	req, err := newFetchRoomParticipantSubscribeRuleRequest(c.BaseURL, roomSid, participantSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchRoomParticipantSubscribeRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VideoV1RoomRoomParticipantRoomParticipantSubscribeRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateRoomParticipantSubscribeRule: POST /v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/SubscribeRules

type UpdateRoomParticipantSubscribeRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *VideoV1RoomRoomParticipantRoomParticipantSubscribeRule
}

// Status returns HTTPResponse.Status
func (r UpdateRoomParticipantSubscribeRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoomParticipantSubscribeRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateRoomParticipantSubscribeRuleRequestWithBody generates requests for UpdateRoomParticipantSubscribeRule with any type of body
func newUpdateRoomParticipantSubscribeRuleRequestWithBody(baseURL *url.URL, roomSid string, participantSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("RoomSid", roomSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ParticipantSid", participantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateRoomParticipantSubscribeRuleFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateRoomParticipantSubscribeRuleWithBody returns a parsed response.
// POST /v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/SubscribeRules
func (c *Client) UpdateRoomParticipantSubscribeRuleWithBody(ctx context.Context, roomSid string, participantSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateRoomParticipantSubscribeRuleResponse, error) {
	req, err := newUpdateRoomParticipantSubscribeRuleRequestWithBody(c.BaseURL, roomSid, participantSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateRoomParticipantSubscribeRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest VideoV1RoomRoomParticipantRoomParticipantSubscribeRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest
	}

	return response, nil
}

// ListRoomParticipantSubscribedTrack: GET /v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/SubscribedTracks

type ListRoomParticipantSubscribedTrackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		SubscribedTracks *[]VideoV1RoomRoomParticipantRoomParticipantSubscribedTrack `json:"subscribed_tracks,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRoomParticipantSubscribedTrackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRoomParticipantSubscribedTrackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListRoomParticipantSubscribedTrackRequest generates requests for ListRoomParticipantSubscribedTrack
func newListRoomParticipantSubscribedTrackRequest(baseURL *url.URL, roomSid string, participantSid string, params *ListRoomParticipantSubscribedTrackParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("RoomSid", roomSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ParticipantSid", participantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListRoomParticipantSubscribedTrackFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListRoomParticipantSubscribedTrack returns a parsed response.
// GET /v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/SubscribedTracks
func (c *Client) ListRoomParticipantSubscribedTrack(ctx context.Context, roomSid string, participantSid string, params *ListRoomParticipantSubscribedTrackParams, reqEditors ...client.RequestEditorFn) (*ListRoomParticipantSubscribedTrackResponse, error) {
	req, err := newListRoomParticipantSubscribedTrackRequest(c.BaseURL, roomSid, participantSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListRoomParticipantSubscribedTrackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			SubscribedTracks *[]VideoV1RoomRoomParticipantRoomParticipantSubscribedTrack `json:"subscribed_tracks,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchRoomParticipantSubscribedTrack: GET /v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/SubscribedTracks/{Sid}

type FetchRoomParticipantSubscribedTrackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VideoV1RoomRoomParticipantRoomParticipantSubscribedTrack
}

// Status returns HTTPResponse.Status
func (r FetchRoomParticipantSubscribedTrackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchRoomParticipantSubscribedTrackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchRoomParticipantSubscribedTrackRequest generates requests for FetchRoomParticipantSubscribedTrack
func newFetchRoomParticipantSubscribedTrackRequest(baseURL *url.URL, roomSid string, participantSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("RoomSid", roomSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ParticipantSid", participantSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchRoomParticipantSubscribedTrackFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchRoomParticipantSubscribedTrack returns a parsed response.
// GET /v1/Rooms/{RoomSid}/Participants/{ParticipantSid}/SubscribedTracks/{Sid}
func (c *Client) FetchRoomParticipantSubscribedTrack(ctx context.Context, roomSid string, participantSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchRoomParticipantSubscribedTrackResponse, error) {
	req, err := newFetchRoomParticipantSubscribedTrackRequest(c.BaseURL, roomSid, participantSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchRoomParticipantSubscribedTrackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VideoV1RoomRoomParticipantRoomParticipantSubscribedTrack
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchRoomParticipant: GET /v1/Rooms/{RoomSid}/Participants/{Sid}

type FetchRoomParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VideoV1RoomRoomParticipant
}

// Status returns HTTPResponse.Status
func (r FetchRoomParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchRoomParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchRoomParticipantRequest generates requests for FetchRoomParticipant
func newFetchRoomParticipantRequest(baseURL *url.URL, roomSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("RoomSid", roomSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchRoomParticipantFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchRoomParticipant returns a parsed response.
// GET /v1/Rooms/{RoomSid}/Participants/{Sid}
func (c *Client) FetchRoomParticipant(ctx context.Context, roomSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchRoomParticipantResponse, error) {
	req, err := newFetchRoomParticipantRequest(c.BaseURL, roomSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchRoomParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VideoV1RoomRoomParticipant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateRoomParticipant: POST /v1/Rooms/{RoomSid}/Participants/{Sid}

type UpdateRoomParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VideoV1RoomRoomParticipant
}

// Status returns HTTPResponse.Status
func (r UpdateRoomParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoomParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateRoomParticipantRequestWithBody generates requests for UpdateRoomParticipant with any type of body
func newUpdateRoomParticipantRequestWithBody(baseURL *url.URL, roomSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("RoomSid", roomSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateRoomParticipantFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateRoomParticipantWithBody returns a parsed response.
// POST /v1/Rooms/{RoomSid}/Participants/{Sid}
func (c *Client) UpdateRoomParticipantWithBody(ctx context.Context, roomSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateRoomParticipantResponse, error) {
	req, err := newUpdateRoomParticipantRequestWithBody(c.BaseURL, roomSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateRoomParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VideoV1RoomRoomParticipant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchRoomRecordingRule: GET /v1/Rooms/{RoomSid}/RecordingRules

type FetchRoomRecordingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VideoV1RoomRoomRecordingRule
}

// Status returns HTTPResponse.Status
func (r FetchRoomRecordingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchRoomRecordingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchRoomRecordingRuleRequest generates requests for FetchRoomRecordingRule
func newFetchRoomRecordingRuleRequest(baseURL *url.URL, roomSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("RoomSid", roomSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchRoomRecordingRuleFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchRoomRecordingRule returns a parsed response.
// GET /v1/Rooms/{RoomSid}/RecordingRules
func (c *Client) FetchRoomRecordingRule(ctx context.Context, roomSid string, reqEditors ...client.RequestEditorFn) (*FetchRoomRecordingRuleResponse, error) {
	req, err := newFetchRoomRecordingRuleRequest(c.BaseURL, roomSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchRoomRecordingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VideoV1RoomRoomRecordingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateRoomRecordingRule: POST /v1/Rooms/{RoomSid}/RecordingRules

type UpdateRoomRecordingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *VideoV1RoomRoomRecordingRule
}

// Status returns HTTPResponse.Status
func (r UpdateRoomRecordingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoomRecordingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateRoomRecordingRuleRequestWithBody generates requests for UpdateRoomRecordingRule with any type of body
func newUpdateRoomRecordingRuleRequestWithBody(baseURL *url.URL, roomSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("RoomSid", roomSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateRoomRecordingRuleFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateRoomRecordingRuleWithBody returns a parsed response.
// POST /v1/Rooms/{RoomSid}/RecordingRules
func (c *Client) UpdateRoomRecordingRuleWithBody(ctx context.Context, roomSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateRoomRecordingRuleResponse, error) {
	req, err := newUpdateRoomRecordingRuleRequestWithBody(c.BaseURL, roomSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateRoomRecordingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest VideoV1RoomRoomRecordingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest
	}

	return response, nil
}

// ListRoomRecording: GET /v1/Rooms/{RoomSid}/Recordings

type ListRoomRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Recordings *[]VideoV1RoomRoomRecording `json:"recordings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRoomRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRoomRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListRoomRecordingRequest generates requests for ListRoomRecording
func newListRoomRecordingRequest(baseURL *url.URL, roomSid string, params *ListRoomRecordingParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("RoomSid", roomSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListRoomRecordingFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.SourceSid != nil {
		if err := client.AddQueryParam(q, "SourceSid", *params.SourceSid); err != nil {
			return nil, err
		}
	}

	if params.DateCreatedAfter != nil {
		if err := client.AddQueryParam(q, "DateCreatedAfter", *params.DateCreatedAfter); err != nil {
			return nil, err
		}
	}

	if params.DateCreatedBefore != nil {
		if err := client.AddQueryParam(q, "DateCreatedBefore", *params.DateCreatedBefore); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListRoomRecording returns a parsed response.
// GET /v1/Rooms/{RoomSid}/Recordings
func (c *Client) ListRoomRecording(ctx context.Context, roomSid string, params *ListRoomRecordingParams, reqEditors ...client.RequestEditorFn) (*ListRoomRecordingResponse, error) {
	req, err := newListRoomRecordingRequest(c.BaseURL, roomSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListRoomRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Recordings *[]VideoV1RoomRoomRecording `json:"recordings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteRoomRecording: DELETE /v1/Rooms/{RoomSid}/Recordings/{Sid}

type DeleteRoomRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRoomRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoomRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteRoomRecordingRequest generates requests for DeleteRoomRecording
func newDeleteRoomRecordingRequest(baseURL *url.URL, roomSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("RoomSid", roomSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteRoomRecordingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteRoomRecording returns a parsed response.
// DELETE /v1/Rooms/{RoomSid}/Recordings/{Sid}
func (c *Client) DeleteRoomRecording(ctx context.Context, roomSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteRoomRecordingResponse, error) {
	req, err := newDeleteRoomRecordingRequest(c.BaseURL, roomSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteRoomRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchRoomRecording: GET /v1/Rooms/{RoomSid}/Recordings/{Sid}

type FetchRoomRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VideoV1RoomRoomRecording
}

// Status returns HTTPResponse.Status
func (r FetchRoomRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchRoomRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchRoomRecordingRequest generates requests for FetchRoomRecording
func newFetchRoomRecordingRequest(baseURL *url.URL, roomSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("RoomSid", roomSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchRoomRecordingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchRoomRecording returns a parsed response.
// GET /v1/Rooms/{RoomSid}/Recordings/{Sid}
func (c *Client) FetchRoomRecording(ctx context.Context, roomSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchRoomRecordingResponse, error) {
	req, err := newFetchRoomRecordingRequest(c.BaseURL, roomSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchRoomRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VideoV1RoomRoomRecording
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchRoom: GET /v1/Rooms/{Sid}

type FetchRoomResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VideoV1Room
}

// Status returns HTTPResponse.Status
func (r FetchRoomResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchRoomResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchRoomRequest generates requests for FetchRoom
func newFetchRoomRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchRoomFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchRoom returns a parsed response.
// GET /v1/Rooms/{Sid}
func (c *Client) FetchRoom(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchRoomResponse, error) {
	req, err := newFetchRoomRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchRoomResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VideoV1Room
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateRoom: POST /v1/Rooms/{Sid}

type UpdateRoomResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VideoV1Room
}

// Status returns HTTPResponse.Status
func (r UpdateRoomResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoomResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateRoomRequestWithBody generates requests for UpdateRoom with any type of body
func newUpdateRoomRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateRoomFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateRoomWithBody returns a parsed response.
// POST /v1/Rooms/{Sid}
func (c *Client) UpdateRoomWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateRoomResponse, error) {
	req, err := newUpdateRoomRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateRoomResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VideoV1Room
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
