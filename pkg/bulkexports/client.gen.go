// Package bulkexports provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package bulkexports

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/faetools/client"
)

// operation paths

const (
	opPathDeleteJobFormat                 = "./v1/Exports/Jobs/%s"
	opPathFetchJobFormat                  = "./v1/Exports/Jobs/%s"
	opPathFetchExportFormat               = "./v1/Exports/%s"
	opPathFetchExportConfigurationFormat  = "./v1/Exports/%s/Configuration"
	opPathUpdateExportConfigurationFormat = "./v1/Exports/%s/Configuration"
	opPathListDayFormat                   = "./v1/Exports/%s/Days"
	opPathFetchDayFormat                  = "./v1/Exports/%s/Days/%s"
	opPathListExportCustomJobFormat       = "./v1/Exports/%s/Jobs"
	opPathCreateExportCustomJobFormat     = "./v1/Exports/%s/Jobs"
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// DeleteJob request
	DeleteJob(ctx context.Context, jobSid string, reqEditors ...client.RequestEditorFn) (*DeleteJobResponse, error)

	// FetchJob request
	FetchJob(ctx context.Context, jobSid string, reqEditors ...client.RequestEditorFn) (*FetchJobResponse, error)

	// FetchExport request
	FetchExport(ctx context.Context, resourceType string, reqEditors ...client.RequestEditorFn) (*FetchExportResponse, error)

	// FetchExportConfiguration request
	FetchExportConfiguration(ctx context.Context, resourceType string, reqEditors ...client.RequestEditorFn) (*FetchExportConfigurationResponse, error)

	// UpdateExportConfiguration request with any body
	UpdateExportConfigurationWithBody(ctx context.Context, resourceType string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateExportConfigurationResponse, error)

	// ListDay request
	ListDay(ctx context.Context, resourceType string, params *ListDayParams, reqEditors ...client.RequestEditorFn) (*ListDayResponse, error)

	// FetchDay request
	FetchDay(ctx context.Context, resourceType string, day string, reqEditors ...client.RequestEditorFn) (*FetchDayResponse, error)

	// ListExportCustomJob request
	ListExportCustomJob(ctx context.Context, resourceType string, params *ListExportCustomJobParams, reqEditors ...client.RequestEditorFn) (*ListExportCustomJobResponse, error)

	// CreateExportCustomJob request with any body
	CreateExportCustomJobWithBody(ctx context.Context, resourceType string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateExportCustomJobResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// DeleteJob: DELETE /v1/Exports/Jobs/{JobSid}

type DeleteJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteJobRequest generates requests for DeleteJob
func newDeleteJobRequest(baseURL *url.URL, jobSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("JobSid", jobSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteJobFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteJob returns a parsed response.
// DELETE /v1/Exports/Jobs/{JobSid}
func (c *Client) DeleteJob(ctx context.Context, jobSid string, reqEditors ...client.RequestEditorFn) (*DeleteJobResponse, error) {
	req, err := newDeleteJobRequest(c.BaseURL, jobSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchJob: GET /v1/Exports/Jobs/{JobSid}

type FetchJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BulkexportsV1ExportJob
}

// Status returns HTTPResponse.Status
func (r FetchJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchJobRequest generates requests for FetchJob
func newFetchJobRequest(baseURL *url.URL, jobSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("JobSid", jobSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchJobFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchJob returns a parsed response.
// GET /v1/Exports/Jobs/{JobSid}
func (c *Client) FetchJob(ctx context.Context, jobSid string, reqEditors ...client.RequestEditorFn) (*FetchJobResponse, error) {
	req, err := newFetchJobRequest(c.BaseURL, jobSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BulkexportsV1ExportJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchExport: GET /v1/Exports/{ResourceType}

type FetchExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BulkexportsV1Export
}

// Status returns HTTPResponse.Status
func (r FetchExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchExportRequest generates requests for FetchExport
func newFetchExportRequest(baseURL *url.URL, resourceType string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ResourceType", resourceType)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchExportFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchExport returns a parsed response.
// GET /v1/Exports/{ResourceType}
func (c *Client) FetchExport(ctx context.Context, resourceType string, reqEditors ...client.RequestEditorFn) (*FetchExportResponse, error) {
	req, err := newFetchExportRequest(c.BaseURL, resourceType)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BulkexportsV1Export
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchExportConfiguration: GET /v1/Exports/{ResourceType}/Configuration

type FetchExportConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BulkexportsV1ExportConfiguration
}

// Status returns HTTPResponse.Status
func (r FetchExportConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchExportConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchExportConfigurationRequest generates requests for FetchExportConfiguration
func newFetchExportConfigurationRequest(baseURL *url.URL, resourceType string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ResourceType", resourceType)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchExportConfigurationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchExportConfiguration returns a parsed response.
// GET /v1/Exports/{ResourceType}/Configuration
func (c *Client) FetchExportConfiguration(ctx context.Context, resourceType string, reqEditors ...client.RequestEditorFn) (*FetchExportConfigurationResponse, error) {
	req, err := newFetchExportConfigurationRequest(c.BaseURL, resourceType)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchExportConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BulkexportsV1ExportConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateExportConfiguration: POST /v1/Exports/{ResourceType}/Configuration

type UpdateExportConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BulkexportsV1ExportConfiguration
}

// Status returns HTTPResponse.Status
func (r UpdateExportConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateExportConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateExportConfigurationRequestWithBody generates requests for UpdateExportConfiguration with any type of body
func newUpdateExportConfigurationRequestWithBody(baseURL *url.URL, resourceType string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ResourceType", resourceType)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateExportConfigurationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateExportConfigurationWithBody returns a parsed response.
// POST /v1/Exports/{ResourceType}/Configuration
func (c *Client) UpdateExportConfigurationWithBody(ctx context.Context, resourceType string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateExportConfigurationResponse, error) {
	req, err := newUpdateExportConfigurationRequestWithBody(c.BaseURL, resourceType, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateExportConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BulkexportsV1ExportConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListDay: GET /v1/Exports/{ResourceType}/Days

type ListDayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Days *[]BulkexportsV1ExportDay `json:"days,omitempty"`
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListDayRequest generates requests for ListDay
func newListDayRequest(baseURL *url.URL, resourceType string, params *ListDayParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ResourceType", resourceType)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListDayFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListDay returns a parsed response.
// GET /v1/Exports/{ResourceType}/Days
func (c *Client) ListDay(ctx context.Context, resourceType string, params *ListDayParams, reqEditors ...client.RequestEditorFn) (*ListDayResponse, error) {
	req, err := newListDayRequest(c.BaseURL, resourceType, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListDayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Days *[]BulkexportsV1ExportDay `json:"days,omitempty"`
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchDay: GET /v1/Exports/{ResourceType}/Days/{Day}

type FetchDayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON307      *BulkexportsV1ExportDayInstance
}

// Status returns HTTPResponse.Status
func (r FetchDayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchDayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchDayRequest generates requests for FetchDay
func newFetchDayRequest(baseURL *url.URL, resourceType string, day string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ResourceType", resourceType)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Day", day)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchDayFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchDay returns a parsed response.
// GET /v1/Exports/{ResourceType}/Days/{Day}
func (c *Client) FetchDay(ctx context.Context, resourceType string, day string, reqEditors ...client.RequestEditorFn) (*FetchDayResponse, error) {
	req, err := newFetchDayRequest(c.BaseURL, resourceType, day)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchDayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest BulkexportsV1ExportDayInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest
	}

	return response, nil
}

// ListExportCustomJob: GET /v1/Exports/{ResourceType}/Jobs

type ListExportCustomJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Jobs *[]BulkexportsV1ExportExportCustomJob `json:"jobs,omitempty"`
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListExportCustomJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListExportCustomJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListExportCustomJobRequest generates requests for ListExportCustomJob
func newListExportCustomJobRequest(baseURL *url.URL, resourceType string, params *ListExportCustomJobParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ResourceType", resourceType)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListExportCustomJobFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListExportCustomJob returns a parsed response.
// GET /v1/Exports/{ResourceType}/Jobs
func (c *Client) ListExportCustomJob(ctx context.Context, resourceType string, params *ListExportCustomJobParams, reqEditors ...client.RequestEditorFn) (*ListExportCustomJobResponse, error) {
	req, err := newListExportCustomJobRequest(c.BaseURL, resourceType, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListExportCustomJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Jobs *[]BulkexportsV1ExportExportCustomJob `json:"jobs,omitempty"`
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateExportCustomJob: POST /v1/Exports/{ResourceType}/Jobs

type CreateExportCustomJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BulkexportsV1ExportExportCustomJob
}

// Status returns HTTPResponse.Status
func (r CreateExportCustomJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateExportCustomJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateExportCustomJobRequestWithBody generates requests for CreateExportCustomJob with any type of body
func newCreateExportCustomJobRequestWithBody(baseURL *url.URL, resourceType string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ResourceType", resourceType)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateExportCustomJobFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateExportCustomJobWithBody returns a parsed response.
// POST /v1/Exports/{ResourceType}/Jobs
func (c *Client) CreateExportCustomJobWithBody(ctx context.Context, resourceType string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateExportCustomJobResponse, error) {
	req, err := newCreateExportCustomJobRequestWithBody(c.BaseURL, resourceType, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateExportCustomJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BulkexportsV1ExportExportCustomJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}
