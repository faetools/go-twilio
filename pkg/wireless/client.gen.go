// Package wireless provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package wireless

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/faetools/client"
)

// operation paths

const (
	opPathDeleteCommandFormat   = "./v1/Commands/%s"
	opPathFetchCommandFormat    = "./v1/Commands/%s"
	opPathDeleteRatePlanFormat  = "./v1/RatePlans/%s"
	opPathFetchRatePlanFormat   = "./v1/RatePlans/%s"
	opPathUpdateRatePlanFormat  = "./v1/RatePlans/%s"
	opPathDeleteSimFormat       = "./v1/Sims/%s"
	opPathFetchSimFormat        = "./v1/Sims/%s"
	opPathUpdateSimFormat       = "./v1/Sims/%s"
	opPathListDataSessionFormat = "./v1/Sims/%s/DataSessions"
	opPathListUsageRecordFormat = "./v1/Sims/%s/UsageRecords"
)

var (
	opPathListCommand            = client.MustParseURL("./v1/Commands")
	opPathCreateCommand          = client.MustParseURL("./v1/Commands")
	opPathListRatePlan           = client.MustParseURL("./v1/RatePlans")
	opPathCreateRatePlan         = client.MustParseURL("./v1/RatePlans")
	opPathListSim                = client.MustParseURL("./v1/Sims")
	opPathListAccountUsageRecord = client.MustParseURL("./v1/UsageRecords")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// ListCommand request
	ListCommand(ctx context.Context, params *ListCommandParams, reqEditors ...client.RequestEditorFn) (*ListCommandResponse, error)

	// CreateCommand request with any body
	CreateCommandWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCommandResponse, error)

	// DeleteCommand request
	DeleteCommand(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCommandResponse, error)

	// FetchCommand request
	FetchCommand(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchCommandResponse, error)

	// ListRatePlan request
	ListRatePlan(ctx context.Context, params *ListRatePlanParams, reqEditors ...client.RequestEditorFn) (*ListRatePlanResponse, error)

	// CreateRatePlan request with any body
	CreateRatePlanWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateRatePlanResponse, error)

	// DeleteRatePlan request
	DeleteRatePlan(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteRatePlanResponse, error)

	// FetchRatePlan request
	FetchRatePlan(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchRatePlanResponse, error)

	// UpdateRatePlan request with any body
	UpdateRatePlanWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateRatePlanResponse, error)

	// ListSim request
	ListSim(ctx context.Context, params *ListSimParams, reqEditors ...client.RequestEditorFn) (*ListSimResponse, error)

	// DeleteSim request
	DeleteSim(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSimResponse, error)

	// FetchSim request
	FetchSim(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchSimResponse, error)

	// UpdateSim request with any body
	UpdateSimWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSimResponse, error)

	// ListDataSession request
	ListDataSession(ctx context.Context, simSid string, params *ListDataSessionParams, reqEditors ...client.RequestEditorFn) (*ListDataSessionResponse, error)

	// ListUsageRecord request
	ListUsageRecord(ctx context.Context, simSid string, params *ListUsageRecordParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordResponse, error)

	// ListAccountUsageRecord request
	ListAccountUsageRecord(ctx context.Context, params *ListAccountUsageRecordParams, reqEditors ...client.RequestEditorFn) (*ListAccountUsageRecordResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// ListCommand: GET /v1/Commands

type ListCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Commands *[]WirelessV1Command `json:"commands,omitempty"`
		Meta     *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListCommandRequest generates requests for ListCommand
func newListCommandRequest(baseURL *url.URL, params *ListCommandParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListCommand)

	q := queryURL.Query()

	if params.Sim != nil {
		if err := client.AddQueryParam(q, "Sim", *params.Sim); err != nil {
			return nil, err
		}
	}

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.Direction != nil {
		if err := client.AddQueryParam(q, "Direction", *params.Direction); err != nil {
			return nil, err
		}
	}

	if params.Transport != nil {
		if err := client.AddQueryParam(q, "Transport", *params.Transport); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListCommand returns a parsed response.
// GET /v1/Commands
func (c *Client) ListCommand(ctx context.Context, params *ListCommandParams, reqEditors ...client.RequestEditorFn) (*ListCommandResponse, error) {
	req, err := newListCommandRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Commands *[]WirelessV1Command `json:"commands,omitempty"`
			Meta     *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateCommand: POST /v1/Commands

type CreateCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WirelessV1Command
}

// Status returns HTTPResponse.Status
func (r CreateCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateCommandRequestWithBody generates requests for CreateCommand with any type of body
func newCreateCommandRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateCommand)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateCommandWithBody returns a parsed response.
// POST /v1/Commands
func (c *Client) CreateCommandWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCommandResponse, error) {
	req, err := newCreateCommandRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WirelessV1Command
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteCommand: DELETE /v1/Commands/{Sid}

type DeleteCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteCommandRequest generates requests for DeleteCommand
func newDeleteCommandRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteCommandFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteCommand returns a parsed response.
// DELETE /v1/Commands/{Sid}
func (c *Client) DeleteCommand(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCommandResponse, error) {
	req, err := newDeleteCommandRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchCommand: GET /v1/Commands/{Sid}

type FetchCommandResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WirelessV1Command
}

// Status returns HTTPResponse.Status
func (r FetchCommandResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchCommandResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchCommandRequest generates requests for FetchCommand
func newFetchCommandRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchCommandFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchCommand returns a parsed response.
// GET /v1/Commands/{Sid}
func (c *Client) FetchCommand(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchCommandResponse, error) {
	req, err := newFetchCommandRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchCommandResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WirelessV1Command
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListRatePlan: GET /v1/RatePlans

type ListRatePlanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		RatePlans *[]WirelessV1RatePlan `json:"rate_plans,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRatePlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRatePlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListRatePlanRequest generates requests for ListRatePlan
func newListRatePlanRequest(baseURL *url.URL, params *ListRatePlanParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListRatePlan)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListRatePlan returns a parsed response.
// GET /v1/RatePlans
func (c *Client) ListRatePlan(ctx context.Context, params *ListRatePlanParams, reqEditors ...client.RequestEditorFn) (*ListRatePlanResponse, error) {
	req, err := newListRatePlanRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListRatePlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			RatePlans *[]WirelessV1RatePlan `json:"rate_plans,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateRatePlan: POST /v1/RatePlans

type CreateRatePlanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WirelessV1RatePlan
}

// Status returns HTTPResponse.Status
func (r CreateRatePlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRatePlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateRatePlanRequestWithBody generates requests for CreateRatePlan with any type of body
func newCreateRatePlanRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateRatePlan)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateRatePlanWithBody returns a parsed response.
// POST /v1/RatePlans
func (c *Client) CreateRatePlanWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateRatePlanResponse, error) {
	req, err := newCreateRatePlanRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateRatePlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WirelessV1RatePlan
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteRatePlan: DELETE /v1/RatePlans/{Sid}

type DeleteRatePlanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRatePlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRatePlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteRatePlanRequest generates requests for DeleteRatePlan
func newDeleteRatePlanRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteRatePlanFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteRatePlan returns a parsed response.
// DELETE /v1/RatePlans/{Sid}
func (c *Client) DeleteRatePlan(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteRatePlanResponse, error) {
	req, err := newDeleteRatePlanRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteRatePlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchRatePlan: GET /v1/RatePlans/{Sid}

type FetchRatePlanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WirelessV1RatePlan
}

// Status returns HTTPResponse.Status
func (r FetchRatePlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchRatePlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchRatePlanRequest generates requests for FetchRatePlan
func newFetchRatePlanRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchRatePlanFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchRatePlan returns a parsed response.
// GET /v1/RatePlans/{Sid}
func (c *Client) FetchRatePlan(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchRatePlanResponse, error) {
	req, err := newFetchRatePlanRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchRatePlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WirelessV1RatePlan
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateRatePlan: POST /v1/RatePlans/{Sid}

type UpdateRatePlanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WirelessV1RatePlan
}

// Status returns HTTPResponse.Status
func (r UpdateRatePlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRatePlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateRatePlanRequestWithBody generates requests for UpdateRatePlan with any type of body
func newUpdateRatePlanRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateRatePlanFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateRatePlanWithBody returns a parsed response.
// POST /v1/RatePlans/{Sid}
func (c *Client) UpdateRatePlanWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateRatePlanResponse, error) {
	req, err := newUpdateRatePlanRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateRatePlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WirelessV1RatePlan
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSim: GET /v1/Sims

type ListSimResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Sims *[]WirelessV1Sim `json:"sims,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSimResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSimResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSimRequest generates requests for ListSim
func newListSimRequest(baseURL *url.URL, params *ListSimParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListSim)

	q := queryURL.Query()

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.Iccid != nil {
		if err := client.AddQueryParam(q, "Iccid", *params.Iccid); err != nil {
			return nil, err
		}
	}

	if params.RatePlan != nil {
		if err := client.AddQueryParam(q, "RatePlan", *params.RatePlan); err != nil {
			return nil, err
		}
	}

	if params.EId != nil {
		if err := client.AddQueryParam(q, "EId", *params.EId); err != nil {
			return nil, err
		}
	}

	if params.SimRegistrationCode != nil {
		if err := client.AddQueryParam(q, "SimRegistrationCode", *params.SimRegistrationCode); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSim returns a parsed response.
// GET /v1/Sims
func (c *Client) ListSim(ctx context.Context, params *ListSimParams, reqEditors ...client.RequestEditorFn) (*ListSimResponse, error) {
	req, err := newListSimRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSimResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Sims *[]WirelessV1Sim `json:"sims,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteSim: DELETE /v1/Sims/{Sid}

type DeleteSimResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSimResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSimResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSimRequest generates requests for DeleteSim
func newDeleteSimRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSimFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSim returns a parsed response.
// DELETE /v1/Sims/{Sid}
func (c *Client) DeleteSim(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSimResponse, error) {
	req, err := newDeleteSimRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSimResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSim: GET /v1/Sims/{Sid}

type FetchSimResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WirelessV1Sim
}

// Status returns HTTPResponse.Status
func (r FetchSimResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSimResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSimRequest generates requests for FetchSim
func newFetchSimRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSimFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSim returns a parsed response.
// GET /v1/Sims/{Sid}
func (c *Client) FetchSim(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchSimResponse, error) {
	req, err := newFetchSimRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSimResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WirelessV1Sim
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSim: POST /v1/Sims/{Sid}

type UpdateSimResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WirelessV1Sim
}

// Status returns HTTPResponse.Status
func (r UpdateSimResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSimResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSimRequestWithBody generates requests for UpdateSim with any type of body
func newUpdateSimRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSimFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSimWithBody returns a parsed response.
// POST /v1/Sims/{Sid}
func (c *Client) UpdateSimWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSimResponse, error) {
	req, err := newUpdateSimRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSimResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WirelessV1Sim
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListDataSession: GET /v1/Sims/{SimSid}/DataSessions

type ListDataSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DataSessions *[]WirelessV1SimDataSession `json:"data_sessions,omitempty"`
		Meta         *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDataSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDataSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListDataSessionRequest generates requests for ListDataSession
func newListDataSessionRequest(baseURL *url.URL, simSid string, params *ListDataSessionParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("SimSid", simSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListDataSessionFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListDataSession returns a parsed response.
// GET /v1/Sims/{SimSid}/DataSessions
func (c *Client) ListDataSession(ctx context.Context, simSid string, params *ListDataSessionParams, reqEditors ...client.RequestEditorFn) (*ListDataSessionResponse, error) {
	req, err := newListDataSessionRequest(c.BaseURL, simSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListDataSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DataSessions *[]WirelessV1SimDataSession `json:"data_sessions,omitempty"`
			Meta         *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListUsageRecord: GET /v1/Sims/{SimSid}/UsageRecords

type ListUsageRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		UsageRecords *[]WirelessV1SimUsageRecord `json:"usage_records,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUsageRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsageRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListUsageRecordRequest generates requests for ListUsageRecord
func newListUsageRecordRequest(baseURL *url.URL, simSid string, params *ListUsageRecordParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("SimSid", simSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListUsageRecordFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.End != nil {
		if err := client.AddQueryParam(q, "End", *params.End); err != nil {
			return nil, err
		}
	}

	if params.Start != nil {
		if err := client.AddQueryParam(q, "Start", *params.Start); err != nil {
			return nil, err
		}
	}

	if params.Granularity != nil {
		if err := client.AddQueryParam(q, "Granularity", *params.Granularity); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListUsageRecord returns a parsed response.
// GET /v1/Sims/{SimSid}/UsageRecords
func (c *Client) ListUsageRecord(ctx context.Context, simSid string, params *ListUsageRecordParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordResponse, error) {
	req, err := newListUsageRecordRequest(c.BaseURL, simSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListUsageRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			UsageRecords *[]WirelessV1SimUsageRecord `json:"usage_records,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListAccountUsageRecord: GET /v1/UsageRecords

type ListAccountUsageRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		UsageRecords *[]WirelessV1AccountUsageRecord `json:"usage_records,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAccountUsageRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccountUsageRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListAccountUsageRecordRequest generates requests for ListAccountUsageRecord
func newListAccountUsageRecordRequest(baseURL *url.URL, params *ListAccountUsageRecordParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListAccountUsageRecord)

	q := queryURL.Query()

	if params.End != nil {
		if err := client.AddQueryParam(q, "End", *params.End); err != nil {
			return nil, err
		}
	}

	if params.Start != nil {
		if err := client.AddQueryParam(q, "Start", *params.Start); err != nil {
			return nil, err
		}
	}

	if params.Granularity != nil {
		if err := client.AddQueryParam(q, "Granularity", *params.Granularity); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListAccountUsageRecord returns a parsed response.
// GET /v1/UsageRecords
func (c *Client) ListAccountUsageRecord(ctx context.Context, params *ListAccountUsageRecordParams, reqEditors ...client.RequestEditorFn) (*ListAccountUsageRecordResponse, error) {
	req, err := newListAccountUsageRecordRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListAccountUsageRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			UsageRecords *[]WirelessV1AccountUsageRecord `json:"usage_records,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
