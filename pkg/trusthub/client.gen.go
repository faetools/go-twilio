// Package trusthub provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package trusthub

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/faetools/client"
)

// operation paths

const (
	opPathListCustomerProfileChannelEndpointAssignmentFormat   = "./v1/CustomerProfiles/%s/ChannelEndpointAssignments"
	opPathCreateCustomerProfileChannelEndpointAssignmentFormat = "./v1/CustomerProfiles/%s/ChannelEndpointAssignments"
	opPathDeleteCustomerProfileChannelEndpointAssignmentFormat = "./v1/CustomerProfiles/%s/ChannelEndpointAssignments/%s"
	opPathFetchCustomerProfileChannelEndpointAssignmentFormat  = "./v1/CustomerProfiles/%s/ChannelEndpointAssignments/%s"
	opPathListCustomerProfileEntityAssignmentFormat            = "./v1/CustomerProfiles/%s/EntityAssignments"
	opPathCreateCustomerProfileEntityAssignmentFormat          = "./v1/CustomerProfiles/%s/EntityAssignments"
	opPathDeleteCustomerProfileEntityAssignmentFormat          = "./v1/CustomerProfiles/%s/EntityAssignments/%s"
	opPathFetchCustomerProfileEntityAssignmentFormat           = "./v1/CustomerProfiles/%s/EntityAssignments/%s"
	opPathListCustomerProfileEvaluationFormat                  = "./v1/CustomerProfiles/%s/Evaluations"
	opPathCreateCustomerProfileEvaluationFormat                = "./v1/CustomerProfiles/%s/Evaluations"
	opPathFetchCustomerProfileEvaluationFormat                 = "./v1/CustomerProfiles/%s/Evaluations/%s"
	opPathDeleteCustomerProfileFormat                          = "./v1/CustomerProfiles/%s"
	opPathFetchCustomerProfileFormat                           = "./v1/CustomerProfiles/%s"
	opPathUpdateCustomerProfileFormat                          = "./v1/CustomerProfiles/%s"
	opPathFetchEndUserTypeFormat                               = "./v1/EndUserTypes/%s"
	opPathDeleteEndUserFormat                                  = "./v1/EndUsers/%s"
	opPathFetchEndUserFormat                                   = "./v1/EndUsers/%s"
	opPathUpdateEndUserFormat                                  = "./v1/EndUsers/%s"
	opPathFetchPoliciesFormat                                  = "./v1/Policies/%s"
	opPathFetchSupportingDocumentTypeFormat                    = "./v1/SupportingDocumentTypes/%s"
	opPathDeleteSupportingDocumentFormat                       = "./v1/SupportingDocuments/%s"
	opPathFetchSupportingDocumentFormat                        = "./v1/SupportingDocuments/%s"
	opPathUpdateSupportingDocumentFormat                       = "./v1/SupportingDocuments/%s"
	opPathDeleteTrustProductFormat                             = "./v1/TrustProducts/%s"
	opPathFetchTrustProductFormat                              = "./v1/TrustProducts/%s"
	opPathUpdateTrustProductFormat                             = "./v1/TrustProducts/%s"
	opPathListTrustProductChannelEndpointAssignmentFormat      = "./v1/TrustProducts/%s/ChannelEndpointAssignments"
	opPathCreateTrustProductChannelEndpointAssignmentFormat    = "./v1/TrustProducts/%s/ChannelEndpointAssignments"
	opPathDeleteTrustProductChannelEndpointAssignmentFormat    = "./v1/TrustProducts/%s/ChannelEndpointAssignments/%s"
	opPathFetchTrustProductChannelEndpointAssignmentFormat     = "./v1/TrustProducts/%s/ChannelEndpointAssignments/%s"
	opPathListTrustProductEntityAssignmentFormat               = "./v1/TrustProducts/%s/EntityAssignments"
	opPathCreateTrustProductEntityAssignmentFormat             = "./v1/TrustProducts/%s/EntityAssignments"
	opPathDeleteTrustProductEntityAssignmentFormat             = "./v1/TrustProducts/%s/EntityAssignments/%s"
	opPathFetchTrustProductEntityAssignmentFormat              = "./v1/TrustProducts/%s/EntityAssignments/%s"
	opPathListTrustProductEvaluationFormat                     = "./v1/TrustProducts/%s/Evaluations"
	opPathCreateTrustProductEvaluationFormat                   = "./v1/TrustProducts/%s/Evaluations"
	opPathFetchTrustProductEvaluationFormat                    = "./v1/TrustProducts/%s/Evaluations/%s"
)

var (
	opPathListCustomerProfile        = client.MustParseURL("./v1/CustomerProfiles")
	opPathCreateCustomerProfile      = client.MustParseURL("./v1/CustomerProfiles")
	opPathListEndUserType            = client.MustParseURL("./v1/EndUserTypes")
	opPathListEndUser                = client.MustParseURL("./v1/EndUsers")
	opPathCreateEndUser              = client.MustParseURL("./v1/EndUsers")
	opPathListPolicies               = client.MustParseURL("./v1/Policies")
	opPathListSupportingDocumentType = client.MustParseURL("./v1/SupportingDocumentTypes")
	opPathListSupportingDocument     = client.MustParseURL("./v1/SupportingDocuments")
	opPathCreateSupportingDocument   = client.MustParseURL("./v1/SupportingDocuments")
	opPathListTrustProduct           = client.MustParseURL("./v1/TrustProducts")
	opPathCreateTrustProduct         = client.MustParseURL("./v1/TrustProducts")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// ListCustomerProfile request
	ListCustomerProfile(ctx context.Context, params *ListCustomerProfileParams, reqEditors ...client.RequestEditorFn) (*ListCustomerProfileResponse, error)

	// CreateCustomerProfile request with any body
	CreateCustomerProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCustomerProfileResponse, error)

	// ListCustomerProfileChannelEndpointAssignment request
	ListCustomerProfileChannelEndpointAssignment(ctx context.Context, customerProfileSid string, params *ListCustomerProfileChannelEndpointAssignmentParams, reqEditors ...client.RequestEditorFn) (*ListCustomerProfileChannelEndpointAssignmentResponse, error)

	// CreateCustomerProfileChannelEndpointAssignment request with any body
	CreateCustomerProfileChannelEndpointAssignmentWithBody(ctx context.Context, customerProfileSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCustomerProfileChannelEndpointAssignmentResponse, error)

	// DeleteCustomerProfileChannelEndpointAssignment request
	DeleteCustomerProfileChannelEndpointAssignment(ctx context.Context, customerProfileSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCustomerProfileChannelEndpointAssignmentResponse, error)

	// FetchCustomerProfileChannelEndpointAssignment request
	FetchCustomerProfileChannelEndpointAssignment(ctx context.Context, customerProfileSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchCustomerProfileChannelEndpointAssignmentResponse, error)

	// ListCustomerProfileEntityAssignment request
	ListCustomerProfileEntityAssignment(ctx context.Context, customerProfileSid string, params *ListCustomerProfileEntityAssignmentParams, reqEditors ...client.RequestEditorFn) (*ListCustomerProfileEntityAssignmentResponse, error)

	// CreateCustomerProfileEntityAssignment request with any body
	CreateCustomerProfileEntityAssignmentWithBody(ctx context.Context, customerProfileSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCustomerProfileEntityAssignmentResponse, error)

	// DeleteCustomerProfileEntityAssignment request
	DeleteCustomerProfileEntityAssignment(ctx context.Context, customerProfileSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCustomerProfileEntityAssignmentResponse, error)

	// FetchCustomerProfileEntityAssignment request
	FetchCustomerProfileEntityAssignment(ctx context.Context, customerProfileSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchCustomerProfileEntityAssignmentResponse, error)

	// ListCustomerProfileEvaluation request
	ListCustomerProfileEvaluation(ctx context.Context, customerProfileSid string, params *ListCustomerProfileEvaluationParams, reqEditors ...client.RequestEditorFn) (*ListCustomerProfileEvaluationResponse, error)

	// CreateCustomerProfileEvaluation request with any body
	CreateCustomerProfileEvaluationWithBody(ctx context.Context, customerProfileSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCustomerProfileEvaluationResponse, error)

	// FetchCustomerProfileEvaluation request
	FetchCustomerProfileEvaluation(ctx context.Context, customerProfileSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchCustomerProfileEvaluationResponse, error)

	// DeleteCustomerProfile request
	DeleteCustomerProfile(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCustomerProfileResponse, error)

	// FetchCustomerProfile request
	FetchCustomerProfile(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchCustomerProfileResponse, error)

	// UpdateCustomerProfile request with any body
	UpdateCustomerProfileWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateCustomerProfileResponse, error)

	// ListEndUserType request
	ListEndUserType(ctx context.Context, params *ListEndUserTypeParams, reqEditors ...client.RequestEditorFn) (*ListEndUserTypeResponse, error)

	// FetchEndUserType request
	FetchEndUserType(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchEndUserTypeResponse, error)

	// ListEndUser request
	ListEndUser(ctx context.Context, params *ListEndUserParams, reqEditors ...client.RequestEditorFn) (*ListEndUserResponse, error)

	// CreateEndUser request with any body
	CreateEndUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateEndUserResponse, error)

	// DeleteEndUser request
	DeleteEndUser(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteEndUserResponse, error)

	// FetchEndUser request
	FetchEndUser(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchEndUserResponse, error)

	// UpdateEndUser request with any body
	UpdateEndUserWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateEndUserResponse, error)

	// ListPolicies request
	ListPolicies(ctx context.Context, params *ListPoliciesParams, reqEditors ...client.RequestEditorFn) (*ListPoliciesResponse, error)

	// FetchPolicies request
	FetchPolicies(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchPoliciesResponse, error)

	// ListSupportingDocumentType request
	ListSupportingDocumentType(ctx context.Context, params *ListSupportingDocumentTypeParams, reqEditors ...client.RequestEditorFn) (*ListSupportingDocumentTypeResponse, error)

	// FetchSupportingDocumentType request
	FetchSupportingDocumentType(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchSupportingDocumentTypeResponse, error)

	// ListSupportingDocument request
	ListSupportingDocument(ctx context.Context, params *ListSupportingDocumentParams, reqEditors ...client.RequestEditorFn) (*ListSupportingDocumentResponse, error)

	// CreateSupportingDocument request with any body
	CreateSupportingDocumentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSupportingDocumentResponse, error)

	// DeleteSupportingDocument request
	DeleteSupportingDocument(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSupportingDocumentResponse, error)

	// FetchSupportingDocument request
	FetchSupportingDocument(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchSupportingDocumentResponse, error)

	// UpdateSupportingDocument request with any body
	UpdateSupportingDocumentWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSupportingDocumentResponse, error)

	// ListTrustProduct request
	ListTrustProduct(ctx context.Context, params *ListTrustProductParams, reqEditors ...client.RequestEditorFn) (*ListTrustProductResponse, error)

	// CreateTrustProduct request with any body
	CreateTrustProductWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateTrustProductResponse, error)

	// DeleteTrustProduct request
	DeleteTrustProduct(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteTrustProductResponse, error)

	// FetchTrustProduct request
	FetchTrustProduct(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchTrustProductResponse, error)

	// UpdateTrustProduct request with any body
	UpdateTrustProductWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateTrustProductResponse, error)

	// ListTrustProductChannelEndpointAssignment request
	ListTrustProductChannelEndpointAssignment(ctx context.Context, trustProductSid string, params *ListTrustProductChannelEndpointAssignmentParams, reqEditors ...client.RequestEditorFn) (*ListTrustProductChannelEndpointAssignmentResponse, error)

	// CreateTrustProductChannelEndpointAssignment request with any body
	CreateTrustProductChannelEndpointAssignmentWithBody(ctx context.Context, trustProductSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateTrustProductChannelEndpointAssignmentResponse, error)

	// DeleteTrustProductChannelEndpointAssignment request
	DeleteTrustProductChannelEndpointAssignment(ctx context.Context, trustProductSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteTrustProductChannelEndpointAssignmentResponse, error)

	// FetchTrustProductChannelEndpointAssignment request
	FetchTrustProductChannelEndpointAssignment(ctx context.Context, trustProductSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchTrustProductChannelEndpointAssignmentResponse, error)

	// ListTrustProductEntityAssignment request
	ListTrustProductEntityAssignment(ctx context.Context, trustProductSid string, params *ListTrustProductEntityAssignmentParams, reqEditors ...client.RequestEditorFn) (*ListTrustProductEntityAssignmentResponse, error)

	// CreateTrustProductEntityAssignment request with any body
	CreateTrustProductEntityAssignmentWithBody(ctx context.Context, trustProductSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateTrustProductEntityAssignmentResponse, error)

	// DeleteTrustProductEntityAssignment request
	DeleteTrustProductEntityAssignment(ctx context.Context, trustProductSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteTrustProductEntityAssignmentResponse, error)

	// FetchTrustProductEntityAssignment request
	FetchTrustProductEntityAssignment(ctx context.Context, trustProductSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchTrustProductEntityAssignmentResponse, error)

	// ListTrustProductEvaluation request
	ListTrustProductEvaluation(ctx context.Context, trustProductSid string, params *ListTrustProductEvaluationParams, reqEditors ...client.RequestEditorFn) (*ListTrustProductEvaluationResponse, error)

	// CreateTrustProductEvaluation request with any body
	CreateTrustProductEvaluationWithBody(ctx context.Context, trustProductSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateTrustProductEvaluationResponse, error)

	// FetchTrustProductEvaluation request
	FetchTrustProductEvaluation(ctx context.Context, trustProductSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchTrustProductEvaluationResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// ListCustomerProfile: GET /v1/CustomerProfiles

type ListCustomerProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Results *[]TrusthubV1CustomerProfile `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCustomerProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomerProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListCustomerProfileRequest generates requests for ListCustomerProfile
func newListCustomerProfileRequest(baseURL *url.URL, params *ListCustomerProfileParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListCustomerProfile)

	q := queryURL.Query()

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.PolicySid != nil {
		if err := client.AddQueryParam(q, "PolicySid", *params.PolicySid); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListCustomerProfile returns a parsed response.
// GET /v1/CustomerProfiles
func (c *Client) ListCustomerProfile(ctx context.Context, params *ListCustomerProfileParams, reqEditors ...client.RequestEditorFn) (*ListCustomerProfileResponse, error) {
	req, err := newListCustomerProfileRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListCustomerProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Results *[]TrusthubV1CustomerProfile `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateCustomerProfile: POST /v1/CustomerProfiles

type CreateCustomerProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TrusthubV1CustomerProfile
}

// Status returns HTTPResponse.Status
func (r CreateCustomerProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomerProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateCustomerProfileRequestWithBody generates requests for CreateCustomerProfile with any type of body
func newCreateCustomerProfileRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateCustomerProfile)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateCustomerProfileWithBody returns a parsed response.
// POST /v1/CustomerProfiles
func (c *Client) CreateCustomerProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCustomerProfileResponse, error) {
	req, err := newCreateCustomerProfileRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateCustomerProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TrusthubV1CustomerProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListCustomerProfileChannelEndpointAssignment: GET /v1/CustomerProfiles/{CustomerProfileSid}/ChannelEndpointAssignments

type ListCustomerProfileChannelEndpointAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Results *[]TrusthubV1CustomerProfileCustomerProfileChannelEndpointAssignment `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCustomerProfileChannelEndpointAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomerProfileChannelEndpointAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListCustomerProfileChannelEndpointAssignmentRequest generates requests for ListCustomerProfileChannelEndpointAssignment
func newListCustomerProfileChannelEndpointAssignmentRequest(baseURL *url.URL, customerProfileSid string, params *ListCustomerProfileChannelEndpointAssignmentParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("CustomerProfileSid", customerProfileSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListCustomerProfileChannelEndpointAssignmentFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.ChannelEndpointSid != nil {
		if err := client.AddQueryParam(q, "ChannelEndpointSid", *params.ChannelEndpointSid); err != nil {
			return nil, err
		}
	}

	if params.ChannelEndpointSids != nil {
		if err := client.AddQueryParam(q, "ChannelEndpointSids", *params.ChannelEndpointSids); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListCustomerProfileChannelEndpointAssignment returns a parsed response.
// GET /v1/CustomerProfiles/{CustomerProfileSid}/ChannelEndpointAssignments
func (c *Client) ListCustomerProfileChannelEndpointAssignment(ctx context.Context, customerProfileSid string, params *ListCustomerProfileChannelEndpointAssignmentParams, reqEditors ...client.RequestEditorFn) (*ListCustomerProfileChannelEndpointAssignmentResponse, error) {
	req, err := newListCustomerProfileChannelEndpointAssignmentRequest(c.BaseURL, customerProfileSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListCustomerProfileChannelEndpointAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Results *[]TrusthubV1CustomerProfileCustomerProfileChannelEndpointAssignment `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateCustomerProfileChannelEndpointAssignment: POST /v1/CustomerProfiles/{CustomerProfileSid}/ChannelEndpointAssignments

type CreateCustomerProfileChannelEndpointAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TrusthubV1CustomerProfileCustomerProfileChannelEndpointAssignment
}

// Status returns HTTPResponse.Status
func (r CreateCustomerProfileChannelEndpointAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomerProfileChannelEndpointAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateCustomerProfileChannelEndpointAssignmentRequestWithBody generates requests for CreateCustomerProfileChannelEndpointAssignment with any type of body
func newCreateCustomerProfileChannelEndpointAssignmentRequestWithBody(baseURL *url.URL, customerProfileSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("CustomerProfileSid", customerProfileSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateCustomerProfileChannelEndpointAssignmentFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateCustomerProfileChannelEndpointAssignmentWithBody returns a parsed response.
// POST /v1/CustomerProfiles/{CustomerProfileSid}/ChannelEndpointAssignments
func (c *Client) CreateCustomerProfileChannelEndpointAssignmentWithBody(ctx context.Context, customerProfileSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCustomerProfileChannelEndpointAssignmentResponse, error) {
	req, err := newCreateCustomerProfileChannelEndpointAssignmentRequestWithBody(c.BaseURL, customerProfileSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateCustomerProfileChannelEndpointAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TrusthubV1CustomerProfileCustomerProfileChannelEndpointAssignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteCustomerProfileChannelEndpointAssignment: DELETE /v1/CustomerProfiles/{CustomerProfileSid}/ChannelEndpointAssignments/{Sid}

type DeleteCustomerProfileChannelEndpointAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCustomerProfileChannelEndpointAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomerProfileChannelEndpointAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteCustomerProfileChannelEndpointAssignmentRequest generates requests for DeleteCustomerProfileChannelEndpointAssignment
func newDeleteCustomerProfileChannelEndpointAssignmentRequest(baseURL *url.URL, customerProfileSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("CustomerProfileSid", customerProfileSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteCustomerProfileChannelEndpointAssignmentFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteCustomerProfileChannelEndpointAssignment returns a parsed response.
// DELETE /v1/CustomerProfiles/{CustomerProfileSid}/ChannelEndpointAssignments/{Sid}
func (c *Client) DeleteCustomerProfileChannelEndpointAssignment(ctx context.Context, customerProfileSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCustomerProfileChannelEndpointAssignmentResponse, error) {
	req, err := newDeleteCustomerProfileChannelEndpointAssignmentRequest(c.BaseURL, customerProfileSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteCustomerProfileChannelEndpointAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchCustomerProfileChannelEndpointAssignment: GET /v1/CustomerProfiles/{CustomerProfileSid}/ChannelEndpointAssignments/{Sid}

type FetchCustomerProfileChannelEndpointAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrusthubV1CustomerProfileCustomerProfileChannelEndpointAssignment
}

// Status returns HTTPResponse.Status
func (r FetchCustomerProfileChannelEndpointAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchCustomerProfileChannelEndpointAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchCustomerProfileChannelEndpointAssignmentRequest generates requests for FetchCustomerProfileChannelEndpointAssignment
func newFetchCustomerProfileChannelEndpointAssignmentRequest(baseURL *url.URL, customerProfileSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("CustomerProfileSid", customerProfileSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchCustomerProfileChannelEndpointAssignmentFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchCustomerProfileChannelEndpointAssignment returns a parsed response.
// GET /v1/CustomerProfiles/{CustomerProfileSid}/ChannelEndpointAssignments/{Sid}
func (c *Client) FetchCustomerProfileChannelEndpointAssignment(ctx context.Context, customerProfileSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchCustomerProfileChannelEndpointAssignmentResponse, error) {
	req, err := newFetchCustomerProfileChannelEndpointAssignmentRequest(c.BaseURL, customerProfileSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchCustomerProfileChannelEndpointAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrusthubV1CustomerProfileCustomerProfileChannelEndpointAssignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListCustomerProfileEntityAssignment: GET /v1/CustomerProfiles/{CustomerProfileSid}/EntityAssignments

type ListCustomerProfileEntityAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Results *[]TrusthubV1CustomerProfileCustomerProfileEntityAssignment `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCustomerProfileEntityAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomerProfileEntityAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListCustomerProfileEntityAssignmentRequest generates requests for ListCustomerProfileEntityAssignment
func newListCustomerProfileEntityAssignmentRequest(baseURL *url.URL, customerProfileSid string, params *ListCustomerProfileEntityAssignmentParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("CustomerProfileSid", customerProfileSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListCustomerProfileEntityAssignmentFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListCustomerProfileEntityAssignment returns a parsed response.
// GET /v1/CustomerProfiles/{CustomerProfileSid}/EntityAssignments
func (c *Client) ListCustomerProfileEntityAssignment(ctx context.Context, customerProfileSid string, params *ListCustomerProfileEntityAssignmentParams, reqEditors ...client.RequestEditorFn) (*ListCustomerProfileEntityAssignmentResponse, error) {
	req, err := newListCustomerProfileEntityAssignmentRequest(c.BaseURL, customerProfileSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListCustomerProfileEntityAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Results *[]TrusthubV1CustomerProfileCustomerProfileEntityAssignment `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateCustomerProfileEntityAssignment: POST /v1/CustomerProfiles/{CustomerProfileSid}/EntityAssignments

type CreateCustomerProfileEntityAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TrusthubV1CustomerProfileCustomerProfileEntityAssignment
}

// Status returns HTTPResponse.Status
func (r CreateCustomerProfileEntityAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomerProfileEntityAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateCustomerProfileEntityAssignmentRequestWithBody generates requests for CreateCustomerProfileEntityAssignment with any type of body
func newCreateCustomerProfileEntityAssignmentRequestWithBody(baseURL *url.URL, customerProfileSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("CustomerProfileSid", customerProfileSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateCustomerProfileEntityAssignmentFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateCustomerProfileEntityAssignmentWithBody returns a parsed response.
// POST /v1/CustomerProfiles/{CustomerProfileSid}/EntityAssignments
func (c *Client) CreateCustomerProfileEntityAssignmentWithBody(ctx context.Context, customerProfileSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCustomerProfileEntityAssignmentResponse, error) {
	req, err := newCreateCustomerProfileEntityAssignmentRequestWithBody(c.BaseURL, customerProfileSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateCustomerProfileEntityAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TrusthubV1CustomerProfileCustomerProfileEntityAssignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteCustomerProfileEntityAssignment: DELETE /v1/CustomerProfiles/{CustomerProfileSid}/EntityAssignments/{Sid}

type DeleteCustomerProfileEntityAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCustomerProfileEntityAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomerProfileEntityAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteCustomerProfileEntityAssignmentRequest generates requests for DeleteCustomerProfileEntityAssignment
func newDeleteCustomerProfileEntityAssignmentRequest(baseURL *url.URL, customerProfileSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("CustomerProfileSid", customerProfileSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteCustomerProfileEntityAssignmentFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteCustomerProfileEntityAssignment returns a parsed response.
// DELETE /v1/CustomerProfiles/{CustomerProfileSid}/EntityAssignments/{Sid}
func (c *Client) DeleteCustomerProfileEntityAssignment(ctx context.Context, customerProfileSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCustomerProfileEntityAssignmentResponse, error) {
	req, err := newDeleteCustomerProfileEntityAssignmentRequest(c.BaseURL, customerProfileSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteCustomerProfileEntityAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchCustomerProfileEntityAssignment: GET /v1/CustomerProfiles/{CustomerProfileSid}/EntityAssignments/{Sid}

type FetchCustomerProfileEntityAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrusthubV1CustomerProfileCustomerProfileEntityAssignment
}

// Status returns HTTPResponse.Status
func (r FetchCustomerProfileEntityAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchCustomerProfileEntityAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchCustomerProfileEntityAssignmentRequest generates requests for FetchCustomerProfileEntityAssignment
func newFetchCustomerProfileEntityAssignmentRequest(baseURL *url.URL, customerProfileSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("CustomerProfileSid", customerProfileSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchCustomerProfileEntityAssignmentFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchCustomerProfileEntityAssignment returns a parsed response.
// GET /v1/CustomerProfiles/{CustomerProfileSid}/EntityAssignments/{Sid}
func (c *Client) FetchCustomerProfileEntityAssignment(ctx context.Context, customerProfileSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchCustomerProfileEntityAssignmentResponse, error) {
	req, err := newFetchCustomerProfileEntityAssignmentRequest(c.BaseURL, customerProfileSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchCustomerProfileEntityAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrusthubV1CustomerProfileCustomerProfileEntityAssignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListCustomerProfileEvaluation: GET /v1/CustomerProfiles/{CustomerProfileSid}/Evaluations

type ListCustomerProfileEvaluationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Results *[]TrusthubV1CustomerProfileCustomerProfileEvaluation `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCustomerProfileEvaluationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomerProfileEvaluationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListCustomerProfileEvaluationRequest generates requests for ListCustomerProfileEvaluation
func newListCustomerProfileEvaluationRequest(baseURL *url.URL, customerProfileSid string, params *ListCustomerProfileEvaluationParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("CustomerProfileSid", customerProfileSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListCustomerProfileEvaluationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListCustomerProfileEvaluation returns a parsed response.
// GET /v1/CustomerProfiles/{CustomerProfileSid}/Evaluations
func (c *Client) ListCustomerProfileEvaluation(ctx context.Context, customerProfileSid string, params *ListCustomerProfileEvaluationParams, reqEditors ...client.RequestEditorFn) (*ListCustomerProfileEvaluationResponse, error) {
	req, err := newListCustomerProfileEvaluationRequest(c.BaseURL, customerProfileSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListCustomerProfileEvaluationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Results *[]TrusthubV1CustomerProfileCustomerProfileEvaluation `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateCustomerProfileEvaluation: POST /v1/CustomerProfiles/{CustomerProfileSid}/Evaluations

type CreateCustomerProfileEvaluationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TrusthubV1CustomerProfileCustomerProfileEvaluation
}

// Status returns HTTPResponse.Status
func (r CreateCustomerProfileEvaluationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomerProfileEvaluationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateCustomerProfileEvaluationRequestWithBody generates requests for CreateCustomerProfileEvaluation with any type of body
func newCreateCustomerProfileEvaluationRequestWithBody(baseURL *url.URL, customerProfileSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("CustomerProfileSid", customerProfileSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateCustomerProfileEvaluationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateCustomerProfileEvaluationWithBody returns a parsed response.
// POST /v1/CustomerProfiles/{CustomerProfileSid}/Evaluations
func (c *Client) CreateCustomerProfileEvaluationWithBody(ctx context.Context, customerProfileSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCustomerProfileEvaluationResponse, error) {
	req, err := newCreateCustomerProfileEvaluationRequestWithBody(c.BaseURL, customerProfileSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateCustomerProfileEvaluationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TrusthubV1CustomerProfileCustomerProfileEvaluation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// FetchCustomerProfileEvaluation: GET /v1/CustomerProfiles/{CustomerProfileSid}/Evaluations/{Sid}

type FetchCustomerProfileEvaluationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrusthubV1CustomerProfileCustomerProfileEvaluation
}

// Status returns HTTPResponse.Status
func (r FetchCustomerProfileEvaluationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchCustomerProfileEvaluationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchCustomerProfileEvaluationRequest generates requests for FetchCustomerProfileEvaluation
func newFetchCustomerProfileEvaluationRequest(baseURL *url.URL, customerProfileSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("CustomerProfileSid", customerProfileSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchCustomerProfileEvaluationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchCustomerProfileEvaluation returns a parsed response.
// GET /v1/CustomerProfiles/{CustomerProfileSid}/Evaluations/{Sid}
func (c *Client) FetchCustomerProfileEvaluation(ctx context.Context, customerProfileSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchCustomerProfileEvaluationResponse, error) {
	req, err := newFetchCustomerProfileEvaluationRequest(c.BaseURL, customerProfileSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchCustomerProfileEvaluationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrusthubV1CustomerProfileCustomerProfileEvaluation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteCustomerProfile: DELETE /v1/CustomerProfiles/{Sid}

type DeleteCustomerProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCustomerProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomerProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteCustomerProfileRequest generates requests for DeleteCustomerProfile
func newDeleteCustomerProfileRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteCustomerProfileFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteCustomerProfile returns a parsed response.
// DELETE /v1/CustomerProfiles/{Sid}
func (c *Client) DeleteCustomerProfile(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCustomerProfileResponse, error) {
	req, err := newDeleteCustomerProfileRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteCustomerProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchCustomerProfile: GET /v1/CustomerProfiles/{Sid}

type FetchCustomerProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrusthubV1CustomerProfile
}

// Status returns HTTPResponse.Status
func (r FetchCustomerProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchCustomerProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchCustomerProfileRequest generates requests for FetchCustomerProfile
func newFetchCustomerProfileRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchCustomerProfileFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchCustomerProfile returns a parsed response.
// GET /v1/CustomerProfiles/{Sid}
func (c *Client) FetchCustomerProfile(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchCustomerProfileResponse, error) {
	req, err := newFetchCustomerProfileRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchCustomerProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrusthubV1CustomerProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateCustomerProfile: POST /v1/CustomerProfiles/{Sid}

type UpdateCustomerProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrusthubV1CustomerProfile
}

// Status returns HTTPResponse.Status
func (r UpdateCustomerProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomerProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateCustomerProfileRequestWithBody generates requests for UpdateCustomerProfile with any type of body
func newUpdateCustomerProfileRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateCustomerProfileFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateCustomerProfileWithBody returns a parsed response.
// POST /v1/CustomerProfiles/{Sid}
func (c *Client) UpdateCustomerProfileWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateCustomerProfileResponse, error) {
	req, err := newUpdateCustomerProfileRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateCustomerProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrusthubV1CustomerProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListEndUserType: GET /v1/EndUserTypes

type ListEndUserTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		EndUserTypes *[]TrusthubV1EndUserType `json:"end_user_types,omitempty"`
		Meta         *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListEndUserTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEndUserTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListEndUserTypeRequest generates requests for ListEndUserType
func newListEndUserTypeRequest(baseURL *url.URL, params *ListEndUserTypeParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListEndUserType)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListEndUserType returns a parsed response.
// GET /v1/EndUserTypes
func (c *Client) ListEndUserType(ctx context.Context, params *ListEndUserTypeParams, reqEditors ...client.RequestEditorFn) (*ListEndUserTypeResponse, error) {
	req, err := newListEndUserTypeRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListEndUserTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			EndUserTypes *[]TrusthubV1EndUserType `json:"end_user_types,omitempty"`
			Meta         *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchEndUserType: GET /v1/EndUserTypes/{Sid}

type FetchEndUserTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrusthubV1EndUserType
}

// Status returns HTTPResponse.Status
func (r FetchEndUserTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchEndUserTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchEndUserTypeRequest generates requests for FetchEndUserType
func newFetchEndUserTypeRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchEndUserTypeFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchEndUserType returns a parsed response.
// GET /v1/EndUserTypes/{Sid}
func (c *Client) FetchEndUserType(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchEndUserTypeResponse, error) {
	req, err := newFetchEndUserTypeRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchEndUserTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrusthubV1EndUserType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListEndUser: GET /v1/EndUsers

type ListEndUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Results *[]TrusthubV1EndUser `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListEndUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEndUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListEndUserRequest generates requests for ListEndUser
func newListEndUserRequest(baseURL *url.URL, params *ListEndUserParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListEndUser)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListEndUser returns a parsed response.
// GET /v1/EndUsers
func (c *Client) ListEndUser(ctx context.Context, params *ListEndUserParams, reqEditors ...client.RequestEditorFn) (*ListEndUserResponse, error) {
	req, err := newListEndUserRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListEndUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Results *[]TrusthubV1EndUser `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateEndUser: POST /v1/EndUsers

type CreateEndUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TrusthubV1EndUser
}

// Status returns HTTPResponse.Status
func (r CreateEndUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEndUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateEndUserRequestWithBody generates requests for CreateEndUser with any type of body
func newCreateEndUserRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateEndUser)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateEndUserWithBody returns a parsed response.
// POST /v1/EndUsers
func (c *Client) CreateEndUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateEndUserResponse, error) {
	req, err := newCreateEndUserRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateEndUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TrusthubV1EndUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteEndUser: DELETE /v1/EndUsers/{Sid}

type DeleteEndUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteEndUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEndUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteEndUserRequest generates requests for DeleteEndUser
func newDeleteEndUserRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteEndUserFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteEndUser returns a parsed response.
// DELETE /v1/EndUsers/{Sid}
func (c *Client) DeleteEndUser(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteEndUserResponse, error) {
	req, err := newDeleteEndUserRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteEndUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchEndUser: GET /v1/EndUsers/{Sid}

type FetchEndUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrusthubV1EndUser
}

// Status returns HTTPResponse.Status
func (r FetchEndUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchEndUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchEndUserRequest generates requests for FetchEndUser
func newFetchEndUserRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchEndUserFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchEndUser returns a parsed response.
// GET /v1/EndUsers/{Sid}
func (c *Client) FetchEndUser(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchEndUserResponse, error) {
	req, err := newFetchEndUserRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchEndUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrusthubV1EndUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateEndUser: POST /v1/EndUsers/{Sid}

type UpdateEndUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrusthubV1EndUser
}

// Status returns HTTPResponse.Status
func (r UpdateEndUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEndUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateEndUserRequestWithBody generates requests for UpdateEndUser with any type of body
func newUpdateEndUserRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateEndUserFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateEndUserWithBody returns a parsed response.
// POST /v1/EndUsers/{Sid}
func (c *Client) UpdateEndUserWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateEndUserResponse, error) {
	req, err := newUpdateEndUserRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateEndUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrusthubV1EndUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListPolicies: GET /v1/Policies

type ListPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Results *[]TrusthubV1Policies `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListPoliciesRequest generates requests for ListPolicies
func newListPoliciesRequest(baseURL *url.URL, params *ListPoliciesParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListPolicies)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListPolicies returns a parsed response.
// GET /v1/Policies
func (c *Client) ListPolicies(ctx context.Context, params *ListPoliciesParams, reqEditors ...client.RequestEditorFn) (*ListPoliciesResponse, error) {
	req, err := newListPoliciesRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Results *[]TrusthubV1Policies `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchPolicies: GET /v1/Policies/{Sid}

type FetchPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrusthubV1Policies
}

// Status returns HTTPResponse.Status
func (r FetchPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchPoliciesRequest generates requests for FetchPolicies
func newFetchPoliciesRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchPoliciesFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchPolicies returns a parsed response.
// GET /v1/Policies/{Sid}
func (c *Client) FetchPolicies(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchPoliciesResponse, error) {
	req, err := newFetchPoliciesRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrusthubV1Policies
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSupportingDocumentType: GET /v1/SupportingDocumentTypes

type ListSupportingDocumentTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		SupportingDocumentTypes *[]TrusthubV1SupportingDocumentType `json:"supporting_document_types,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSupportingDocumentTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSupportingDocumentTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSupportingDocumentTypeRequest generates requests for ListSupportingDocumentType
func newListSupportingDocumentTypeRequest(baseURL *url.URL, params *ListSupportingDocumentTypeParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListSupportingDocumentType)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSupportingDocumentType returns a parsed response.
// GET /v1/SupportingDocumentTypes
func (c *Client) ListSupportingDocumentType(ctx context.Context, params *ListSupportingDocumentTypeParams, reqEditors ...client.RequestEditorFn) (*ListSupportingDocumentTypeResponse, error) {
	req, err := newListSupportingDocumentTypeRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSupportingDocumentTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			SupportingDocumentTypes *[]TrusthubV1SupportingDocumentType `json:"supporting_document_types,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchSupportingDocumentType: GET /v1/SupportingDocumentTypes/{Sid}

type FetchSupportingDocumentTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrusthubV1SupportingDocumentType
}

// Status returns HTTPResponse.Status
func (r FetchSupportingDocumentTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSupportingDocumentTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSupportingDocumentTypeRequest generates requests for FetchSupportingDocumentType
func newFetchSupportingDocumentTypeRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSupportingDocumentTypeFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSupportingDocumentType returns a parsed response.
// GET /v1/SupportingDocumentTypes/{Sid}
func (c *Client) FetchSupportingDocumentType(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchSupportingDocumentTypeResponse, error) {
	req, err := newFetchSupportingDocumentTypeRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSupportingDocumentTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrusthubV1SupportingDocumentType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSupportingDocument: GET /v1/SupportingDocuments

type ListSupportingDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Results *[]TrusthubV1SupportingDocument `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSupportingDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSupportingDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSupportingDocumentRequest generates requests for ListSupportingDocument
func newListSupportingDocumentRequest(baseURL *url.URL, params *ListSupportingDocumentParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListSupportingDocument)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSupportingDocument returns a parsed response.
// GET /v1/SupportingDocuments
func (c *Client) ListSupportingDocument(ctx context.Context, params *ListSupportingDocumentParams, reqEditors ...client.RequestEditorFn) (*ListSupportingDocumentResponse, error) {
	req, err := newListSupportingDocumentRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSupportingDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Results *[]TrusthubV1SupportingDocument `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSupportingDocument: POST /v1/SupportingDocuments

type CreateSupportingDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TrusthubV1SupportingDocument
}

// Status returns HTTPResponse.Status
func (r CreateSupportingDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSupportingDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSupportingDocumentRequestWithBody generates requests for CreateSupportingDocument with any type of body
func newCreateSupportingDocumentRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateSupportingDocument)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSupportingDocumentWithBody returns a parsed response.
// POST /v1/SupportingDocuments
func (c *Client) CreateSupportingDocumentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSupportingDocumentResponse, error) {
	req, err := newCreateSupportingDocumentRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSupportingDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TrusthubV1SupportingDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteSupportingDocument: DELETE /v1/SupportingDocuments/{Sid}

type DeleteSupportingDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSupportingDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSupportingDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSupportingDocumentRequest generates requests for DeleteSupportingDocument
func newDeleteSupportingDocumentRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSupportingDocumentFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSupportingDocument returns a parsed response.
// DELETE /v1/SupportingDocuments/{Sid}
func (c *Client) DeleteSupportingDocument(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSupportingDocumentResponse, error) {
	req, err := newDeleteSupportingDocumentRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSupportingDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSupportingDocument: GET /v1/SupportingDocuments/{Sid}

type FetchSupportingDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrusthubV1SupportingDocument
}

// Status returns HTTPResponse.Status
func (r FetchSupportingDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSupportingDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSupportingDocumentRequest generates requests for FetchSupportingDocument
func newFetchSupportingDocumentRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSupportingDocumentFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSupportingDocument returns a parsed response.
// GET /v1/SupportingDocuments/{Sid}
func (c *Client) FetchSupportingDocument(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchSupportingDocumentResponse, error) {
	req, err := newFetchSupportingDocumentRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSupportingDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrusthubV1SupportingDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSupportingDocument: POST /v1/SupportingDocuments/{Sid}

type UpdateSupportingDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrusthubV1SupportingDocument
}

// Status returns HTTPResponse.Status
func (r UpdateSupportingDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSupportingDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSupportingDocumentRequestWithBody generates requests for UpdateSupportingDocument with any type of body
func newUpdateSupportingDocumentRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSupportingDocumentFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSupportingDocumentWithBody returns a parsed response.
// POST /v1/SupportingDocuments/{Sid}
func (c *Client) UpdateSupportingDocumentWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSupportingDocumentResponse, error) {
	req, err := newUpdateSupportingDocumentRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSupportingDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrusthubV1SupportingDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListTrustProduct: GET /v1/TrustProducts

type ListTrustProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Results *[]TrusthubV1TrustProduct `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListTrustProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTrustProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListTrustProductRequest generates requests for ListTrustProduct
func newListTrustProductRequest(baseURL *url.URL, params *ListTrustProductParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListTrustProduct)

	q := queryURL.Query()

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.PolicySid != nil {
		if err := client.AddQueryParam(q, "PolicySid", *params.PolicySid); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListTrustProduct returns a parsed response.
// GET /v1/TrustProducts
func (c *Client) ListTrustProduct(ctx context.Context, params *ListTrustProductParams, reqEditors ...client.RequestEditorFn) (*ListTrustProductResponse, error) {
	req, err := newListTrustProductRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListTrustProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Results *[]TrusthubV1TrustProduct `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateTrustProduct: POST /v1/TrustProducts

type CreateTrustProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TrusthubV1TrustProduct
}

// Status returns HTTPResponse.Status
func (r CreateTrustProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTrustProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateTrustProductRequestWithBody generates requests for CreateTrustProduct with any type of body
func newCreateTrustProductRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateTrustProduct)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateTrustProductWithBody returns a parsed response.
// POST /v1/TrustProducts
func (c *Client) CreateTrustProductWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateTrustProductResponse, error) {
	req, err := newCreateTrustProductRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateTrustProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TrusthubV1TrustProduct
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteTrustProduct: DELETE /v1/TrustProducts/{Sid}

type DeleteTrustProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTrustProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTrustProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteTrustProductRequest generates requests for DeleteTrustProduct
func newDeleteTrustProductRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteTrustProductFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteTrustProduct returns a parsed response.
// DELETE /v1/TrustProducts/{Sid}
func (c *Client) DeleteTrustProduct(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteTrustProductResponse, error) {
	req, err := newDeleteTrustProductRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteTrustProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchTrustProduct: GET /v1/TrustProducts/{Sid}

type FetchTrustProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrusthubV1TrustProduct
}

// Status returns HTTPResponse.Status
func (r FetchTrustProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTrustProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchTrustProductRequest generates requests for FetchTrustProduct
func newFetchTrustProductRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchTrustProductFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchTrustProduct returns a parsed response.
// GET /v1/TrustProducts/{Sid}
func (c *Client) FetchTrustProduct(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchTrustProductResponse, error) {
	req, err := newFetchTrustProductRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchTrustProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrusthubV1TrustProduct
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateTrustProduct: POST /v1/TrustProducts/{Sid}

type UpdateTrustProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrusthubV1TrustProduct
}

// Status returns HTTPResponse.Status
func (r UpdateTrustProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTrustProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateTrustProductRequestWithBody generates requests for UpdateTrustProduct with any type of body
func newUpdateTrustProductRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateTrustProductFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateTrustProductWithBody returns a parsed response.
// POST /v1/TrustProducts/{Sid}
func (c *Client) UpdateTrustProductWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateTrustProductResponse, error) {
	req, err := newUpdateTrustProductRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateTrustProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrusthubV1TrustProduct
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListTrustProductChannelEndpointAssignment: GET /v1/TrustProducts/{TrustProductSid}/ChannelEndpointAssignments

type ListTrustProductChannelEndpointAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Results *[]TrusthubV1TrustProductTrustProductChannelEndpointAssignment `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListTrustProductChannelEndpointAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTrustProductChannelEndpointAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListTrustProductChannelEndpointAssignmentRequest generates requests for ListTrustProductChannelEndpointAssignment
func newListTrustProductChannelEndpointAssignmentRequest(baseURL *url.URL, trustProductSid string, params *ListTrustProductChannelEndpointAssignmentParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrustProductSid", trustProductSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListTrustProductChannelEndpointAssignmentFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.ChannelEndpointSid != nil {
		if err := client.AddQueryParam(q, "ChannelEndpointSid", *params.ChannelEndpointSid); err != nil {
			return nil, err
		}
	}

	if params.ChannelEndpointSids != nil {
		if err := client.AddQueryParam(q, "ChannelEndpointSids", *params.ChannelEndpointSids); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListTrustProductChannelEndpointAssignment returns a parsed response.
// GET /v1/TrustProducts/{TrustProductSid}/ChannelEndpointAssignments
func (c *Client) ListTrustProductChannelEndpointAssignment(ctx context.Context, trustProductSid string, params *ListTrustProductChannelEndpointAssignmentParams, reqEditors ...client.RequestEditorFn) (*ListTrustProductChannelEndpointAssignmentResponse, error) {
	req, err := newListTrustProductChannelEndpointAssignmentRequest(c.BaseURL, trustProductSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListTrustProductChannelEndpointAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Results *[]TrusthubV1TrustProductTrustProductChannelEndpointAssignment `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateTrustProductChannelEndpointAssignment: POST /v1/TrustProducts/{TrustProductSid}/ChannelEndpointAssignments

type CreateTrustProductChannelEndpointAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TrusthubV1TrustProductTrustProductChannelEndpointAssignment
}

// Status returns HTTPResponse.Status
func (r CreateTrustProductChannelEndpointAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTrustProductChannelEndpointAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateTrustProductChannelEndpointAssignmentRequestWithBody generates requests for CreateTrustProductChannelEndpointAssignment with any type of body
func newCreateTrustProductChannelEndpointAssignmentRequestWithBody(baseURL *url.URL, trustProductSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrustProductSid", trustProductSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateTrustProductChannelEndpointAssignmentFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateTrustProductChannelEndpointAssignmentWithBody returns a parsed response.
// POST /v1/TrustProducts/{TrustProductSid}/ChannelEndpointAssignments
func (c *Client) CreateTrustProductChannelEndpointAssignmentWithBody(ctx context.Context, trustProductSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateTrustProductChannelEndpointAssignmentResponse, error) {
	req, err := newCreateTrustProductChannelEndpointAssignmentRequestWithBody(c.BaseURL, trustProductSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateTrustProductChannelEndpointAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TrusthubV1TrustProductTrustProductChannelEndpointAssignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteTrustProductChannelEndpointAssignment: DELETE /v1/TrustProducts/{TrustProductSid}/ChannelEndpointAssignments/{Sid}

type DeleteTrustProductChannelEndpointAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTrustProductChannelEndpointAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTrustProductChannelEndpointAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteTrustProductChannelEndpointAssignmentRequest generates requests for DeleteTrustProductChannelEndpointAssignment
func newDeleteTrustProductChannelEndpointAssignmentRequest(baseURL *url.URL, trustProductSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrustProductSid", trustProductSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteTrustProductChannelEndpointAssignmentFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteTrustProductChannelEndpointAssignment returns a parsed response.
// DELETE /v1/TrustProducts/{TrustProductSid}/ChannelEndpointAssignments/{Sid}
func (c *Client) DeleteTrustProductChannelEndpointAssignment(ctx context.Context, trustProductSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteTrustProductChannelEndpointAssignmentResponse, error) {
	req, err := newDeleteTrustProductChannelEndpointAssignmentRequest(c.BaseURL, trustProductSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteTrustProductChannelEndpointAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchTrustProductChannelEndpointAssignment: GET /v1/TrustProducts/{TrustProductSid}/ChannelEndpointAssignments/{Sid}

type FetchTrustProductChannelEndpointAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrusthubV1TrustProductTrustProductChannelEndpointAssignment
}

// Status returns HTTPResponse.Status
func (r FetchTrustProductChannelEndpointAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTrustProductChannelEndpointAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchTrustProductChannelEndpointAssignmentRequest generates requests for FetchTrustProductChannelEndpointAssignment
func newFetchTrustProductChannelEndpointAssignmentRequest(baseURL *url.URL, trustProductSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrustProductSid", trustProductSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchTrustProductChannelEndpointAssignmentFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchTrustProductChannelEndpointAssignment returns a parsed response.
// GET /v1/TrustProducts/{TrustProductSid}/ChannelEndpointAssignments/{Sid}
func (c *Client) FetchTrustProductChannelEndpointAssignment(ctx context.Context, trustProductSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchTrustProductChannelEndpointAssignmentResponse, error) {
	req, err := newFetchTrustProductChannelEndpointAssignmentRequest(c.BaseURL, trustProductSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchTrustProductChannelEndpointAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrusthubV1TrustProductTrustProductChannelEndpointAssignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListTrustProductEntityAssignment: GET /v1/TrustProducts/{TrustProductSid}/EntityAssignments

type ListTrustProductEntityAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Results *[]TrusthubV1TrustProductTrustProductEntityAssignment `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListTrustProductEntityAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTrustProductEntityAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListTrustProductEntityAssignmentRequest generates requests for ListTrustProductEntityAssignment
func newListTrustProductEntityAssignmentRequest(baseURL *url.URL, trustProductSid string, params *ListTrustProductEntityAssignmentParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrustProductSid", trustProductSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListTrustProductEntityAssignmentFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListTrustProductEntityAssignment returns a parsed response.
// GET /v1/TrustProducts/{TrustProductSid}/EntityAssignments
func (c *Client) ListTrustProductEntityAssignment(ctx context.Context, trustProductSid string, params *ListTrustProductEntityAssignmentParams, reqEditors ...client.RequestEditorFn) (*ListTrustProductEntityAssignmentResponse, error) {
	req, err := newListTrustProductEntityAssignmentRequest(c.BaseURL, trustProductSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListTrustProductEntityAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Results *[]TrusthubV1TrustProductTrustProductEntityAssignment `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateTrustProductEntityAssignment: POST /v1/TrustProducts/{TrustProductSid}/EntityAssignments

type CreateTrustProductEntityAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TrusthubV1TrustProductTrustProductEntityAssignment
}

// Status returns HTTPResponse.Status
func (r CreateTrustProductEntityAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTrustProductEntityAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateTrustProductEntityAssignmentRequestWithBody generates requests for CreateTrustProductEntityAssignment with any type of body
func newCreateTrustProductEntityAssignmentRequestWithBody(baseURL *url.URL, trustProductSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrustProductSid", trustProductSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateTrustProductEntityAssignmentFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateTrustProductEntityAssignmentWithBody returns a parsed response.
// POST /v1/TrustProducts/{TrustProductSid}/EntityAssignments
func (c *Client) CreateTrustProductEntityAssignmentWithBody(ctx context.Context, trustProductSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateTrustProductEntityAssignmentResponse, error) {
	req, err := newCreateTrustProductEntityAssignmentRequestWithBody(c.BaseURL, trustProductSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateTrustProductEntityAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TrusthubV1TrustProductTrustProductEntityAssignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteTrustProductEntityAssignment: DELETE /v1/TrustProducts/{TrustProductSid}/EntityAssignments/{Sid}

type DeleteTrustProductEntityAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTrustProductEntityAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTrustProductEntityAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteTrustProductEntityAssignmentRequest generates requests for DeleteTrustProductEntityAssignment
func newDeleteTrustProductEntityAssignmentRequest(baseURL *url.URL, trustProductSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrustProductSid", trustProductSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteTrustProductEntityAssignmentFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteTrustProductEntityAssignment returns a parsed response.
// DELETE /v1/TrustProducts/{TrustProductSid}/EntityAssignments/{Sid}
func (c *Client) DeleteTrustProductEntityAssignment(ctx context.Context, trustProductSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteTrustProductEntityAssignmentResponse, error) {
	req, err := newDeleteTrustProductEntityAssignmentRequest(c.BaseURL, trustProductSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteTrustProductEntityAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchTrustProductEntityAssignment: GET /v1/TrustProducts/{TrustProductSid}/EntityAssignments/{Sid}

type FetchTrustProductEntityAssignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrusthubV1TrustProductTrustProductEntityAssignment
}

// Status returns HTTPResponse.Status
func (r FetchTrustProductEntityAssignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTrustProductEntityAssignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchTrustProductEntityAssignmentRequest generates requests for FetchTrustProductEntityAssignment
func newFetchTrustProductEntityAssignmentRequest(baseURL *url.URL, trustProductSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrustProductSid", trustProductSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchTrustProductEntityAssignmentFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchTrustProductEntityAssignment returns a parsed response.
// GET /v1/TrustProducts/{TrustProductSid}/EntityAssignments/{Sid}
func (c *Client) FetchTrustProductEntityAssignment(ctx context.Context, trustProductSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchTrustProductEntityAssignmentResponse, error) {
	req, err := newFetchTrustProductEntityAssignmentRequest(c.BaseURL, trustProductSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchTrustProductEntityAssignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrusthubV1TrustProductTrustProductEntityAssignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListTrustProductEvaluation: GET /v1/TrustProducts/{TrustProductSid}/Evaluations

type ListTrustProductEvaluationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Results *[]TrusthubV1TrustProductTrustProductEvaluation `json:"results,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListTrustProductEvaluationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTrustProductEvaluationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListTrustProductEvaluationRequest generates requests for ListTrustProductEvaluation
func newListTrustProductEvaluationRequest(baseURL *url.URL, trustProductSid string, params *ListTrustProductEvaluationParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrustProductSid", trustProductSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListTrustProductEvaluationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListTrustProductEvaluation returns a parsed response.
// GET /v1/TrustProducts/{TrustProductSid}/Evaluations
func (c *Client) ListTrustProductEvaluation(ctx context.Context, trustProductSid string, params *ListTrustProductEvaluationParams, reqEditors ...client.RequestEditorFn) (*ListTrustProductEvaluationResponse, error) {
	req, err := newListTrustProductEvaluationRequest(c.BaseURL, trustProductSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListTrustProductEvaluationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Results *[]TrusthubV1TrustProductTrustProductEvaluation `json:"results,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateTrustProductEvaluation: POST /v1/TrustProducts/{TrustProductSid}/Evaluations

type CreateTrustProductEvaluationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TrusthubV1TrustProductTrustProductEvaluation
}

// Status returns HTTPResponse.Status
func (r CreateTrustProductEvaluationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTrustProductEvaluationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateTrustProductEvaluationRequestWithBody generates requests for CreateTrustProductEvaluation with any type of body
func newCreateTrustProductEvaluationRequestWithBody(baseURL *url.URL, trustProductSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrustProductSid", trustProductSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateTrustProductEvaluationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateTrustProductEvaluationWithBody returns a parsed response.
// POST /v1/TrustProducts/{TrustProductSid}/Evaluations
func (c *Client) CreateTrustProductEvaluationWithBody(ctx context.Context, trustProductSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateTrustProductEvaluationResponse, error) {
	req, err := newCreateTrustProductEvaluationRequestWithBody(c.BaseURL, trustProductSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateTrustProductEvaluationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TrusthubV1TrustProductTrustProductEvaluation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// FetchTrustProductEvaluation: GET /v1/TrustProducts/{TrustProductSid}/Evaluations/{Sid}

type FetchTrustProductEvaluationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrusthubV1TrustProductTrustProductEvaluation
}

// Status returns HTTPResponse.Status
func (r FetchTrustProductEvaluationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTrustProductEvaluationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchTrustProductEvaluationRequest generates requests for FetchTrustProductEvaluation
func newFetchTrustProductEvaluationRequest(baseURL *url.URL, trustProductSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrustProductSid", trustProductSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchTrustProductEvaluationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchTrustProductEvaluation returns a parsed response.
// GET /v1/TrustProducts/{TrustProductSid}/Evaluations/{Sid}
func (c *Client) FetchTrustProductEvaluation(ctx context.Context, trustProductSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchTrustProductEvaluationResponse, error) {
	req, err := newFetchTrustProductEvaluationRequest(c.BaseURL, trustProductSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchTrustProductEvaluationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrusthubV1TrustProductTrustProductEvaluation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
