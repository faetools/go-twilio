// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package api

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/faetools/client"
)

// operation paths

const (
	opPathListAddressFormat                                     = "./2010-04-01/Accounts/%s/Addresses.json"
	opPathCreateAddressFormat                                   = "./2010-04-01/Accounts/%s/Addresses.json"
	opPathListDependentPhoneNumberFormat                        = "./2010-04-01/Accounts/%s/Addresses/%s/DependentPhoneNumbers.json"
	opPathDeleteAddressFormat                                   = "./2010-04-01/Accounts/%s/Addresses/%s.json"
	opPathFetchAddressFormat                                    = "./2010-04-01/Accounts/%s/Addresses/%s.json"
	opPathUpdateAddressFormat                                   = "./2010-04-01/Accounts/%s/Addresses/%s.json"
	opPathListApplicationFormat                                 = "./2010-04-01/Accounts/%s/Applications.json"
	opPathCreateApplicationFormat                               = "./2010-04-01/Accounts/%s/Applications.json"
	opPathDeleteApplicationFormat                               = "./2010-04-01/Accounts/%s/Applications/%s.json"
	opPathFetchApplicationFormat                                = "./2010-04-01/Accounts/%s/Applications/%s.json"
	opPathUpdateApplicationFormat                               = "./2010-04-01/Accounts/%s/Applications/%s.json"
	opPathListAuthorizedConnectAppFormat                        = "./2010-04-01/Accounts/%s/AuthorizedConnectApps.json"
	opPathFetchAuthorizedConnectAppFormat                       = "./2010-04-01/Accounts/%s/AuthorizedConnectApps/%s.json"
	opPathListAvailablePhoneNumberCountryFormat                 = "./2010-04-01/Accounts/%s/AvailablePhoneNumbers.json"
	opPathFetchAvailablePhoneNumberCountryFormat                = "./2010-04-01/Accounts/%s/AvailablePhoneNumbers/%s.json"
	opPathListAvailablePhoneNumberLocalFormat                   = "./2010-04-01/Accounts/%s/AvailablePhoneNumbers/%s/Local.json"
	opPathListAvailablePhoneNumberMachineToMachineFormat        = "./2010-04-01/Accounts/%s/AvailablePhoneNumbers/%s/MachineToMachine.json"
	opPathListAvailablePhoneNumberMobileFormat                  = "./2010-04-01/Accounts/%s/AvailablePhoneNumbers/%s/Mobile.json"
	opPathListAvailablePhoneNumberNationalFormat                = "./2010-04-01/Accounts/%s/AvailablePhoneNumbers/%s/National.json"
	opPathListAvailablePhoneNumberSharedCostFormat              = "./2010-04-01/Accounts/%s/AvailablePhoneNumbers/%s/SharedCost.json"
	opPathListAvailablePhoneNumberTollFreeFormat                = "./2010-04-01/Accounts/%s/AvailablePhoneNumbers/%s/TollFree.json"
	opPathListAvailablePhoneNumberVoipFormat                    = "./2010-04-01/Accounts/%s/AvailablePhoneNumbers/%s/Voip.json"
	opPathFetchBalanceFormat                                    = "./2010-04-01/Accounts/%s/Balance.json"
	opPathListCallFormat                                        = "./2010-04-01/Accounts/%s/Calls.json"
	opPathCreateCallFormat                                      = "./2010-04-01/Accounts/%s/Calls.json"
	opPathCreateCallFeedbackSummaryFormat                       = "./2010-04-01/Accounts/%s/Calls/FeedbackSummary.json"
	opPathDeleteCallFeedbackSummaryFormat                       = "./2010-04-01/Accounts/%s/Calls/FeedbackSummary/%s.json"
	opPathFetchCallFeedbackSummaryFormat                        = "./2010-04-01/Accounts/%s/Calls/FeedbackSummary/%s.json"
	opPathListCallEventFormat                                   = "./2010-04-01/Accounts/%s/Calls/%s/Events.json"
	opPathFetchCallFeedbackFormat                               = "./2010-04-01/Accounts/%s/Calls/%s/Feedback.json"
	opPathUpdateCallFeedbackFormat                              = "./2010-04-01/Accounts/%s/Calls/%s/Feedback.json"
	opPathListCallNotificationFormat                            = "./2010-04-01/Accounts/%s/Calls/%s/Notifications.json"
	opPathFetchCallNotificationFormat                           = "./2010-04-01/Accounts/%s/Calls/%s/Notifications/%s.json"
	opPathCreatePaymentsFormat                                  = "./2010-04-01/Accounts/%s/Calls/%s/Payments.json"
	opPathUpdatePaymentsFormat                                  = "./2010-04-01/Accounts/%s/Calls/%s/Payments/%s.json"
	opPathListCallRecordingFormat                               = "./2010-04-01/Accounts/%s/Calls/%s/Recordings.json"
	opPathCreateCallRecordingFormat                             = "./2010-04-01/Accounts/%s/Calls/%s/Recordings.json"
	opPathDeleteCallRecordingFormat                             = "./2010-04-01/Accounts/%s/Calls/%s/Recordings/%s.json"
	opPathFetchCallRecordingFormat                              = "./2010-04-01/Accounts/%s/Calls/%s/Recordings/%s.json"
	opPathUpdateCallRecordingFormat                             = "./2010-04-01/Accounts/%s/Calls/%s/Recordings/%s.json"
	opPathCreateSiprecFormat                                    = "./2010-04-01/Accounts/%s/Calls/%s/Siprec.json"
	opPathUpdateSiprecFormat                                    = "./2010-04-01/Accounts/%s/Calls/%s/Siprec/%s.json"
	opPathCreateStreamFormat                                    = "./2010-04-01/Accounts/%s/Calls/%s/Streams.json"
	opPathUpdateStreamFormat                                    = "./2010-04-01/Accounts/%s/Calls/%s/Streams/%s.json"
	opPathDeleteCallFormat                                      = "./2010-04-01/Accounts/%s/Calls/%s.json"
	opPathFetchCallFormat                                       = "./2010-04-01/Accounts/%s/Calls/%s.json"
	opPathUpdateCallFormat                                      = "./2010-04-01/Accounts/%s/Calls/%s.json"
	opPathListConferenceFormat                                  = "./2010-04-01/Accounts/%s/Conferences.json"
	opPathListParticipantFormat                                 = "./2010-04-01/Accounts/%s/Conferences/%s/Participants.json"
	opPathCreateParticipantFormat                               = "./2010-04-01/Accounts/%s/Conferences/%s/Participants.json"
	opPathDeleteParticipantFormat                               = "./2010-04-01/Accounts/%s/Conferences/%s/Participants/%s.json"
	opPathFetchParticipantFormat                                = "./2010-04-01/Accounts/%s/Conferences/%s/Participants/%s.json"
	opPathUpdateParticipantFormat                               = "./2010-04-01/Accounts/%s/Conferences/%s/Participants/%s.json"
	opPathListConferenceRecordingFormat                         = "./2010-04-01/Accounts/%s/Conferences/%s/Recordings.json"
	opPathDeleteConferenceRecordingFormat                       = "./2010-04-01/Accounts/%s/Conferences/%s/Recordings/%s.json"
	opPathFetchConferenceRecordingFormat                        = "./2010-04-01/Accounts/%s/Conferences/%s/Recordings/%s.json"
	opPathUpdateConferenceRecordingFormat                       = "./2010-04-01/Accounts/%s/Conferences/%s/Recordings/%s.json"
	opPathFetchConferenceFormat                                 = "./2010-04-01/Accounts/%s/Conferences/%s.json"
	opPathUpdateConferenceFormat                                = "./2010-04-01/Accounts/%s/Conferences/%s.json"
	opPathListConnectAppFormat                                  = "./2010-04-01/Accounts/%s/ConnectApps.json"
	opPathDeleteConnectAppFormat                                = "./2010-04-01/Accounts/%s/ConnectApps/%s.json"
	opPathFetchConnectAppFormat                                 = "./2010-04-01/Accounts/%s/ConnectApps/%s.json"
	opPathUpdateConnectAppFormat                                = "./2010-04-01/Accounts/%s/ConnectApps/%s.json"
	opPathListIncomingPhoneNumberFormat                         = "./2010-04-01/Accounts/%s/IncomingPhoneNumbers.json"
	opPathCreateIncomingPhoneNumberFormat                       = "./2010-04-01/Accounts/%s/IncomingPhoneNumbers.json"
	opPathListIncomingPhoneNumberLocalFormat                    = "./2010-04-01/Accounts/%s/IncomingPhoneNumbers/Local.json"
	opPathCreateIncomingPhoneNumberLocalFormat                  = "./2010-04-01/Accounts/%s/IncomingPhoneNumbers/Local.json"
	opPathListIncomingPhoneNumberMobileFormat                   = "./2010-04-01/Accounts/%s/IncomingPhoneNumbers/Mobile.json"
	opPathCreateIncomingPhoneNumberMobileFormat                 = "./2010-04-01/Accounts/%s/IncomingPhoneNumbers/Mobile.json"
	opPathListIncomingPhoneNumberTollFreeFormat                 = "./2010-04-01/Accounts/%s/IncomingPhoneNumbers/TollFree.json"
	opPathCreateIncomingPhoneNumberTollFreeFormat               = "./2010-04-01/Accounts/%s/IncomingPhoneNumbers/TollFree.json"
	opPathListIncomingPhoneNumberAssignedAddOnFormat            = "./2010-04-01/Accounts/%s/IncomingPhoneNumbers/%s/AssignedAddOns.json"
	opPathCreateIncomingPhoneNumberAssignedAddOnFormat          = "./2010-04-01/Accounts/%s/IncomingPhoneNumbers/%s/AssignedAddOns.json"
	opPathListIncomingPhoneNumberAssignedAddOnExtensionFormat   = "./2010-04-01/Accounts/%s/IncomingPhoneNumbers/%s/AssignedAddOns/%s/Extensions.json"
	opPathFetchIncomingPhoneNumberAssignedAddOnExtensionFormat  = "./2010-04-01/Accounts/%s/IncomingPhoneNumbers/%s/AssignedAddOns/%s/Extensions/%s.json"
	opPathDeleteIncomingPhoneNumberAssignedAddOnFormat          = "./2010-04-01/Accounts/%s/IncomingPhoneNumbers/%s/AssignedAddOns/%s.json"
	opPathFetchIncomingPhoneNumberAssignedAddOnFormat           = "./2010-04-01/Accounts/%s/IncomingPhoneNumbers/%s/AssignedAddOns/%s.json"
	opPathDeleteIncomingPhoneNumberFormat                       = "./2010-04-01/Accounts/%s/IncomingPhoneNumbers/%s.json"
	opPathFetchIncomingPhoneNumberFormat                        = "./2010-04-01/Accounts/%s/IncomingPhoneNumbers/%s.json"
	opPathUpdateIncomingPhoneNumberFormat                       = "./2010-04-01/Accounts/%s/IncomingPhoneNumbers/%s.json"
	opPathListKeyFormat                                         = "./2010-04-01/Accounts/%s/Keys.json"
	opPathCreateNewKeyFormat                                    = "./2010-04-01/Accounts/%s/Keys.json"
	opPathDeleteKeyFormat                                       = "./2010-04-01/Accounts/%s/Keys/%s.json"
	opPathFetchKeyFormat                                        = "./2010-04-01/Accounts/%s/Keys/%s.json"
	opPathUpdateKeyFormat                                       = "./2010-04-01/Accounts/%s/Keys/%s.json"
	opPathListMessageFormat                                     = "./2010-04-01/Accounts/%s/Messages.json"
	opPathCreateMessageFormat                                   = "./2010-04-01/Accounts/%s/Messages.json"
	opPathCreateMessageFeedbackFormat                           = "./2010-04-01/Accounts/%s/Messages/%s/Feedback.json"
	opPathListMediaFormat                                       = "./2010-04-01/Accounts/%s/Messages/%s/Media.json"
	opPathDeleteMediaFormat                                     = "./2010-04-01/Accounts/%s/Messages/%s/Media/%s.json"
	opPathFetchMediaFormat                                      = "./2010-04-01/Accounts/%s/Messages/%s/Media/%s.json"
	opPathDeleteMessageFormat                                   = "./2010-04-01/Accounts/%s/Messages/%s.json"
	opPathFetchMessageFormat                                    = "./2010-04-01/Accounts/%s/Messages/%s.json"
	opPathUpdateMessageFormat                                   = "./2010-04-01/Accounts/%s/Messages/%s.json"
	opPathListNotificationFormat                                = "./2010-04-01/Accounts/%s/Notifications.json"
	opPathFetchNotificationFormat                               = "./2010-04-01/Accounts/%s/Notifications/%s.json"
	opPathListOutgoingCallerIdFormat                            = "./2010-04-01/Accounts/%s/OutgoingCallerIds.json"
	opPathCreateValidationRequestFormat                         = "./2010-04-01/Accounts/%s/OutgoingCallerIds.json"
	opPathDeleteOutgoingCallerIdFormat                          = "./2010-04-01/Accounts/%s/OutgoingCallerIds/%s.json"
	opPathFetchOutgoingCallerIdFormat                           = "./2010-04-01/Accounts/%s/OutgoingCallerIds/%s.json"
	opPathUpdateOutgoingCallerIdFormat                          = "./2010-04-01/Accounts/%s/OutgoingCallerIds/%s.json"
	opPathListQueueFormat                                       = "./2010-04-01/Accounts/%s/Queues.json"
	opPathCreateQueueFormat                                     = "./2010-04-01/Accounts/%s/Queues.json"
	opPathListMemberFormat                                      = "./2010-04-01/Accounts/%s/Queues/%s/Members.json"
	opPathFetchMemberFormat                                     = "./2010-04-01/Accounts/%s/Queues/%s/Members/%s.json"
	opPathUpdateMemberFormat                                    = "./2010-04-01/Accounts/%s/Queues/%s/Members/%s.json"
	opPathDeleteQueueFormat                                     = "./2010-04-01/Accounts/%s/Queues/%s.json"
	opPathFetchQueueFormat                                      = "./2010-04-01/Accounts/%s/Queues/%s.json"
	opPathUpdateQueueFormat                                     = "./2010-04-01/Accounts/%s/Queues/%s.json"
	opPathListRecordingFormat                                   = "./2010-04-01/Accounts/%s/Recordings.json"
	opPathListRecordingTranscriptionFormat                      = "./2010-04-01/Accounts/%s/Recordings/%s/Transcriptions.json"
	opPathDeleteRecordingTranscriptionFormat                    = "./2010-04-01/Accounts/%s/Recordings/%s/Transcriptions/%s.json"
	opPathFetchRecordingTranscriptionFormat                     = "./2010-04-01/Accounts/%s/Recordings/%s/Transcriptions/%s.json"
	opPathListRecordingAddOnResultFormat                        = "./2010-04-01/Accounts/%s/Recordings/%s/AddOnResults.json"
	opPathListRecordingAddOnResultPayloadFormat                 = "./2010-04-01/Accounts/%s/Recordings/%s/AddOnResults/%s/Payloads.json"
	opPathDeleteRecordingAddOnResultPayloadFormat               = "./2010-04-01/Accounts/%s/Recordings/%s/AddOnResults/%s/Payloads/%s.json"
	opPathFetchRecordingAddOnResultPayloadFormat                = "./2010-04-01/Accounts/%s/Recordings/%s/AddOnResults/%s/Payloads/%s.json"
	opPathDeleteRecordingAddOnResultFormat                      = "./2010-04-01/Accounts/%s/Recordings/%s/AddOnResults/%s.json"
	opPathFetchRecordingAddOnResultFormat                       = "./2010-04-01/Accounts/%s/Recordings/%s/AddOnResults/%s.json"
	opPathDeleteRecordingFormat                                 = "./2010-04-01/Accounts/%s/Recordings/%s.json"
	opPathFetchRecordingFormat                                  = "./2010-04-01/Accounts/%s/Recordings/%s.json"
	opPathListSipCredentialListFormat                           = "./2010-04-01/Accounts/%s/SIP/CredentialLists.json"
	opPathCreateSipCredentialListFormat                         = "./2010-04-01/Accounts/%s/SIP/CredentialLists.json"
	opPathListSipCredentialFormat                               = "./2010-04-01/Accounts/%s/SIP/CredentialLists/%s/Credentials.json"
	opPathCreateSipCredentialFormat                             = "./2010-04-01/Accounts/%s/SIP/CredentialLists/%s/Credentials.json"
	opPathDeleteSipCredentialFormat                             = "./2010-04-01/Accounts/%s/SIP/CredentialLists/%s/Credentials/%s.json"
	opPathFetchSipCredentialFormat                              = "./2010-04-01/Accounts/%s/SIP/CredentialLists/%s/Credentials/%s.json"
	opPathUpdateSipCredentialFormat                             = "./2010-04-01/Accounts/%s/SIP/CredentialLists/%s/Credentials/%s.json"
	opPathDeleteSipCredentialListFormat                         = "./2010-04-01/Accounts/%s/SIP/CredentialLists/%s.json"
	opPathFetchSipCredentialListFormat                          = "./2010-04-01/Accounts/%s/SIP/CredentialLists/%s.json"
	opPathUpdateSipCredentialListFormat                         = "./2010-04-01/Accounts/%s/SIP/CredentialLists/%s.json"
	opPathListSipDomainFormat                                   = "./2010-04-01/Accounts/%s/SIP/Domains.json"
	opPathCreateSipDomainFormat                                 = "./2010-04-01/Accounts/%s/SIP/Domains.json"
	opPathListSipAuthCallsCredentialListMappingFormat           = "./2010-04-01/Accounts/%s/SIP/Domains/%s/Auth/Calls/CredentialListMappings.json"
	opPathCreateSipAuthCallsCredentialListMappingFormat         = "./2010-04-01/Accounts/%s/SIP/Domains/%s/Auth/Calls/CredentialListMappings.json"
	opPathDeleteSipAuthCallsCredentialListMappingFormat         = "./2010-04-01/Accounts/%s/SIP/Domains/%s/Auth/Calls/CredentialListMappings/%s.json"
	opPathFetchSipAuthCallsCredentialListMappingFormat          = "./2010-04-01/Accounts/%s/SIP/Domains/%s/Auth/Calls/CredentialListMappings/%s.json"
	opPathListSipAuthCallsIpAccessControlListMappingFormat      = "./2010-04-01/Accounts/%s/SIP/Domains/%s/Auth/Calls/IpAccessControlListMappings.json"
	opPathCreateSipAuthCallsIpAccessControlListMappingFormat    = "./2010-04-01/Accounts/%s/SIP/Domains/%s/Auth/Calls/IpAccessControlListMappings.json"
	opPathDeleteSipAuthCallsIpAccessControlListMappingFormat    = "./2010-04-01/Accounts/%s/SIP/Domains/%s/Auth/Calls/IpAccessControlListMappings/%s.json"
	opPathFetchSipAuthCallsIpAccessControlListMappingFormat     = "./2010-04-01/Accounts/%s/SIP/Domains/%s/Auth/Calls/IpAccessControlListMappings/%s.json"
	opPathListSipAuthRegistrationsCredentialListMappingFormat   = "./2010-04-01/Accounts/%s/SIP/Domains/%s/Auth/Registrations/CredentialListMappings.json"
	opPathCreateSipAuthRegistrationsCredentialListMappingFormat = "./2010-04-01/Accounts/%s/SIP/Domains/%s/Auth/Registrations/CredentialListMappings.json"
	opPathDeleteSipAuthRegistrationsCredentialListMappingFormat = "./2010-04-01/Accounts/%s/SIP/Domains/%s/Auth/Registrations/CredentialListMappings/%s.json"
	opPathFetchSipAuthRegistrationsCredentialListMappingFormat  = "./2010-04-01/Accounts/%s/SIP/Domains/%s/Auth/Registrations/CredentialListMappings/%s.json"
	opPathListSipCredentialListMappingFormat                    = "./2010-04-01/Accounts/%s/SIP/Domains/%s/CredentialListMappings.json"
	opPathCreateSipCredentialListMappingFormat                  = "./2010-04-01/Accounts/%s/SIP/Domains/%s/CredentialListMappings.json"
	opPathDeleteSipCredentialListMappingFormat                  = "./2010-04-01/Accounts/%s/SIP/Domains/%s/CredentialListMappings/%s.json"
	opPathFetchSipCredentialListMappingFormat                   = "./2010-04-01/Accounts/%s/SIP/Domains/%s/CredentialListMappings/%s.json"
	opPathListSipIpAccessControlListMappingFormat               = "./2010-04-01/Accounts/%s/SIP/Domains/%s/IpAccessControlListMappings.json"
	opPathCreateSipIpAccessControlListMappingFormat             = "./2010-04-01/Accounts/%s/SIP/Domains/%s/IpAccessControlListMappings.json"
	opPathDeleteSipIpAccessControlListMappingFormat             = "./2010-04-01/Accounts/%s/SIP/Domains/%s/IpAccessControlListMappings/%s.json"
	opPathFetchSipIpAccessControlListMappingFormat              = "./2010-04-01/Accounts/%s/SIP/Domains/%s/IpAccessControlListMappings/%s.json"
	opPathDeleteSipDomainFormat                                 = "./2010-04-01/Accounts/%s/SIP/Domains/%s.json"
	opPathFetchSipDomainFormat                                  = "./2010-04-01/Accounts/%s/SIP/Domains/%s.json"
	opPathUpdateSipDomainFormat                                 = "./2010-04-01/Accounts/%s/SIP/Domains/%s.json"
	opPathListSipIpAccessControlListFormat                      = "./2010-04-01/Accounts/%s/SIP/IpAccessControlLists.json"
	opPathCreateSipIpAccessControlListFormat                    = "./2010-04-01/Accounts/%s/SIP/IpAccessControlLists.json"
	opPathListSipIpAddressFormat                                = "./2010-04-01/Accounts/%s/SIP/IpAccessControlLists/%s/IpAddresses.json"
	opPathCreateSipIpAddressFormat                              = "./2010-04-01/Accounts/%s/SIP/IpAccessControlLists/%s/IpAddresses.json"
	opPathDeleteSipIpAddressFormat                              = "./2010-04-01/Accounts/%s/SIP/IpAccessControlLists/%s/IpAddresses/%s.json"
	opPathFetchSipIpAddressFormat                               = "./2010-04-01/Accounts/%s/SIP/IpAccessControlLists/%s/IpAddresses/%s.json"
	opPathUpdateSipIpAddressFormat                              = "./2010-04-01/Accounts/%s/SIP/IpAccessControlLists/%s/IpAddresses/%s.json"
	opPathDeleteSipIpAccessControlListFormat                    = "./2010-04-01/Accounts/%s/SIP/IpAccessControlLists/%s.json"
	opPathFetchSipIpAccessControlListFormat                     = "./2010-04-01/Accounts/%s/SIP/IpAccessControlLists/%s.json"
	opPathUpdateSipIpAccessControlListFormat                    = "./2010-04-01/Accounts/%s/SIP/IpAccessControlLists/%s.json"
	opPathListShortCodeFormat                                   = "./2010-04-01/Accounts/%s/SMS/ShortCodes.json"
	opPathFetchShortCodeFormat                                  = "./2010-04-01/Accounts/%s/SMS/ShortCodes/%s.json"
	opPathUpdateShortCodeFormat                                 = "./2010-04-01/Accounts/%s/SMS/ShortCodes/%s.json"
	opPathListSigningKeyFormat                                  = "./2010-04-01/Accounts/%s/SigningKeys.json"
	opPathCreateNewSigningKeyFormat                             = "./2010-04-01/Accounts/%s/SigningKeys.json"
	opPathDeleteSigningKeyFormat                                = "./2010-04-01/Accounts/%s/SigningKeys/%s.json"
	opPathFetchSigningKeyFormat                                 = "./2010-04-01/Accounts/%s/SigningKeys/%s.json"
	opPathUpdateSigningKeyFormat                                = "./2010-04-01/Accounts/%s/SigningKeys/%s.json"
	opPathCreateTokenFormat                                     = "./2010-04-01/Accounts/%s/Tokens.json"
	opPathListTranscriptionFormat                               = "./2010-04-01/Accounts/%s/Transcriptions.json"
	opPathDeleteTranscriptionFormat                             = "./2010-04-01/Accounts/%s/Transcriptions/%s.json"
	opPathFetchTranscriptionFormat                              = "./2010-04-01/Accounts/%s/Transcriptions/%s.json"
	opPathListUsageRecordFormat                                 = "./2010-04-01/Accounts/%s/Usage/Records.json"
	opPathListUsageRecordAllTimeFormat                          = "./2010-04-01/Accounts/%s/Usage/Records/AllTime.json"
	opPathListUsageRecordDailyFormat                            = "./2010-04-01/Accounts/%s/Usage/Records/Daily.json"
	opPathListUsageRecordLastMonthFormat                        = "./2010-04-01/Accounts/%s/Usage/Records/LastMonth.json"
	opPathListUsageRecordMonthlyFormat                          = "./2010-04-01/Accounts/%s/Usage/Records/Monthly.json"
	opPathListUsageRecordThisMonthFormat                        = "./2010-04-01/Accounts/%s/Usage/Records/ThisMonth.json"
	opPathListUsageRecordTodayFormat                            = "./2010-04-01/Accounts/%s/Usage/Records/Today.json"
	opPathListUsageRecordYearlyFormat                           = "./2010-04-01/Accounts/%s/Usage/Records/Yearly.json"
	opPathListUsageRecordYesterdayFormat                        = "./2010-04-01/Accounts/%s/Usage/Records/Yesterday.json"
	opPathListUsageTriggerFormat                                = "./2010-04-01/Accounts/%s/Usage/Triggers.json"
	opPathCreateUsageTriggerFormat                              = "./2010-04-01/Accounts/%s/Usage/Triggers.json"
	opPathDeleteUsageTriggerFormat                              = "./2010-04-01/Accounts/%s/Usage/Triggers/%s.json"
	opPathFetchUsageTriggerFormat                               = "./2010-04-01/Accounts/%s/Usage/Triggers/%s.json"
	opPathUpdateUsageTriggerFormat                              = "./2010-04-01/Accounts/%s/Usage/Triggers/%s.json"
	opPathFetchAccountFormat                                    = "./2010-04-01/Accounts/%s.json"
	opPathUpdateAccountFormat                                   = "./2010-04-01/Accounts/%s.json"
)

var (
	opPathListAccount   = client.MustParseURL("./2010-04-01/Accounts.json")
	opPathCreateAccount = client.MustParseURL("./2010-04-01/Accounts.json")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// ListAccount request
	ListAccount(ctx context.Context, params *ListAccountParams, reqEditors ...client.RequestEditorFn) (*ListAccountResponse, error)

	// CreateAccount request with any body
	CreateAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateAccountResponse, error)

	// ListAddress request
	ListAddress(ctx context.Context, accountSid string, params *ListAddressParams, reqEditors ...client.RequestEditorFn) (*ListAddressResponse, error)

	// CreateAddress request with any body
	CreateAddressWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateAddressResponse, error)

	// ListDependentPhoneNumber request
	ListDependentPhoneNumber(ctx context.Context, accountSid string, addressSid string, params *ListDependentPhoneNumberParams, reqEditors ...client.RequestEditorFn) (*ListDependentPhoneNumberResponse, error)

	// DeleteAddress request
	DeleteAddress(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteAddressResponse, error)

	// FetchAddress request
	FetchAddress(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchAddressResponse, error)

	// UpdateAddress request with any body
	UpdateAddressWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateAddressResponse, error)

	// ListApplication request
	ListApplication(ctx context.Context, accountSid string, params *ListApplicationParams, reqEditors ...client.RequestEditorFn) (*ListApplicationResponse, error)

	// CreateApplication request with any body
	CreateApplicationWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateApplicationResponse, error)

	// DeleteApplication request
	DeleteApplication(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteApplicationResponse, error)

	// FetchApplication request
	FetchApplication(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchApplicationResponse, error)

	// UpdateApplication request with any body
	UpdateApplicationWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateApplicationResponse, error)

	// ListAuthorizedConnectApp request
	ListAuthorizedConnectApp(ctx context.Context, accountSid string, params *ListAuthorizedConnectAppParams, reqEditors ...client.RequestEditorFn) (*ListAuthorizedConnectAppResponse, error)

	// FetchAuthorizedConnectApp request
	FetchAuthorizedConnectApp(ctx context.Context, accountSid string, connectAppSid string, reqEditors ...client.RequestEditorFn) (*FetchAuthorizedConnectAppResponse, error)

	// ListAvailablePhoneNumberCountry request
	ListAvailablePhoneNumberCountry(ctx context.Context, accountSid string, params *ListAvailablePhoneNumberCountryParams, reqEditors ...client.RequestEditorFn) (*ListAvailablePhoneNumberCountryResponse, error)

	// FetchAvailablePhoneNumberCountry request
	FetchAvailablePhoneNumberCountry(ctx context.Context, accountSid string, countryCode string, reqEditors ...client.RequestEditorFn) (*FetchAvailablePhoneNumberCountryResponse, error)

	// ListAvailablePhoneNumberLocal request
	ListAvailablePhoneNumberLocal(ctx context.Context, accountSid string, countryCode string, params *ListAvailablePhoneNumberLocalParams, reqEditors ...client.RequestEditorFn) (*ListAvailablePhoneNumberLocalResponse, error)

	// ListAvailablePhoneNumberMachineToMachine request
	ListAvailablePhoneNumberMachineToMachine(ctx context.Context, accountSid string, countryCode string, params *ListAvailablePhoneNumberMachineToMachineParams, reqEditors ...client.RequestEditorFn) (*ListAvailablePhoneNumberMachineToMachineResponse, error)

	// ListAvailablePhoneNumberMobile request
	ListAvailablePhoneNumberMobile(ctx context.Context, accountSid string, countryCode string, params *ListAvailablePhoneNumberMobileParams, reqEditors ...client.RequestEditorFn) (*ListAvailablePhoneNumberMobileResponse, error)

	// ListAvailablePhoneNumberNational request
	ListAvailablePhoneNumberNational(ctx context.Context, accountSid string, countryCode string, params *ListAvailablePhoneNumberNationalParams, reqEditors ...client.RequestEditorFn) (*ListAvailablePhoneNumberNationalResponse, error)

	// ListAvailablePhoneNumberSharedCost request
	ListAvailablePhoneNumberSharedCost(ctx context.Context, accountSid string, countryCode string, params *ListAvailablePhoneNumberSharedCostParams, reqEditors ...client.RequestEditorFn) (*ListAvailablePhoneNumberSharedCostResponse, error)

	// ListAvailablePhoneNumberTollFree request
	ListAvailablePhoneNumberTollFree(ctx context.Context, accountSid string, countryCode string, params *ListAvailablePhoneNumberTollFreeParams, reqEditors ...client.RequestEditorFn) (*ListAvailablePhoneNumberTollFreeResponse, error)

	// ListAvailablePhoneNumberVoip request
	ListAvailablePhoneNumberVoip(ctx context.Context, accountSid string, countryCode string, params *ListAvailablePhoneNumberVoipParams, reqEditors ...client.RequestEditorFn) (*ListAvailablePhoneNumberVoipResponse, error)

	// FetchBalance request
	FetchBalance(ctx context.Context, accountSid string, reqEditors ...client.RequestEditorFn) (*FetchBalanceResponse, error)

	// ListCall request
	ListCall(ctx context.Context, accountSid string, params *ListCallParams, reqEditors ...client.RequestEditorFn) (*ListCallResponse, error)

	// CreateCall request with any body
	CreateCallWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCallResponse, error)

	// CreateCallFeedbackSummary request with any body
	CreateCallFeedbackSummaryWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCallFeedbackSummaryResponse, error)

	// DeleteCallFeedbackSummary request
	DeleteCallFeedbackSummary(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCallFeedbackSummaryResponse, error)

	// FetchCallFeedbackSummary request
	FetchCallFeedbackSummary(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchCallFeedbackSummaryResponse, error)

	// ListCallEvent request
	ListCallEvent(ctx context.Context, accountSid string, callSid string, params *ListCallEventParams, reqEditors ...client.RequestEditorFn) (*ListCallEventResponse, error)

	// FetchCallFeedback request
	FetchCallFeedback(ctx context.Context, accountSid string, callSid string, reqEditors ...client.RequestEditorFn) (*FetchCallFeedbackResponse, error)

	// UpdateCallFeedback request with any body
	UpdateCallFeedbackWithBody(ctx context.Context, accountSid string, callSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateCallFeedbackResponse, error)

	// ListCallNotification request
	ListCallNotification(ctx context.Context, accountSid string, callSid string, params *ListCallNotificationParams, reqEditors ...client.RequestEditorFn) (*ListCallNotificationResponse, error)

	// FetchCallNotification request
	FetchCallNotification(ctx context.Context, accountSid string, callSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchCallNotificationResponse, error)

	// CreatePayments request with any body
	CreatePaymentsWithBody(ctx context.Context, accountSid string, callSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreatePaymentsResponse, error)

	// UpdatePayments request with any body
	UpdatePaymentsWithBody(ctx context.Context, accountSid string, callSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdatePaymentsResponse, error)

	// ListCallRecording request
	ListCallRecording(ctx context.Context, accountSid string, callSid string, params *ListCallRecordingParams, reqEditors ...client.RequestEditorFn) (*ListCallRecordingResponse, error)

	// CreateCallRecording request with any body
	CreateCallRecordingWithBody(ctx context.Context, accountSid string, callSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCallRecordingResponse, error)

	// DeleteCallRecording request
	DeleteCallRecording(ctx context.Context, accountSid string, callSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCallRecordingResponse, error)

	// FetchCallRecording request
	FetchCallRecording(ctx context.Context, accountSid string, callSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchCallRecordingResponse, error)

	// UpdateCallRecording request with any body
	UpdateCallRecordingWithBody(ctx context.Context, accountSid string, callSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateCallRecordingResponse, error)

	// CreateSiprec request with any body
	CreateSiprecWithBody(ctx context.Context, accountSid string, callSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSiprecResponse, error)

	// UpdateSiprec request with any body
	UpdateSiprecWithBody(ctx context.Context, accountSid string, callSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSiprecResponse, error)

	// CreateStream request with any body
	CreateStreamWithBody(ctx context.Context, accountSid string, callSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateStreamResponse, error)

	// UpdateStream request with any body
	UpdateStreamWithBody(ctx context.Context, accountSid string, callSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateStreamResponse, error)

	// DeleteCall request
	DeleteCall(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCallResponse, error)

	// FetchCall request
	FetchCall(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchCallResponse, error)

	// UpdateCall request with any body
	UpdateCallWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateCallResponse, error)

	// ListConference request
	ListConference(ctx context.Context, accountSid string, params *ListConferenceParams, reqEditors ...client.RequestEditorFn) (*ListConferenceResponse, error)

	// ListParticipant request
	ListParticipant(ctx context.Context, accountSid string, conferenceSid string, params *ListParticipantParams, reqEditors ...client.RequestEditorFn) (*ListParticipantResponse, error)

	// CreateParticipant request with any body
	CreateParticipantWithBody(ctx context.Context, accountSid string, conferenceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateParticipantResponse, error)

	// DeleteParticipant request
	DeleteParticipant(ctx context.Context, accountSid string, conferenceSid string, callSid string, reqEditors ...client.RequestEditorFn) (*DeleteParticipantResponse, error)

	// FetchParticipant request
	FetchParticipant(ctx context.Context, accountSid string, conferenceSid string, callSid string, reqEditors ...client.RequestEditorFn) (*FetchParticipantResponse, error)

	// UpdateParticipant request with any body
	UpdateParticipantWithBody(ctx context.Context, accountSid string, conferenceSid string, callSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateParticipantResponse, error)

	// ListConferenceRecording request
	ListConferenceRecording(ctx context.Context, accountSid string, conferenceSid string, params *ListConferenceRecordingParams, reqEditors ...client.RequestEditorFn) (*ListConferenceRecordingResponse, error)

	// DeleteConferenceRecording request
	DeleteConferenceRecording(ctx context.Context, accountSid string, conferenceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteConferenceRecordingResponse, error)

	// FetchConferenceRecording request
	FetchConferenceRecording(ctx context.Context, accountSid string, conferenceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchConferenceRecordingResponse, error)

	// UpdateConferenceRecording request with any body
	UpdateConferenceRecordingWithBody(ctx context.Context, accountSid string, conferenceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConferenceRecordingResponse, error)

	// FetchConference request
	FetchConference(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchConferenceResponse, error)

	// UpdateConference request with any body
	UpdateConferenceWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConferenceResponse, error)

	// ListConnectApp request
	ListConnectApp(ctx context.Context, accountSid string, params *ListConnectAppParams, reqEditors ...client.RequestEditorFn) (*ListConnectAppResponse, error)

	// DeleteConnectApp request
	DeleteConnectApp(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteConnectAppResponse, error)

	// FetchConnectApp request
	FetchConnectApp(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchConnectAppResponse, error)

	// UpdateConnectApp request with any body
	UpdateConnectAppWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConnectAppResponse, error)

	// ListIncomingPhoneNumber request
	ListIncomingPhoneNumber(ctx context.Context, accountSid string, params *ListIncomingPhoneNumberParams, reqEditors ...client.RequestEditorFn) (*ListIncomingPhoneNumberResponse, error)

	// CreateIncomingPhoneNumber request with any body
	CreateIncomingPhoneNumberWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateIncomingPhoneNumberResponse, error)

	// ListIncomingPhoneNumberLocal request
	ListIncomingPhoneNumberLocal(ctx context.Context, accountSid string, params *ListIncomingPhoneNumberLocalParams, reqEditors ...client.RequestEditorFn) (*ListIncomingPhoneNumberLocalResponse, error)

	// CreateIncomingPhoneNumberLocal request with any body
	CreateIncomingPhoneNumberLocalWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateIncomingPhoneNumberLocalResponse, error)

	// ListIncomingPhoneNumberMobile request
	ListIncomingPhoneNumberMobile(ctx context.Context, accountSid string, params *ListIncomingPhoneNumberMobileParams, reqEditors ...client.RequestEditorFn) (*ListIncomingPhoneNumberMobileResponse, error)

	// CreateIncomingPhoneNumberMobile request with any body
	CreateIncomingPhoneNumberMobileWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateIncomingPhoneNumberMobileResponse, error)

	// ListIncomingPhoneNumberTollFree request
	ListIncomingPhoneNumberTollFree(ctx context.Context, accountSid string, params *ListIncomingPhoneNumberTollFreeParams, reqEditors ...client.RequestEditorFn) (*ListIncomingPhoneNumberTollFreeResponse, error)

	// CreateIncomingPhoneNumberTollFree request with any body
	CreateIncomingPhoneNumberTollFreeWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateIncomingPhoneNumberTollFreeResponse, error)

	// ListIncomingPhoneNumberAssignedAddOn request
	ListIncomingPhoneNumberAssignedAddOn(ctx context.Context, accountSid string, resourceSid string, params *ListIncomingPhoneNumberAssignedAddOnParams, reqEditors ...client.RequestEditorFn) (*ListIncomingPhoneNumberAssignedAddOnResponse, error)

	// CreateIncomingPhoneNumberAssignedAddOn request with any body
	CreateIncomingPhoneNumberAssignedAddOnWithBody(ctx context.Context, accountSid string, resourceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateIncomingPhoneNumberAssignedAddOnResponse, error)

	// ListIncomingPhoneNumberAssignedAddOnExtension request
	ListIncomingPhoneNumberAssignedAddOnExtension(ctx context.Context, accountSid string, resourceSid string, assignedAddOnSid string, params *ListIncomingPhoneNumberAssignedAddOnExtensionParams, reqEditors ...client.RequestEditorFn) (*ListIncomingPhoneNumberAssignedAddOnExtensionResponse, error)

	// FetchIncomingPhoneNumberAssignedAddOnExtension request
	FetchIncomingPhoneNumberAssignedAddOnExtension(ctx context.Context, accountSid string, resourceSid string, assignedAddOnSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchIncomingPhoneNumberAssignedAddOnExtensionResponse, error)

	// DeleteIncomingPhoneNumberAssignedAddOn request
	DeleteIncomingPhoneNumberAssignedAddOn(ctx context.Context, accountSid string, resourceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteIncomingPhoneNumberAssignedAddOnResponse, error)

	// FetchIncomingPhoneNumberAssignedAddOn request
	FetchIncomingPhoneNumberAssignedAddOn(ctx context.Context, accountSid string, resourceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchIncomingPhoneNumberAssignedAddOnResponse, error)

	// DeleteIncomingPhoneNumber request
	DeleteIncomingPhoneNumber(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteIncomingPhoneNumberResponse, error)

	// FetchIncomingPhoneNumber request
	FetchIncomingPhoneNumber(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchIncomingPhoneNumberResponse, error)

	// UpdateIncomingPhoneNumber request with any body
	UpdateIncomingPhoneNumberWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateIncomingPhoneNumberResponse, error)

	// ListKey request
	ListKey(ctx context.Context, accountSid string, params *ListKeyParams, reqEditors ...client.RequestEditorFn) (*ListKeyResponse, error)

	// CreateNewKey request with any body
	CreateNewKeyWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateNewKeyResponse, error)

	// DeleteKey request
	DeleteKey(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteKeyResponse, error)

	// FetchKey request
	FetchKey(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchKeyResponse, error)

	// UpdateKey request with any body
	UpdateKeyWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateKeyResponse, error)

	// ListMessage request
	ListMessage(ctx context.Context, accountSid string, params *ListMessageParams, reqEditors ...client.RequestEditorFn) (*ListMessageResponse, error)

	// CreateMessage request with any body
	CreateMessageWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateMessageResponse, error)

	// CreateMessageFeedback request with any body
	CreateMessageFeedbackWithBody(ctx context.Context, accountSid string, messageSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateMessageFeedbackResponse, error)

	// ListMedia request
	ListMedia(ctx context.Context, accountSid string, messageSid string, params *ListMediaParams, reqEditors ...client.RequestEditorFn) (*ListMediaResponse, error)

	// DeleteMedia request
	DeleteMedia(ctx context.Context, accountSid string, messageSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteMediaResponse, error)

	// FetchMedia request
	FetchMedia(ctx context.Context, accountSid string, messageSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchMediaResponse, error)

	// DeleteMessage request
	DeleteMessage(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteMessageResponse, error)

	// FetchMessage request
	FetchMessage(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchMessageResponse, error)

	// UpdateMessage request with any body
	UpdateMessageWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateMessageResponse, error)

	// ListNotification request
	ListNotification(ctx context.Context, accountSid string, params *ListNotificationParams, reqEditors ...client.RequestEditorFn) (*ListNotificationResponse, error)

	// FetchNotification request
	FetchNotification(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchNotificationResponse, error)

	// ListOutgoingCallerId request
	ListOutgoingCallerId(ctx context.Context, accountSid string, params *ListOutgoingCallerIdParams, reqEditors ...client.RequestEditorFn) (*ListOutgoingCallerIdResponse, error)

	// CreateValidationRequest request with any body
	CreateValidationRequestWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateValidationRequestResponse, error)

	// DeleteOutgoingCallerId request
	DeleteOutgoingCallerId(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteOutgoingCallerIdResponse, error)

	// FetchOutgoingCallerId request
	FetchOutgoingCallerId(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchOutgoingCallerIdResponse, error)

	// UpdateOutgoingCallerId request with any body
	UpdateOutgoingCallerIdWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateOutgoingCallerIdResponse, error)

	// ListQueue request
	ListQueue(ctx context.Context, accountSid string, params *ListQueueParams, reqEditors ...client.RequestEditorFn) (*ListQueueResponse, error)

	// CreateQueue request with any body
	CreateQueueWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateQueueResponse, error)

	// ListMember request
	ListMember(ctx context.Context, accountSid string, queueSid string, params *ListMemberParams, reqEditors ...client.RequestEditorFn) (*ListMemberResponse, error)

	// FetchMember request
	FetchMember(ctx context.Context, accountSid string, queueSid string, callSid string, reqEditors ...client.RequestEditorFn) (*FetchMemberResponse, error)

	// UpdateMember request with any body
	UpdateMemberWithBody(ctx context.Context, accountSid string, queueSid string, callSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateMemberResponse, error)

	// DeleteQueue request
	DeleteQueue(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteQueueResponse, error)

	// FetchQueue request
	FetchQueue(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchQueueResponse, error)

	// UpdateQueue request with any body
	UpdateQueueWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateQueueResponse, error)

	// ListRecording request
	ListRecording(ctx context.Context, accountSid string, params *ListRecordingParams, reqEditors ...client.RequestEditorFn) (*ListRecordingResponse, error)

	// ListRecordingTranscription request
	ListRecordingTranscription(ctx context.Context, accountSid string, recordingSid string, params *ListRecordingTranscriptionParams, reqEditors ...client.RequestEditorFn) (*ListRecordingTranscriptionResponse, error)

	// DeleteRecordingTranscription request
	DeleteRecordingTranscription(ctx context.Context, accountSid string, recordingSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteRecordingTranscriptionResponse, error)

	// FetchRecordingTranscription request
	FetchRecordingTranscription(ctx context.Context, accountSid string, recordingSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchRecordingTranscriptionResponse, error)

	// ListRecordingAddOnResult request
	ListRecordingAddOnResult(ctx context.Context, accountSid string, referenceSid string, params *ListRecordingAddOnResultParams, reqEditors ...client.RequestEditorFn) (*ListRecordingAddOnResultResponse, error)

	// ListRecordingAddOnResultPayload request
	ListRecordingAddOnResultPayload(ctx context.Context, accountSid string, referenceSid string, addOnResultSid string, params *ListRecordingAddOnResultPayloadParams, reqEditors ...client.RequestEditorFn) (*ListRecordingAddOnResultPayloadResponse, error)

	// DeleteRecordingAddOnResultPayload request
	DeleteRecordingAddOnResultPayload(ctx context.Context, accountSid string, referenceSid string, addOnResultSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteRecordingAddOnResultPayloadResponse, error)

	// FetchRecordingAddOnResultPayload request
	FetchRecordingAddOnResultPayload(ctx context.Context, accountSid string, referenceSid string, addOnResultSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchRecordingAddOnResultPayloadResponse, error)

	// DeleteRecordingAddOnResult request
	DeleteRecordingAddOnResult(ctx context.Context, accountSid string, referenceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteRecordingAddOnResultResponse, error)

	// FetchRecordingAddOnResult request
	FetchRecordingAddOnResult(ctx context.Context, accountSid string, referenceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchRecordingAddOnResultResponse, error)

	// DeleteRecording request
	DeleteRecording(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteRecordingResponse, error)

	// FetchRecording request
	FetchRecording(ctx context.Context, accountSid string, sid string, params *FetchRecordingParams, reqEditors ...client.RequestEditorFn) (*FetchRecordingResponse, error)

	// ListSipCredentialList request
	ListSipCredentialList(ctx context.Context, accountSid string, params *ListSipCredentialListParams, reqEditors ...client.RequestEditorFn) (*ListSipCredentialListResponse, error)

	// CreateSipCredentialList request with any body
	CreateSipCredentialListWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSipCredentialListResponse, error)

	// ListSipCredential request
	ListSipCredential(ctx context.Context, accountSid string, credentialListSid string, params *ListSipCredentialParams, reqEditors ...client.RequestEditorFn) (*ListSipCredentialResponse, error)

	// CreateSipCredential request with any body
	CreateSipCredentialWithBody(ctx context.Context, accountSid string, credentialListSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSipCredentialResponse, error)

	// DeleteSipCredential request
	DeleteSipCredential(ctx context.Context, accountSid string, credentialListSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSipCredentialResponse, error)

	// FetchSipCredential request
	FetchSipCredential(ctx context.Context, accountSid string, credentialListSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSipCredentialResponse, error)

	// UpdateSipCredential request with any body
	UpdateSipCredentialWithBody(ctx context.Context, accountSid string, credentialListSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSipCredentialResponse, error)

	// DeleteSipCredentialList request
	DeleteSipCredentialList(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSipCredentialListResponse, error)

	// FetchSipCredentialList request
	FetchSipCredentialList(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSipCredentialListResponse, error)

	// UpdateSipCredentialList request with any body
	UpdateSipCredentialListWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSipCredentialListResponse, error)

	// ListSipDomain request
	ListSipDomain(ctx context.Context, accountSid string, params *ListSipDomainParams, reqEditors ...client.RequestEditorFn) (*ListSipDomainResponse, error)

	// CreateSipDomain request with any body
	CreateSipDomainWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSipDomainResponse, error)

	// ListSipAuthCallsCredentialListMapping request
	ListSipAuthCallsCredentialListMapping(ctx context.Context, accountSid string, domainSid string, params *ListSipAuthCallsCredentialListMappingParams, reqEditors ...client.RequestEditorFn) (*ListSipAuthCallsCredentialListMappingResponse, error)

	// CreateSipAuthCallsCredentialListMapping request with any body
	CreateSipAuthCallsCredentialListMappingWithBody(ctx context.Context, accountSid string, domainSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSipAuthCallsCredentialListMappingResponse, error)

	// DeleteSipAuthCallsCredentialListMapping request
	DeleteSipAuthCallsCredentialListMapping(ctx context.Context, accountSid string, domainSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSipAuthCallsCredentialListMappingResponse, error)

	// FetchSipAuthCallsCredentialListMapping request
	FetchSipAuthCallsCredentialListMapping(ctx context.Context, accountSid string, domainSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSipAuthCallsCredentialListMappingResponse, error)

	// ListSipAuthCallsIpAccessControlListMapping request
	ListSipAuthCallsIpAccessControlListMapping(ctx context.Context, accountSid string, domainSid string, params *ListSipAuthCallsIpAccessControlListMappingParams, reqEditors ...client.RequestEditorFn) (*ListSipAuthCallsIpAccessControlListMappingResponse, error)

	// CreateSipAuthCallsIpAccessControlListMapping request with any body
	CreateSipAuthCallsIpAccessControlListMappingWithBody(ctx context.Context, accountSid string, domainSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSipAuthCallsIpAccessControlListMappingResponse, error)

	// DeleteSipAuthCallsIpAccessControlListMapping request
	DeleteSipAuthCallsIpAccessControlListMapping(ctx context.Context, accountSid string, domainSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSipAuthCallsIpAccessControlListMappingResponse, error)

	// FetchSipAuthCallsIpAccessControlListMapping request
	FetchSipAuthCallsIpAccessControlListMapping(ctx context.Context, accountSid string, domainSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSipAuthCallsIpAccessControlListMappingResponse, error)

	// ListSipAuthRegistrationsCredentialListMapping request
	ListSipAuthRegistrationsCredentialListMapping(ctx context.Context, accountSid string, domainSid string, params *ListSipAuthRegistrationsCredentialListMappingParams, reqEditors ...client.RequestEditorFn) (*ListSipAuthRegistrationsCredentialListMappingResponse, error)

	// CreateSipAuthRegistrationsCredentialListMapping request with any body
	CreateSipAuthRegistrationsCredentialListMappingWithBody(ctx context.Context, accountSid string, domainSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSipAuthRegistrationsCredentialListMappingResponse, error)

	// DeleteSipAuthRegistrationsCredentialListMapping request
	DeleteSipAuthRegistrationsCredentialListMapping(ctx context.Context, accountSid string, domainSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSipAuthRegistrationsCredentialListMappingResponse, error)

	// FetchSipAuthRegistrationsCredentialListMapping request
	FetchSipAuthRegistrationsCredentialListMapping(ctx context.Context, accountSid string, domainSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSipAuthRegistrationsCredentialListMappingResponse, error)

	// ListSipCredentialListMapping request
	ListSipCredentialListMapping(ctx context.Context, accountSid string, domainSid string, params *ListSipCredentialListMappingParams, reqEditors ...client.RequestEditorFn) (*ListSipCredentialListMappingResponse, error)

	// CreateSipCredentialListMapping request with any body
	CreateSipCredentialListMappingWithBody(ctx context.Context, accountSid string, domainSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSipCredentialListMappingResponse, error)

	// DeleteSipCredentialListMapping request
	DeleteSipCredentialListMapping(ctx context.Context, accountSid string, domainSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSipCredentialListMappingResponse, error)

	// FetchSipCredentialListMapping request
	FetchSipCredentialListMapping(ctx context.Context, accountSid string, domainSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSipCredentialListMappingResponse, error)

	// ListSipIpAccessControlListMapping request
	ListSipIpAccessControlListMapping(ctx context.Context, accountSid string, domainSid string, params *ListSipIpAccessControlListMappingParams, reqEditors ...client.RequestEditorFn) (*ListSipIpAccessControlListMappingResponse, error)

	// CreateSipIpAccessControlListMapping request with any body
	CreateSipIpAccessControlListMappingWithBody(ctx context.Context, accountSid string, domainSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSipIpAccessControlListMappingResponse, error)

	// DeleteSipIpAccessControlListMapping request
	DeleteSipIpAccessControlListMapping(ctx context.Context, accountSid string, domainSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSipIpAccessControlListMappingResponse, error)

	// FetchSipIpAccessControlListMapping request
	FetchSipIpAccessControlListMapping(ctx context.Context, accountSid string, domainSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSipIpAccessControlListMappingResponse, error)

	// DeleteSipDomain request
	DeleteSipDomain(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSipDomainResponse, error)

	// FetchSipDomain request
	FetchSipDomain(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSipDomainResponse, error)

	// UpdateSipDomain request with any body
	UpdateSipDomainWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSipDomainResponse, error)

	// ListSipIpAccessControlList request
	ListSipIpAccessControlList(ctx context.Context, accountSid string, params *ListSipIpAccessControlListParams, reqEditors ...client.RequestEditorFn) (*ListSipIpAccessControlListResponse, error)

	// CreateSipIpAccessControlList request with any body
	CreateSipIpAccessControlListWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSipIpAccessControlListResponse, error)

	// ListSipIpAddress request
	ListSipIpAddress(ctx context.Context, accountSid string, ipAccessControlListSid string, params *ListSipIpAddressParams, reqEditors ...client.RequestEditorFn) (*ListSipIpAddressResponse, error)

	// CreateSipIpAddress request with any body
	CreateSipIpAddressWithBody(ctx context.Context, accountSid string, ipAccessControlListSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSipIpAddressResponse, error)

	// DeleteSipIpAddress request
	DeleteSipIpAddress(ctx context.Context, accountSid string, ipAccessControlListSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSipIpAddressResponse, error)

	// FetchSipIpAddress request
	FetchSipIpAddress(ctx context.Context, accountSid string, ipAccessControlListSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSipIpAddressResponse, error)

	// UpdateSipIpAddress request with any body
	UpdateSipIpAddressWithBody(ctx context.Context, accountSid string, ipAccessControlListSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSipIpAddressResponse, error)

	// DeleteSipIpAccessControlList request
	DeleteSipIpAccessControlList(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSipIpAccessControlListResponse, error)

	// FetchSipIpAccessControlList request
	FetchSipIpAccessControlList(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSipIpAccessControlListResponse, error)

	// UpdateSipIpAccessControlList request with any body
	UpdateSipIpAccessControlListWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSipIpAccessControlListResponse, error)

	// ListShortCode request
	ListShortCode(ctx context.Context, accountSid string, params *ListShortCodeParams, reqEditors ...client.RequestEditorFn) (*ListShortCodeResponse, error)

	// FetchShortCode request
	FetchShortCode(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchShortCodeResponse, error)

	// UpdateShortCode request with any body
	UpdateShortCodeWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateShortCodeResponse, error)

	// ListSigningKey request
	ListSigningKey(ctx context.Context, accountSid string, params *ListSigningKeyParams, reqEditors ...client.RequestEditorFn) (*ListSigningKeyResponse, error)

	// CreateNewSigningKey request with any body
	CreateNewSigningKeyWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateNewSigningKeyResponse, error)

	// DeleteSigningKey request
	DeleteSigningKey(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSigningKeyResponse, error)

	// FetchSigningKey request
	FetchSigningKey(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSigningKeyResponse, error)

	// UpdateSigningKey request with any body
	UpdateSigningKeyWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSigningKeyResponse, error)

	// CreateToken request with any body
	CreateTokenWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateTokenResponse, error)

	// ListTranscription request
	ListTranscription(ctx context.Context, accountSid string, params *ListTranscriptionParams, reqEditors ...client.RequestEditorFn) (*ListTranscriptionResponse, error)

	// DeleteTranscription request
	DeleteTranscription(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteTranscriptionResponse, error)

	// FetchTranscription request
	FetchTranscription(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchTranscriptionResponse, error)

	// ListUsageRecord request
	ListUsageRecord(ctx context.Context, accountSid string, params *ListUsageRecordParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordResponse, error)

	// ListUsageRecordAllTime request
	ListUsageRecordAllTime(ctx context.Context, accountSid string, params *ListUsageRecordAllTimeParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordAllTimeResponse, error)

	// ListUsageRecordDaily request
	ListUsageRecordDaily(ctx context.Context, accountSid string, params *ListUsageRecordDailyParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordDailyResponse, error)

	// ListUsageRecordLastMonth request
	ListUsageRecordLastMonth(ctx context.Context, accountSid string, params *ListUsageRecordLastMonthParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordLastMonthResponse, error)

	// ListUsageRecordMonthly request
	ListUsageRecordMonthly(ctx context.Context, accountSid string, params *ListUsageRecordMonthlyParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordMonthlyResponse, error)

	// ListUsageRecordThisMonth request
	ListUsageRecordThisMonth(ctx context.Context, accountSid string, params *ListUsageRecordThisMonthParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordThisMonthResponse, error)

	// ListUsageRecordToday request
	ListUsageRecordToday(ctx context.Context, accountSid string, params *ListUsageRecordTodayParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordTodayResponse, error)

	// ListUsageRecordYearly request
	ListUsageRecordYearly(ctx context.Context, accountSid string, params *ListUsageRecordYearlyParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordYearlyResponse, error)

	// ListUsageRecordYesterday request
	ListUsageRecordYesterday(ctx context.Context, accountSid string, params *ListUsageRecordYesterdayParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordYesterdayResponse, error)

	// ListUsageTrigger request
	ListUsageTrigger(ctx context.Context, accountSid string, params *ListUsageTriggerParams, reqEditors ...client.RequestEditorFn) (*ListUsageTriggerResponse, error)

	// CreateUsageTrigger request with any body
	CreateUsageTriggerWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateUsageTriggerResponse, error)

	// DeleteUsageTrigger request
	DeleteUsageTrigger(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteUsageTriggerResponse, error)

	// FetchUsageTrigger request
	FetchUsageTrigger(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchUsageTriggerResponse, error)

	// UpdateUsageTrigger request with any body
	UpdateUsageTriggerWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateUsageTriggerResponse, error)

	// FetchAccount request
	FetchAccount(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchAccountResponse, error)

	// UpdateAccount request with any body
	UpdateAccountWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateAccountResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// ListAccount: GET /2010-04-01/Accounts.json

type ListAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Accounts        *[]ApiV2010Account `json:"accounts,omitempty"`
		End             *int               `json:"end,omitempty"`
		FirstPageUri    *string            `json:"first_page_uri,omitempty"`
		NextPageUri     *string            `json:"next_page_uri,omitempty"`
		Page            *int               `json:"page,omitempty"`
		PageSize        *int               `json:"page_size,omitempty"`
		PreviousPageUri *string            `json:"previous_page_uri,omitempty"`
		Start           *int               `json:"start,omitempty"`
		Uri             *string            `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListAccountRequest generates requests for ListAccount
func newListAccountRequest(baseURL *url.URL, params *ListAccountParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListAccount)

	q := queryURL.Query()

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListAccount returns a parsed response.
// GET /2010-04-01/Accounts.json
func (c *Client) ListAccount(ctx context.Context, params *ListAccountParams, reqEditors ...client.RequestEditorFn) (*ListAccountResponse, error) {
	req, err := newListAccountRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Accounts        *[]ApiV2010Account `json:"accounts,omitempty"`
			End             *int               `json:"end,omitempty"`
			FirstPageUri    *string            `json:"first_page_uri,omitempty"`
			NextPageUri     *string            `json:"next_page_uri,omitempty"`
			Page            *int               `json:"page,omitempty"`
			PageSize        *int               `json:"page_size,omitempty"`
			PreviousPageUri *string            `json:"previous_page_uri,omitempty"`
			Start           *int               `json:"start,omitempty"`
			Uri             *string            `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateAccount: POST /2010-04-01/Accounts.json

type CreateAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010Account
}

// Status returns HTTPResponse.Status
func (r CreateAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateAccountRequestWithBody generates requests for CreateAccount with any type of body
func newCreateAccountRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateAccount)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateAccountWithBody returns a parsed response.
// POST /2010-04-01/Accounts.json
func (c *Client) CreateAccountWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateAccountResponse, error) {
	req, err := newCreateAccountRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010Account
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListAddress: GET /2010-04-01/Accounts/{AccountSid}/Addresses.json

type ListAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Addresses       *[]ApiV2010AccountAddress `json:"addresses,omitempty"`
		End             *int                      `json:"end,omitempty"`
		FirstPageUri    *string                   `json:"first_page_uri,omitempty"`
		NextPageUri     *string                   `json:"next_page_uri,omitempty"`
		Page            *int                      `json:"page,omitempty"`
		PageSize        *int                      `json:"page_size,omitempty"`
		PreviousPageUri *string                   `json:"previous_page_uri,omitempty"`
		Start           *int                      `json:"start,omitempty"`
		Uri             *string                   `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListAddressRequest generates requests for ListAddress
func newListAddressRequest(baseURL *url.URL, accountSid string, params *ListAddressParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListAddressFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.CustomerName != nil {
		if err := client.AddQueryParam(q, "CustomerName", *params.CustomerName); err != nil {
			return nil, err
		}
	}

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.IsoCountry != nil {
		if err := client.AddQueryParam(q, "IsoCountry", *params.IsoCountry); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListAddress returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Addresses.json
func (c *Client) ListAddress(ctx context.Context, accountSid string, params *ListAddressParams, reqEditors ...client.RequestEditorFn) (*ListAddressResponse, error) {
	req, err := newListAddressRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Addresses       *[]ApiV2010AccountAddress `json:"addresses,omitempty"`
			End             *int                      `json:"end,omitempty"`
			FirstPageUri    *string                   `json:"first_page_uri,omitempty"`
			NextPageUri     *string                   `json:"next_page_uri,omitempty"`
			Page            *int                      `json:"page,omitempty"`
			PageSize        *int                      `json:"page_size,omitempty"`
			PreviousPageUri *string                   `json:"previous_page_uri,omitempty"`
			Start           *int                      `json:"start,omitempty"`
			Uri             *string                   `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateAddress: POST /2010-04-01/Accounts/{AccountSid}/Addresses.json

type CreateAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountAddress
}

// Status returns HTTPResponse.Status
func (r CreateAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateAddressRequestWithBody generates requests for CreateAddress with any type of body
func newCreateAddressRequestWithBody(baseURL *url.URL, accountSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateAddressFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateAddressWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Addresses.json
func (c *Client) CreateAddressWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateAddressResponse, error) {
	req, err := newCreateAddressRequestWithBody(c.BaseURL, accountSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountAddress
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListDependentPhoneNumber: GET /2010-04-01/Accounts/{AccountSid}/Addresses/{AddressSid}/DependentPhoneNumbers.json

type ListDependentPhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DependentPhoneNumbers *[]ApiV2010AccountAddressDependentPhoneNumber `json:"dependent_phone_numbers,omitempty"`
		End                   *int                                          `json:"end,omitempty"`
		FirstPageUri          *string                                       `json:"first_page_uri,omitempty"`
		NextPageUri           *string                                       `json:"next_page_uri,omitempty"`
		Page                  *int                                          `json:"page,omitempty"`
		PageSize              *int                                          `json:"page_size,omitempty"`
		PreviousPageUri       *string                                       `json:"previous_page_uri,omitempty"`
		Start                 *int                                          `json:"start,omitempty"`
		Uri                   *string                                       `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDependentPhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDependentPhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListDependentPhoneNumberRequest generates requests for ListDependentPhoneNumber
func newListDependentPhoneNumberRequest(baseURL *url.URL, accountSid string, addressSid string, params *ListDependentPhoneNumberParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("AddressSid", addressSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListDependentPhoneNumberFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListDependentPhoneNumber returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Addresses/{AddressSid}/DependentPhoneNumbers.json
func (c *Client) ListDependentPhoneNumber(ctx context.Context, accountSid string, addressSid string, params *ListDependentPhoneNumberParams, reqEditors ...client.RequestEditorFn) (*ListDependentPhoneNumberResponse, error) {
	req, err := newListDependentPhoneNumberRequest(c.BaseURL, accountSid, addressSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListDependentPhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DependentPhoneNumbers *[]ApiV2010AccountAddressDependentPhoneNumber `json:"dependent_phone_numbers,omitempty"`
			End                   *int                                          `json:"end,omitempty"`
			FirstPageUri          *string                                       `json:"first_page_uri,omitempty"`
			NextPageUri           *string                                       `json:"next_page_uri,omitempty"`
			Page                  *int                                          `json:"page,omitempty"`
			PageSize              *int                                          `json:"page_size,omitempty"`
			PreviousPageUri       *string                                       `json:"previous_page_uri,omitempty"`
			Start                 *int                                          `json:"start,omitempty"`
			Uri                   *string                                       `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteAddress: DELETE /2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json

type DeleteAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteAddressRequest generates requests for DeleteAddress
func newDeleteAddressRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteAddressFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteAddress returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json
func (c *Client) DeleteAddress(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteAddressResponse, error) {
	req, err := newDeleteAddressRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchAddress: GET /2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json

type FetchAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountAddress
}

// Status returns HTTPResponse.Status
func (r FetchAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchAddressRequest generates requests for FetchAddress
func newFetchAddressRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchAddressFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchAddress returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json
func (c *Client) FetchAddress(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchAddressResponse, error) {
	req, err := newFetchAddressRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountAddress
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateAddress: POST /2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json

type UpdateAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountAddress
}

// Status returns HTTPResponse.Status
func (r UpdateAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateAddressRequestWithBody generates requests for UpdateAddress with any type of body
func newUpdateAddressRequestWithBody(baseURL *url.URL, accountSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateAddressFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateAddressWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Addresses/{Sid}.json
func (c *Client) UpdateAddressWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateAddressResponse, error) {
	req, err := newUpdateAddressRequestWithBody(c.BaseURL, accountSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountAddress
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListApplication: GET /2010-04-01/Accounts/{AccountSid}/Applications.json

type ListApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Applications    *[]ApiV2010AccountApplication `json:"applications,omitempty"`
		End             *int                          `json:"end,omitempty"`
		FirstPageUri    *string                       `json:"first_page_uri,omitempty"`
		NextPageUri     *string                       `json:"next_page_uri,omitempty"`
		Page            *int                          `json:"page,omitempty"`
		PageSize        *int                          `json:"page_size,omitempty"`
		PreviousPageUri *string                       `json:"previous_page_uri,omitempty"`
		Start           *int                          `json:"start,omitempty"`
		Uri             *string                       `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListApplicationRequest generates requests for ListApplication
func newListApplicationRequest(baseURL *url.URL, accountSid string, params *ListApplicationParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListApplicationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListApplication returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Applications.json
func (c *Client) ListApplication(ctx context.Context, accountSid string, params *ListApplicationParams, reqEditors ...client.RequestEditorFn) (*ListApplicationResponse, error) {
	req, err := newListApplicationRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Applications    *[]ApiV2010AccountApplication `json:"applications,omitempty"`
			End             *int                          `json:"end,omitempty"`
			FirstPageUri    *string                       `json:"first_page_uri,omitempty"`
			NextPageUri     *string                       `json:"next_page_uri,omitempty"`
			Page            *int                          `json:"page,omitempty"`
			PageSize        *int                          `json:"page_size,omitempty"`
			PreviousPageUri *string                       `json:"previous_page_uri,omitempty"`
			Start           *int                          `json:"start,omitempty"`
			Uri             *string                       `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateApplication: POST /2010-04-01/Accounts/{AccountSid}/Applications.json

type CreateApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountApplication
}

// Status returns HTTPResponse.Status
func (r CreateApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateApplicationRequestWithBody generates requests for CreateApplication with any type of body
func newCreateApplicationRequestWithBody(baseURL *url.URL, accountSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateApplicationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateApplicationWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Applications.json
func (c *Client) CreateApplicationWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateApplicationResponse, error) {
	req, err := newCreateApplicationRequestWithBody(c.BaseURL, accountSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountApplication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteApplication: DELETE /2010-04-01/Accounts/{AccountSid}/Applications/{Sid}.json

type DeleteApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteApplicationRequest generates requests for DeleteApplication
func newDeleteApplicationRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteApplicationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteApplication returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/Applications/{Sid}.json
func (c *Client) DeleteApplication(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteApplicationResponse, error) {
	req, err := newDeleteApplicationRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchApplication: GET /2010-04-01/Accounts/{AccountSid}/Applications/{Sid}.json

type FetchApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountApplication
}

// Status returns HTTPResponse.Status
func (r FetchApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchApplicationRequest generates requests for FetchApplication
func newFetchApplicationRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchApplicationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchApplication returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Applications/{Sid}.json
func (c *Client) FetchApplication(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchApplicationResponse, error) {
	req, err := newFetchApplicationRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountApplication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateApplication: POST /2010-04-01/Accounts/{AccountSid}/Applications/{Sid}.json

type UpdateApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountApplication
}

// Status returns HTTPResponse.Status
func (r UpdateApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateApplicationRequestWithBody generates requests for UpdateApplication with any type of body
func newUpdateApplicationRequestWithBody(baseURL *url.URL, accountSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateApplicationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateApplicationWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Applications/{Sid}.json
func (c *Client) UpdateApplicationWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateApplicationResponse, error) {
	req, err := newUpdateApplicationRequestWithBody(c.BaseURL, accountSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountApplication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListAuthorizedConnectApp: GET /2010-04-01/Accounts/{AccountSid}/AuthorizedConnectApps.json

type ListAuthorizedConnectAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AuthorizedConnectApps *[]ApiV2010AccountAuthorizedConnectApp `json:"authorized_connect_apps,omitempty"`
		End                   *int                                   `json:"end,omitempty"`
		FirstPageUri          *string                                `json:"first_page_uri,omitempty"`
		NextPageUri           *string                                `json:"next_page_uri,omitempty"`
		Page                  *int                                   `json:"page,omitempty"`
		PageSize              *int                                   `json:"page_size,omitempty"`
		PreviousPageUri       *string                                `json:"previous_page_uri,omitempty"`
		Start                 *int                                   `json:"start,omitempty"`
		Uri                   *string                                `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAuthorizedConnectAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAuthorizedConnectAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListAuthorizedConnectAppRequest generates requests for ListAuthorizedConnectApp
func newListAuthorizedConnectAppRequest(baseURL *url.URL, accountSid string, params *ListAuthorizedConnectAppParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListAuthorizedConnectAppFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListAuthorizedConnectApp returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/AuthorizedConnectApps.json
func (c *Client) ListAuthorizedConnectApp(ctx context.Context, accountSid string, params *ListAuthorizedConnectAppParams, reqEditors ...client.RequestEditorFn) (*ListAuthorizedConnectAppResponse, error) {
	req, err := newListAuthorizedConnectAppRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListAuthorizedConnectAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AuthorizedConnectApps *[]ApiV2010AccountAuthorizedConnectApp `json:"authorized_connect_apps,omitempty"`
			End                   *int                                   `json:"end,omitempty"`
			FirstPageUri          *string                                `json:"first_page_uri,omitempty"`
			NextPageUri           *string                                `json:"next_page_uri,omitempty"`
			Page                  *int                                   `json:"page,omitempty"`
			PageSize              *int                                   `json:"page_size,omitempty"`
			PreviousPageUri       *string                                `json:"previous_page_uri,omitempty"`
			Start                 *int                                   `json:"start,omitempty"`
			Uri                   *string                                `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchAuthorizedConnectApp: GET /2010-04-01/Accounts/{AccountSid}/AuthorizedConnectApps/{ConnectAppSid}.json

type FetchAuthorizedConnectAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountAuthorizedConnectApp
}

// Status returns HTTPResponse.Status
func (r FetchAuthorizedConnectAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchAuthorizedConnectAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchAuthorizedConnectAppRequest generates requests for FetchAuthorizedConnectApp
func newFetchAuthorizedConnectAppRequest(baseURL *url.URL, accountSid string, connectAppSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConnectAppSid", connectAppSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchAuthorizedConnectAppFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchAuthorizedConnectApp returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/AuthorizedConnectApps/{ConnectAppSid}.json
func (c *Client) FetchAuthorizedConnectApp(ctx context.Context, accountSid string, connectAppSid string, reqEditors ...client.RequestEditorFn) (*FetchAuthorizedConnectAppResponse, error) {
	req, err := newFetchAuthorizedConnectAppRequest(c.BaseURL, accountSid, connectAppSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchAuthorizedConnectAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountAuthorizedConnectApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListAvailablePhoneNumberCountry: GET /2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers.json

type ListAvailablePhoneNumberCountryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Countries       *[]ApiV2010AccountAvailablePhoneNumberCountry `json:"countries,omitempty"`
		End             *int                                          `json:"end,omitempty"`
		FirstPageUri    *string                                       `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                       `json:"next_page_uri,omitempty"`
		Page            *int                                          `json:"page,omitempty"`
		PageSize        *int                                          `json:"page_size,omitempty"`
		PreviousPageUri *string                                       `json:"previous_page_uri,omitempty"`
		Start           *int                                          `json:"start,omitempty"`
		Uri             *string                                       `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAvailablePhoneNumberCountryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailablePhoneNumberCountryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListAvailablePhoneNumberCountryRequest generates requests for ListAvailablePhoneNumberCountry
func newListAvailablePhoneNumberCountryRequest(baseURL *url.URL, accountSid string, params *ListAvailablePhoneNumberCountryParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListAvailablePhoneNumberCountryFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListAvailablePhoneNumberCountry returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers.json
func (c *Client) ListAvailablePhoneNumberCountry(ctx context.Context, accountSid string, params *ListAvailablePhoneNumberCountryParams, reqEditors ...client.RequestEditorFn) (*ListAvailablePhoneNumberCountryResponse, error) {
	req, err := newListAvailablePhoneNumberCountryRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListAvailablePhoneNumberCountryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Countries       *[]ApiV2010AccountAvailablePhoneNumberCountry `json:"countries,omitempty"`
			End             *int                                          `json:"end,omitempty"`
			FirstPageUri    *string                                       `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                       `json:"next_page_uri,omitempty"`
			Page            *int                                          `json:"page,omitempty"`
			PageSize        *int                                          `json:"page_size,omitempty"`
			PreviousPageUri *string                                       `json:"previous_page_uri,omitempty"`
			Start           *int                                          `json:"start,omitempty"`
			Uri             *string                                       `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchAvailablePhoneNumberCountry: GET /2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}.json

type FetchAvailablePhoneNumberCountryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountAvailablePhoneNumberCountry
}

// Status returns HTTPResponse.Status
func (r FetchAvailablePhoneNumberCountryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchAvailablePhoneNumberCountryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchAvailablePhoneNumberCountryRequest generates requests for FetchAvailablePhoneNumberCountry
func newFetchAvailablePhoneNumberCountryRequest(baseURL *url.URL, accountSid string, countryCode string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CountryCode", countryCode)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchAvailablePhoneNumberCountryFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchAvailablePhoneNumberCountry returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}.json
func (c *Client) FetchAvailablePhoneNumberCountry(ctx context.Context, accountSid string, countryCode string, reqEditors ...client.RequestEditorFn) (*FetchAvailablePhoneNumberCountryResponse, error) {
	req, err := newFetchAvailablePhoneNumberCountryRequest(c.BaseURL, accountSid, countryCode)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchAvailablePhoneNumberCountryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountAvailablePhoneNumberCountry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListAvailablePhoneNumberLocal: GET /2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Local.json

type ListAvailablePhoneNumberLocalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AvailablePhoneNumbers *[]ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberLocal `json:"available_phone_numbers,omitempty"`
		End                   *int                                                                   `json:"end,omitempty"`
		FirstPageUri          *string                                                                `json:"first_page_uri,omitempty"`
		NextPageUri           *string                                                                `json:"next_page_uri,omitempty"`
		Page                  *int                                                                   `json:"page,omitempty"`
		PageSize              *int                                                                   `json:"page_size,omitempty"`
		PreviousPageUri       *string                                                                `json:"previous_page_uri,omitempty"`
		Start                 *int                                                                   `json:"start,omitempty"`
		Uri                   *string                                                                `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAvailablePhoneNumberLocalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailablePhoneNumberLocalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListAvailablePhoneNumberLocalRequest generates requests for ListAvailablePhoneNumberLocal
func newListAvailablePhoneNumberLocalRequest(baseURL *url.URL, accountSid string, countryCode string, params *ListAvailablePhoneNumberLocalParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CountryCode", countryCode)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListAvailablePhoneNumberLocalFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.AreaCode != nil {
		if err := client.AddQueryParam(q, "AreaCode", *params.AreaCode); err != nil {
			return nil, err
		}
	}

	if params.Contains != nil {
		if err := client.AddQueryParam(q, "Contains", *params.Contains); err != nil {
			return nil, err
		}
	}

	if params.SmsEnabled != nil {
		if err := client.AddQueryParam(q, "SmsEnabled", *params.SmsEnabled); err != nil {
			return nil, err
		}
	}

	if params.MmsEnabled != nil {
		if err := client.AddQueryParam(q, "MmsEnabled", *params.MmsEnabled); err != nil {
			return nil, err
		}
	}

	if params.VoiceEnabled != nil {
		if err := client.AddQueryParam(q, "VoiceEnabled", *params.VoiceEnabled); err != nil {
			return nil, err
		}
	}

	if params.ExcludeAllAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeAllAddressRequired", *params.ExcludeAllAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.ExcludeLocalAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeLocalAddressRequired", *params.ExcludeLocalAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.ExcludeForeignAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeForeignAddressRequired", *params.ExcludeForeignAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.Beta != nil {
		if err := client.AddQueryParam(q, "Beta", *params.Beta); err != nil {
			return nil, err
		}
	}

	if params.NearNumber != nil {
		if err := client.AddQueryParam(q, "NearNumber", *params.NearNumber); err != nil {
			return nil, err
		}
	}

	if params.NearLatLong != nil {
		if err := client.AddQueryParam(q, "NearLatLong", *params.NearLatLong); err != nil {
			return nil, err
		}
	}

	if params.Distance != nil {
		if err := client.AddQueryParam(q, "Distance", *params.Distance); err != nil {
			return nil, err
		}
	}

	if params.InPostalCode != nil {
		if err := client.AddQueryParam(q, "InPostalCode", *params.InPostalCode); err != nil {
			return nil, err
		}
	}

	if params.InRegion != nil {
		if err := client.AddQueryParam(q, "InRegion", *params.InRegion); err != nil {
			return nil, err
		}
	}

	if params.InRateCenter != nil {
		if err := client.AddQueryParam(q, "InRateCenter", *params.InRateCenter); err != nil {
			return nil, err
		}
	}

	if params.InLata != nil {
		if err := client.AddQueryParam(q, "InLata", *params.InLata); err != nil {
			return nil, err
		}
	}

	if params.InLocality != nil {
		if err := client.AddQueryParam(q, "InLocality", *params.InLocality); err != nil {
			return nil, err
		}
	}

	if params.FaxEnabled != nil {
		if err := client.AddQueryParam(q, "FaxEnabled", *params.FaxEnabled); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListAvailablePhoneNumberLocal returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Local.json
func (c *Client) ListAvailablePhoneNumberLocal(ctx context.Context, accountSid string, countryCode string, params *ListAvailablePhoneNumberLocalParams, reqEditors ...client.RequestEditorFn) (*ListAvailablePhoneNumberLocalResponse, error) {
	req, err := newListAvailablePhoneNumberLocalRequest(c.BaseURL, accountSid, countryCode, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListAvailablePhoneNumberLocalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AvailablePhoneNumbers *[]ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberLocal `json:"available_phone_numbers,omitempty"`
			End                   *int                                                                   `json:"end,omitempty"`
			FirstPageUri          *string                                                                `json:"first_page_uri,omitempty"`
			NextPageUri           *string                                                                `json:"next_page_uri,omitempty"`
			Page                  *int                                                                   `json:"page,omitempty"`
			PageSize              *int                                                                   `json:"page_size,omitempty"`
			PreviousPageUri       *string                                                                `json:"previous_page_uri,omitempty"`
			Start                 *int                                                                   `json:"start,omitempty"`
			Uri                   *string                                                                `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListAvailablePhoneNumberMachineToMachine: GET /2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/MachineToMachine.json

type ListAvailablePhoneNumberMachineToMachineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AvailablePhoneNumbers *[]ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberMachineToMachine `json:"available_phone_numbers,omitempty"`
		End                   *int                                                                              `json:"end,omitempty"`
		FirstPageUri          *string                                                                           `json:"first_page_uri,omitempty"`
		NextPageUri           *string                                                                           `json:"next_page_uri,omitempty"`
		Page                  *int                                                                              `json:"page,omitempty"`
		PageSize              *int                                                                              `json:"page_size,omitempty"`
		PreviousPageUri       *string                                                                           `json:"previous_page_uri,omitempty"`
		Start                 *int                                                                              `json:"start,omitempty"`
		Uri                   *string                                                                           `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAvailablePhoneNumberMachineToMachineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailablePhoneNumberMachineToMachineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListAvailablePhoneNumberMachineToMachineRequest generates requests for ListAvailablePhoneNumberMachineToMachine
func newListAvailablePhoneNumberMachineToMachineRequest(baseURL *url.URL, accountSid string, countryCode string, params *ListAvailablePhoneNumberMachineToMachineParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CountryCode", countryCode)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListAvailablePhoneNumberMachineToMachineFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.AreaCode != nil {
		if err := client.AddQueryParam(q, "AreaCode", *params.AreaCode); err != nil {
			return nil, err
		}
	}

	if params.Contains != nil {
		if err := client.AddQueryParam(q, "Contains", *params.Contains); err != nil {
			return nil, err
		}
	}

	if params.SmsEnabled != nil {
		if err := client.AddQueryParam(q, "SmsEnabled", *params.SmsEnabled); err != nil {
			return nil, err
		}
	}

	if params.MmsEnabled != nil {
		if err := client.AddQueryParam(q, "MmsEnabled", *params.MmsEnabled); err != nil {
			return nil, err
		}
	}

	if params.VoiceEnabled != nil {
		if err := client.AddQueryParam(q, "VoiceEnabled", *params.VoiceEnabled); err != nil {
			return nil, err
		}
	}

	if params.ExcludeAllAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeAllAddressRequired", *params.ExcludeAllAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.ExcludeLocalAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeLocalAddressRequired", *params.ExcludeLocalAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.ExcludeForeignAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeForeignAddressRequired", *params.ExcludeForeignAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.Beta != nil {
		if err := client.AddQueryParam(q, "Beta", *params.Beta); err != nil {
			return nil, err
		}
	}

	if params.NearNumber != nil {
		if err := client.AddQueryParam(q, "NearNumber", *params.NearNumber); err != nil {
			return nil, err
		}
	}

	if params.NearLatLong != nil {
		if err := client.AddQueryParam(q, "NearLatLong", *params.NearLatLong); err != nil {
			return nil, err
		}
	}

	if params.Distance != nil {
		if err := client.AddQueryParam(q, "Distance", *params.Distance); err != nil {
			return nil, err
		}
	}

	if params.InPostalCode != nil {
		if err := client.AddQueryParam(q, "InPostalCode", *params.InPostalCode); err != nil {
			return nil, err
		}
	}

	if params.InRegion != nil {
		if err := client.AddQueryParam(q, "InRegion", *params.InRegion); err != nil {
			return nil, err
		}
	}

	if params.InRateCenter != nil {
		if err := client.AddQueryParam(q, "InRateCenter", *params.InRateCenter); err != nil {
			return nil, err
		}
	}

	if params.InLata != nil {
		if err := client.AddQueryParam(q, "InLata", *params.InLata); err != nil {
			return nil, err
		}
	}

	if params.InLocality != nil {
		if err := client.AddQueryParam(q, "InLocality", *params.InLocality); err != nil {
			return nil, err
		}
	}

	if params.FaxEnabled != nil {
		if err := client.AddQueryParam(q, "FaxEnabled", *params.FaxEnabled); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListAvailablePhoneNumberMachineToMachine returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/MachineToMachine.json
func (c *Client) ListAvailablePhoneNumberMachineToMachine(ctx context.Context, accountSid string, countryCode string, params *ListAvailablePhoneNumberMachineToMachineParams, reqEditors ...client.RequestEditorFn) (*ListAvailablePhoneNumberMachineToMachineResponse, error) {
	req, err := newListAvailablePhoneNumberMachineToMachineRequest(c.BaseURL, accountSid, countryCode, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListAvailablePhoneNumberMachineToMachineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AvailablePhoneNumbers *[]ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberMachineToMachine `json:"available_phone_numbers,omitempty"`
			End                   *int                                                                              `json:"end,omitempty"`
			FirstPageUri          *string                                                                           `json:"first_page_uri,omitempty"`
			NextPageUri           *string                                                                           `json:"next_page_uri,omitempty"`
			Page                  *int                                                                              `json:"page,omitempty"`
			PageSize              *int                                                                              `json:"page_size,omitempty"`
			PreviousPageUri       *string                                                                           `json:"previous_page_uri,omitempty"`
			Start                 *int                                                                              `json:"start,omitempty"`
			Uri                   *string                                                                           `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListAvailablePhoneNumberMobile: GET /2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Mobile.json

type ListAvailablePhoneNumberMobileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AvailablePhoneNumbers *[]ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberMobile `json:"available_phone_numbers,omitempty"`
		End                   *int                                                                    `json:"end,omitempty"`
		FirstPageUri          *string                                                                 `json:"first_page_uri,omitempty"`
		NextPageUri           *string                                                                 `json:"next_page_uri,omitempty"`
		Page                  *int                                                                    `json:"page,omitempty"`
		PageSize              *int                                                                    `json:"page_size,omitempty"`
		PreviousPageUri       *string                                                                 `json:"previous_page_uri,omitempty"`
		Start                 *int                                                                    `json:"start,omitempty"`
		Uri                   *string                                                                 `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAvailablePhoneNumberMobileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailablePhoneNumberMobileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListAvailablePhoneNumberMobileRequest generates requests for ListAvailablePhoneNumberMobile
func newListAvailablePhoneNumberMobileRequest(baseURL *url.URL, accountSid string, countryCode string, params *ListAvailablePhoneNumberMobileParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CountryCode", countryCode)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListAvailablePhoneNumberMobileFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.AreaCode != nil {
		if err := client.AddQueryParam(q, "AreaCode", *params.AreaCode); err != nil {
			return nil, err
		}
	}

	if params.Contains != nil {
		if err := client.AddQueryParam(q, "Contains", *params.Contains); err != nil {
			return nil, err
		}
	}

	if params.SmsEnabled != nil {
		if err := client.AddQueryParam(q, "SmsEnabled", *params.SmsEnabled); err != nil {
			return nil, err
		}
	}

	if params.MmsEnabled != nil {
		if err := client.AddQueryParam(q, "MmsEnabled", *params.MmsEnabled); err != nil {
			return nil, err
		}
	}

	if params.VoiceEnabled != nil {
		if err := client.AddQueryParam(q, "VoiceEnabled", *params.VoiceEnabled); err != nil {
			return nil, err
		}
	}

	if params.ExcludeAllAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeAllAddressRequired", *params.ExcludeAllAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.ExcludeLocalAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeLocalAddressRequired", *params.ExcludeLocalAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.ExcludeForeignAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeForeignAddressRequired", *params.ExcludeForeignAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.Beta != nil {
		if err := client.AddQueryParam(q, "Beta", *params.Beta); err != nil {
			return nil, err
		}
	}

	if params.NearNumber != nil {
		if err := client.AddQueryParam(q, "NearNumber", *params.NearNumber); err != nil {
			return nil, err
		}
	}

	if params.NearLatLong != nil {
		if err := client.AddQueryParam(q, "NearLatLong", *params.NearLatLong); err != nil {
			return nil, err
		}
	}

	if params.Distance != nil {
		if err := client.AddQueryParam(q, "Distance", *params.Distance); err != nil {
			return nil, err
		}
	}

	if params.InPostalCode != nil {
		if err := client.AddQueryParam(q, "InPostalCode", *params.InPostalCode); err != nil {
			return nil, err
		}
	}

	if params.InRegion != nil {
		if err := client.AddQueryParam(q, "InRegion", *params.InRegion); err != nil {
			return nil, err
		}
	}

	if params.InRateCenter != nil {
		if err := client.AddQueryParam(q, "InRateCenter", *params.InRateCenter); err != nil {
			return nil, err
		}
	}

	if params.InLata != nil {
		if err := client.AddQueryParam(q, "InLata", *params.InLata); err != nil {
			return nil, err
		}
	}

	if params.InLocality != nil {
		if err := client.AddQueryParam(q, "InLocality", *params.InLocality); err != nil {
			return nil, err
		}
	}

	if params.FaxEnabled != nil {
		if err := client.AddQueryParam(q, "FaxEnabled", *params.FaxEnabled); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListAvailablePhoneNumberMobile returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Mobile.json
func (c *Client) ListAvailablePhoneNumberMobile(ctx context.Context, accountSid string, countryCode string, params *ListAvailablePhoneNumberMobileParams, reqEditors ...client.RequestEditorFn) (*ListAvailablePhoneNumberMobileResponse, error) {
	req, err := newListAvailablePhoneNumberMobileRequest(c.BaseURL, accountSid, countryCode, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListAvailablePhoneNumberMobileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AvailablePhoneNumbers *[]ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberMobile `json:"available_phone_numbers,omitempty"`
			End                   *int                                                                    `json:"end,omitempty"`
			FirstPageUri          *string                                                                 `json:"first_page_uri,omitempty"`
			NextPageUri           *string                                                                 `json:"next_page_uri,omitempty"`
			Page                  *int                                                                    `json:"page,omitempty"`
			PageSize              *int                                                                    `json:"page_size,omitempty"`
			PreviousPageUri       *string                                                                 `json:"previous_page_uri,omitempty"`
			Start                 *int                                                                    `json:"start,omitempty"`
			Uri                   *string                                                                 `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListAvailablePhoneNumberNational: GET /2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/National.json

type ListAvailablePhoneNumberNationalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AvailablePhoneNumbers *[]ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberNational `json:"available_phone_numbers,omitempty"`
		End                   *int                                                                      `json:"end,omitempty"`
		FirstPageUri          *string                                                                   `json:"first_page_uri,omitempty"`
		NextPageUri           *string                                                                   `json:"next_page_uri,omitempty"`
		Page                  *int                                                                      `json:"page,omitempty"`
		PageSize              *int                                                                      `json:"page_size,omitempty"`
		PreviousPageUri       *string                                                                   `json:"previous_page_uri,omitempty"`
		Start                 *int                                                                      `json:"start,omitempty"`
		Uri                   *string                                                                   `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAvailablePhoneNumberNationalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailablePhoneNumberNationalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListAvailablePhoneNumberNationalRequest generates requests for ListAvailablePhoneNumberNational
func newListAvailablePhoneNumberNationalRequest(baseURL *url.URL, accountSid string, countryCode string, params *ListAvailablePhoneNumberNationalParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CountryCode", countryCode)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListAvailablePhoneNumberNationalFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.AreaCode != nil {
		if err := client.AddQueryParam(q, "AreaCode", *params.AreaCode); err != nil {
			return nil, err
		}
	}

	if params.Contains != nil {
		if err := client.AddQueryParam(q, "Contains", *params.Contains); err != nil {
			return nil, err
		}
	}

	if params.SmsEnabled != nil {
		if err := client.AddQueryParam(q, "SmsEnabled", *params.SmsEnabled); err != nil {
			return nil, err
		}
	}

	if params.MmsEnabled != nil {
		if err := client.AddQueryParam(q, "MmsEnabled", *params.MmsEnabled); err != nil {
			return nil, err
		}
	}

	if params.VoiceEnabled != nil {
		if err := client.AddQueryParam(q, "VoiceEnabled", *params.VoiceEnabled); err != nil {
			return nil, err
		}
	}

	if params.ExcludeAllAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeAllAddressRequired", *params.ExcludeAllAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.ExcludeLocalAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeLocalAddressRequired", *params.ExcludeLocalAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.ExcludeForeignAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeForeignAddressRequired", *params.ExcludeForeignAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.Beta != nil {
		if err := client.AddQueryParam(q, "Beta", *params.Beta); err != nil {
			return nil, err
		}
	}

	if params.NearNumber != nil {
		if err := client.AddQueryParam(q, "NearNumber", *params.NearNumber); err != nil {
			return nil, err
		}
	}

	if params.NearLatLong != nil {
		if err := client.AddQueryParam(q, "NearLatLong", *params.NearLatLong); err != nil {
			return nil, err
		}
	}

	if params.Distance != nil {
		if err := client.AddQueryParam(q, "Distance", *params.Distance); err != nil {
			return nil, err
		}
	}

	if params.InPostalCode != nil {
		if err := client.AddQueryParam(q, "InPostalCode", *params.InPostalCode); err != nil {
			return nil, err
		}
	}

	if params.InRegion != nil {
		if err := client.AddQueryParam(q, "InRegion", *params.InRegion); err != nil {
			return nil, err
		}
	}

	if params.InRateCenter != nil {
		if err := client.AddQueryParam(q, "InRateCenter", *params.InRateCenter); err != nil {
			return nil, err
		}
	}

	if params.InLata != nil {
		if err := client.AddQueryParam(q, "InLata", *params.InLata); err != nil {
			return nil, err
		}
	}

	if params.InLocality != nil {
		if err := client.AddQueryParam(q, "InLocality", *params.InLocality); err != nil {
			return nil, err
		}
	}

	if params.FaxEnabled != nil {
		if err := client.AddQueryParam(q, "FaxEnabled", *params.FaxEnabled); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListAvailablePhoneNumberNational returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/National.json
func (c *Client) ListAvailablePhoneNumberNational(ctx context.Context, accountSid string, countryCode string, params *ListAvailablePhoneNumberNationalParams, reqEditors ...client.RequestEditorFn) (*ListAvailablePhoneNumberNationalResponse, error) {
	req, err := newListAvailablePhoneNumberNationalRequest(c.BaseURL, accountSid, countryCode, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListAvailablePhoneNumberNationalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AvailablePhoneNumbers *[]ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberNational `json:"available_phone_numbers,omitempty"`
			End                   *int                                                                      `json:"end,omitempty"`
			FirstPageUri          *string                                                                   `json:"first_page_uri,omitempty"`
			NextPageUri           *string                                                                   `json:"next_page_uri,omitempty"`
			Page                  *int                                                                      `json:"page,omitempty"`
			PageSize              *int                                                                      `json:"page_size,omitempty"`
			PreviousPageUri       *string                                                                   `json:"previous_page_uri,omitempty"`
			Start                 *int                                                                      `json:"start,omitempty"`
			Uri                   *string                                                                   `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListAvailablePhoneNumberSharedCost: GET /2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/SharedCost.json

type ListAvailablePhoneNumberSharedCostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AvailablePhoneNumbers *[]ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberSharedCost `json:"available_phone_numbers,omitempty"`
		End                   *int                                                                        `json:"end,omitempty"`
		FirstPageUri          *string                                                                     `json:"first_page_uri,omitempty"`
		NextPageUri           *string                                                                     `json:"next_page_uri,omitempty"`
		Page                  *int                                                                        `json:"page,omitempty"`
		PageSize              *int                                                                        `json:"page_size,omitempty"`
		PreviousPageUri       *string                                                                     `json:"previous_page_uri,omitempty"`
		Start                 *int                                                                        `json:"start,omitempty"`
		Uri                   *string                                                                     `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAvailablePhoneNumberSharedCostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailablePhoneNumberSharedCostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListAvailablePhoneNumberSharedCostRequest generates requests for ListAvailablePhoneNumberSharedCost
func newListAvailablePhoneNumberSharedCostRequest(baseURL *url.URL, accountSid string, countryCode string, params *ListAvailablePhoneNumberSharedCostParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CountryCode", countryCode)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListAvailablePhoneNumberSharedCostFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.AreaCode != nil {
		if err := client.AddQueryParam(q, "AreaCode", *params.AreaCode); err != nil {
			return nil, err
		}
	}

	if params.Contains != nil {
		if err := client.AddQueryParam(q, "Contains", *params.Contains); err != nil {
			return nil, err
		}
	}

	if params.SmsEnabled != nil {
		if err := client.AddQueryParam(q, "SmsEnabled", *params.SmsEnabled); err != nil {
			return nil, err
		}
	}

	if params.MmsEnabled != nil {
		if err := client.AddQueryParam(q, "MmsEnabled", *params.MmsEnabled); err != nil {
			return nil, err
		}
	}

	if params.VoiceEnabled != nil {
		if err := client.AddQueryParam(q, "VoiceEnabled", *params.VoiceEnabled); err != nil {
			return nil, err
		}
	}

	if params.ExcludeAllAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeAllAddressRequired", *params.ExcludeAllAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.ExcludeLocalAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeLocalAddressRequired", *params.ExcludeLocalAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.ExcludeForeignAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeForeignAddressRequired", *params.ExcludeForeignAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.Beta != nil {
		if err := client.AddQueryParam(q, "Beta", *params.Beta); err != nil {
			return nil, err
		}
	}

	if params.NearNumber != nil {
		if err := client.AddQueryParam(q, "NearNumber", *params.NearNumber); err != nil {
			return nil, err
		}
	}

	if params.NearLatLong != nil {
		if err := client.AddQueryParam(q, "NearLatLong", *params.NearLatLong); err != nil {
			return nil, err
		}
	}

	if params.Distance != nil {
		if err := client.AddQueryParam(q, "Distance", *params.Distance); err != nil {
			return nil, err
		}
	}

	if params.InPostalCode != nil {
		if err := client.AddQueryParam(q, "InPostalCode", *params.InPostalCode); err != nil {
			return nil, err
		}
	}

	if params.InRegion != nil {
		if err := client.AddQueryParam(q, "InRegion", *params.InRegion); err != nil {
			return nil, err
		}
	}

	if params.InRateCenter != nil {
		if err := client.AddQueryParam(q, "InRateCenter", *params.InRateCenter); err != nil {
			return nil, err
		}
	}

	if params.InLata != nil {
		if err := client.AddQueryParam(q, "InLata", *params.InLata); err != nil {
			return nil, err
		}
	}

	if params.InLocality != nil {
		if err := client.AddQueryParam(q, "InLocality", *params.InLocality); err != nil {
			return nil, err
		}
	}

	if params.FaxEnabled != nil {
		if err := client.AddQueryParam(q, "FaxEnabled", *params.FaxEnabled); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListAvailablePhoneNumberSharedCost returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/SharedCost.json
func (c *Client) ListAvailablePhoneNumberSharedCost(ctx context.Context, accountSid string, countryCode string, params *ListAvailablePhoneNumberSharedCostParams, reqEditors ...client.RequestEditorFn) (*ListAvailablePhoneNumberSharedCostResponse, error) {
	req, err := newListAvailablePhoneNumberSharedCostRequest(c.BaseURL, accountSid, countryCode, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListAvailablePhoneNumberSharedCostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AvailablePhoneNumbers *[]ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberSharedCost `json:"available_phone_numbers,omitempty"`
			End                   *int                                                                        `json:"end,omitempty"`
			FirstPageUri          *string                                                                     `json:"first_page_uri,omitempty"`
			NextPageUri           *string                                                                     `json:"next_page_uri,omitempty"`
			Page                  *int                                                                        `json:"page,omitempty"`
			PageSize              *int                                                                        `json:"page_size,omitempty"`
			PreviousPageUri       *string                                                                     `json:"previous_page_uri,omitempty"`
			Start                 *int                                                                        `json:"start,omitempty"`
			Uri                   *string                                                                     `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListAvailablePhoneNumberTollFree: GET /2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/TollFree.json

type ListAvailablePhoneNumberTollFreeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AvailablePhoneNumbers *[]ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberTollFree `json:"available_phone_numbers,omitempty"`
		End                   *int                                                                      `json:"end,omitempty"`
		FirstPageUri          *string                                                                   `json:"first_page_uri,omitempty"`
		NextPageUri           *string                                                                   `json:"next_page_uri,omitempty"`
		Page                  *int                                                                      `json:"page,omitempty"`
		PageSize              *int                                                                      `json:"page_size,omitempty"`
		PreviousPageUri       *string                                                                   `json:"previous_page_uri,omitempty"`
		Start                 *int                                                                      `json:"start,omitempty"`
		Uri                   *string                                                                   `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAvailablePhoneNumberTollFreeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailablePhoneNumberTollFreeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListAvailablePhoneNumberTollFreeRequest generates requests for ListAvailablePhoneNumberTollFree
func newListAvailablePhoneNumberTollFreeRequest(baseURL *url.URL, accountSid string, countryCode string, params *ListAvailablePhoneNumberTollFreeParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CountryCode", countryCode)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListAvailablePhoneNumberTollFreeFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.AreaCode != nil {
		if err := client.AddQueryParam(q, "AreaCode", *params.AreaCode); err != nil {
			return nil, err
		}
	}

	if params.Contains != nil {
		if err := client.AddQueryParam(q, "Contains", *params.Contains); err != nil {
			return nil, err
		}
	}

	if params.SmsEnabled != nil {
		if err := client.AddQueryParam(q, "SmsEnabled", *params.SmsEnabled); err != nil {
			return nil, err
		}
	}

	if params.MmsEnabled != nil {
		if err := client.AddQueryParam(q, "MmsEnabled", *params.MmsEnabled); err != nil {
			return nil, err
		}
	}

	if params.VoiceEnabled != nil {
		if err := client.AddQueryParam(q, "VoiceEnabled", *params.VoiceEnabled); err != nil {
			return nil, err
		}
	}

	if params.ExcludeAllAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeAllAddressRequired", *params.ExcludeAllAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.ExcludeLocalAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeLocalAddressRequired", *params.ExcludeLocalAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.ExcludeForeignAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeForeignAddressRequired", *params.ExcludeForeignAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.Beta != nil {
		if err := client.AddQueryParam(q, "Beta", *params.Beta); err != nil {
			return nil, err
		}
	}

	if params.NearNumber != nil {
		if err := client.AddQueryParam(q, "NearNumber", *params.NearNumber); err != nil {
			return nil, err
		}
	}

	if params.NearLatLong != nil {
		if err := client.AddQueryParam(q, "NearLatLong", *params.NearLatLong); err != nil {
			return nil, err
		}
	}

	if params.Distance != nil {
		if err := client.AddQueryParam(q, "Distance", *params.Distance); err != nil {
			return nil, err
		}
	}

	if params.InPostalCode != nil {
		if err := client.AddQueryParam(q, "InPostalCode", *params.InPostalCode); err != nil {
			return nil, err
		}
	}

	if params.InRegion != nil {
		if err := client.AddQueryParam(q, "InRegion", *params.InRegion); err != nil {
			return nil, err
		}
	}

	if params.InRateCenter != nil {
		if err := client.AddQueryParam(q, "InRateCenter", *params.InRateCenter); err != nil {
			return nil, err
		}
	}

	if params.InLata != nil {
		if err := client.AddQueryParam(q, "InLata", *params.InLata); err != nil {
			return nil, err
		}
	}

	if params.InLocality != nil {
		if err := client.AddQueryParam(q, "InLocality", *params.InLocality); err != nil {
			return nil, err
		}
	}

	if params.FaxEnabled != nil {
		if err := client.AddQueryParam(q, "FaxEnabled", *params.FaxEnabled); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListAvailablePhoneNumberTollFree returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/TollFree.json
func (c *Client) ListAvailablePhoneNumberTollFree(ctx context.Context, accountSid string, countryCode string, params *ListAvailablePhoneNumberTollFreeParams, reqEditors ...client.RequestEditorFn) (*ListAvailablePhoneNumberTollFreeResponse, error) {
	req, err := newListAvailablePhoneNumberTollFreeRequest(c.BaseURL, accountSid, countryCode, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListAvailablePhoneNumberTollFreeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AvailablePhoneNumbers *[]ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberTollFree `json:"available_phone_numbers,omitempty"`
			End                   *int                                                                      `json:"end,omitempty"`
			FirstPageUri          *string                                                                   `json:"first_page_uri,omitempty"`
			NextPageUri           *string                                                                   `json:"next_page_uri,omitempty"`
			Page                  *int                                                                      `json:"page,omitempty"`
			PageSize              *int                                                                      `json:"page_size,omitempty"`
			PreviousPageUri       *string                                                                   `json:"previous_page_uri,omitempty"`
			Start                 *int                                                                      `json:"start,omitempty"`
			Uri                   *string                                                                   `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListAvailablePhoneNumberVoip: GET /2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Voip.json

type ListAvailablePhoneNumberVoipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AvailablePhoneNumbers *[]ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberVoip `json:"available_phone_numbers,omitempty"`
		End                   *int                                                                  `json:"end,omitempty"`
		FirstPageUri          *string                                                               `json:"first_page_uri,omitempty"`
		NextPageUri           *string                                                               `json:"next_page_uri,omitempty"`
		Page                  *int                                                                  `json:"page,omitempty"`
		PageSize              *int                                                                  `json:"page_size,omitempty"`
		PreviousPageUri       *string                                                               `json:"previous_page_uri,omitempty"`
		Start                 *int                                                                  `json:"start,omitempty"`
		Uri                   *string                                                               `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAvailablePhoneNumberVoipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAvailablePhoneNumberVoipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListAvailablePhoneNumberVoipRequest generates requests for ListAvailablePhoneNumberVoip
func newListAvailablePhoneNumberVoipRequest(baseURL *url.URL, accountSid string, countryCode string, params *ListAvailablePhoneNumberVoipParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CountryCode", countryCode)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListAvailablePhoneNumberVoipFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.AreaCode != nil {
		if err := client.AddQueryParam(q, "AreaCode", *params.AreaCode); err != nil {
			return nil, err
		}
	}

	if params.Contains != nil {
		if err := client.AddQueryParam(q, "Contains", *params.Contains); err != nil {
			return nil, err
		}
	}

	if params.SmsEnabled != nil {
		if err := client.AddQueryParam(q, "SmsEnabled", *params.SmsEnabled); err != nil {
			return nil, err
		}
	}

	if params.MmsEnabled != nil {
		if err := client.AddQueryParam(q, "MmsEnabled", *params.MmsEnabled); err != nil {
			return nil, err
		}
	}

	if params.VoiceEnabled != nil {
		if err := client.AddQueryParam(q, "VoiceEnabled", *params.VoiceEnabled); err != nil {
			return nil, err
		}
	}

	if params.ExcludeAllAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeAllAddressRequired", *params.ExcludeAllAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.ExcludeLocalAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeLocalAddressRequired", *params.ExcludeLocalAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.ExcludeForeignAddressRequired != nil {
		if err := client.AddQueryParam(q, "ExcludeForeignAddressRequired", *params.ExcludeForeignAddressRequired); err != nil {
			return nil, err
		}
	}

	if params.Beta != nil {
		if err := client.AddQueryParam(q, "Beta", *params.Beta); err != nil {
			return nil, err
		}
	}

	if params.NearNumber != nil {
		if err := client.AddQueryParam(q, "NearNumber", *params.NearNumber); err != nil {
			return nil, err
		}
	}

	if params.NearLatLong != nil {
		if err := client.AddQueryParam(q, "NearLatLong", *params.NearLatLong); err != nil {
			return nil, err
		}
	}

	if params.Distance != nil {
		if err := client.AddQueryParam(q, "Distance", *params.Distance); err != nil {
			return nil, err
		}
	}

	if params.InPostalCode != nil {
		if err := client.AddQueryParam(q, "InPostalCode", *params.InPostalCode); err != nil {
			return nil, err
		}
	}

	if params.InRegion != nil {
		if err := client.AddQueryParam(q, "InRegion", *params.InRegion); err != nil {
			return nil, err
		}
	}

	if params.InRateCenter != nil {
		if err := client.AddQueryParam(q, "InRateCenter", *params.InRateCenter); err != nil {
			return nil, err
		}
	}

	if params.InLata != nil {
		if err := client.AddQueryParam(q, "InLata", *params.InLata); err != nil {
			return nil, err
		}
	}

	if params.InLocality != nil {
		if err := client.AddQueryParam(q, "InLocality", *params.InLocality); err != nil {
			return nil, err
		}
	}

	if params.FaxEnabled != nil {
		if err := client.AddQueryParam(q, "FaxEnabled", *params.FaxEnabled); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListAvailablePhoneNumberVoip returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/AvailablePhoneNumbers/{CountryCode}/Voip.json
func (c *Client) ListAvailablePhoneNumberVoip(ctx context.Context, accountSid string, countryCode string, params *ListAvailablePhoneNumberVoipParams, reqEditors ...client.RequestEditorFn) (*ListAvailablePhoneNumberVoipResponse, error) {
	req, err := newListAvailablePhoneNumberVoipRequest(c.BaseURL, accountSid, countryCode, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListAvailablePhoneNumberVoipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AvailablePhoneNumbers *[]ApiV2010AccountAvailablePhoneNumberCountryAvailablePhoneNumberVoip `json:"available_phone_numbers,omitempty"`
			End                   *int                                                                  `json:"end,omitempty"`
			FirstPageUri          *string                                                               `json:"first_page_uri,omitempty"`
			NextPageUri           *string                                                               `json:"next_page_uri,omitempty"`
			Page                  *int                                                                  `json:"page,omitempty"`
			PageSize              *int                                                                  `json:"page_size,omitempty"`
			PreviousPageUri       *string                                                               `json:"previous_page_uri,omitempty"`
			Start                 *int                                                                  `json:"start,omitempty"`
			Uri                   *string                                                               `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchBalance: GET /2010-04-01/Accounts/{AccountSid}/Balance.json

type FetchBalanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountBalance
}

// Status returns HTTPResponse.Status
func (r FetchBalanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchBalanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchBalanceRequest generates requests for FetchBalance
func newFetchBalanceRequest(baseURL *url.URL, accountSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchBalanceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchBalance returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Balance.json
func (c *Client) FetchBalance(ctx context.Context, accountSid string, reqEditors ...client.RequestEditorFn) (*FetchBalanceResponse, error) {
	req, err := newFetchBalanceRequest(c.BaseURL, accountSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchBalanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountBalance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListCall: GET /2010-04-01/Accounts/{AccountSid}/Calls.json

type ListCallResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Calls           *[]ApiV2010AccountCall `json:"calls,omitempty"`
		End             *int                   `json:"end,omitempty"`
		FirstPageUri    *string                `json:"first_page_uri,omitempty"`
		NextPageUri     *string                `json:"next_page_uri,omitempty"`
		Page            *int                   `json:"page,omitempty"`
		PageSize        *int                   `json:"page_size,omitempty"`
		PreviousPageUri *string                `json:"previous_page_uri,omitempty"`
		Start           *int                   `json:"start,omitempty"`
		Uri             *string                `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCallResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCallResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListCallRequest generates requests for ListCall
func newListCallRequest(baseURL *url.URL, accountSid string, params *ListCallParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListCallFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.To != nil {
		if err := client.AddQueryParam(q, "To", *params.To); err != nil {
			return nil, err
		}
	}

	if params.From != nil {
		if err := client.AddQueryParam(q, "From", *params.From); err != nil {
			return nil, err
		}
	}

	if params.ParentCallSid != nil {
		if err := client.AddQueryParam(q, "ParentCallSid", *params.ParentCallSid); err != nil {
			return nil, err
		}
	}

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.StartTime != nil {
		if err := client.AddQueryParam(q, "StartTime", *params.StartTime); err != nil {
			return nil, err
		}
	}

	if params.StartTime != nil {
		if err := client.AddQueryParam(q, "StartTime<", *params.StartTime); err != nil {
			return nil, err
		}
	}

	if params.StartTime != nil {
		if err := client.AddQueryParam(q, "StartTime>", *params.StartTime); err != nil {
			return nil, err
		}
	}

	if params.EndTime != nil {
		if err := client.AddQueryParam(q, "EndTime", *params.EndTime); err != nil {
			return nil, err
		}
	}

	if params.EndTime != nil {
		if err := client.AddQueryParam(q, "EndTime<", *params.EndTime); err != nil {
			return nil, err
		}
	}

	if params.EndTime != nil {
		if err := client.AddQueryParam(q, "EndTime>", *params.EndTime); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListCall returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Calls.json
func (c *Client) ListCall(ctx context.Context, accountSid string, params *ListCallParams, reqEditors ...client.RequestEditorFn) (*ListCallResponse, error) {
	req, err := newListCallRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListCallResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Calls           *[]ApiV2010AccountCall `json:"calls,omitempty"`
			End             *int                   `json:"end,omitempty"`
			FirstPageUri    *string                `json:"first_page_uri,omitempty"`
			NextPageUri     *string                `json:"next_page_uri,omitempty"`
			Page            *int                   `json:"page,omitempty"`
			PageSize        *int                   `json:"page_size,omitempty"`
			PreviousPageUri *string                `json:"previous_page_uri,omitempty"`
			Start           *int                   `json:"start,omitempty"`
			Uri             *string                `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateCall: POST /2010-04-01/Accounts/{AccountSid}/Calls.json

type CreateCallResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountCall
}

// Status returns HTTPResponse.Status
func (r CreateCallResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCallResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateCallRequestWithBody generates requests for CreateCall with any type of body
func newCreateCallRequestWithBody(baseURL *url.URL, accountSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateCallFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateCallWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Calls.json
func (c *Client) CreateCallWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCallResponse, error) {
	req, err := newCreateCallRequestWithBody(c.BaseURL, accountSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateCallResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountCall
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// CreateCallFeedbackSummary: POST /2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary.json

type CreateCallFeedbackSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountCallCallFeedbackSummary
}

// Status returns HTTPResponse.Status
func (r CreateCallFeedbackSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCallFeedbackSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateCallFeedbackSummaryRequestWithBody generates requests for CreateCallFeedbackSummary with any type of body
func newCreateCallFeedbackSummaryRequestWithBody(baseURL *url.URL, accountSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateCallFeedbackSummaryFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateCallFeedbackSummaryWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary.json
func (c *Client) CreateCallFeedbackSummaryWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCallFeedbackSummaryResponse, error) {
	req, err := newCreateCallFeedbackSummaryRequestWithBody(c.BaseURL, accountSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateCallFeedbackSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountCallCallFeedbackSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteCallFeedbackSummary: DELETE /2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary/{Sid}.json

type DeleteCallFeedbackSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCallFeedbackSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCallFeedbackSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteCallFeedbackSummaryRequest generates requests for DeleteCallFeedbackSummary
func newDeleteCallFeedbackSummaryRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteCallFeedbackSummaryFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteCallFeedbackSummary returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary/{Sid}.json
func (c *Client) DeleteCallFeedbackSummary(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCallFeedbackSummaryResponse, error) {
	req, err := newDeleteCallFeedbackSummaryRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteCallFeedbackSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchCallFeedbackSummary: GET /2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary/{Sid}.json

type FetchCallFeedbackSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountCallCallFeedbackSummary
}

// Status returns HTTPResponse.Status
func (r FetchCallFeedbackSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchCallFeedbackSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchCallFeedbackSummaryRequest generates requests for FetchCallFeedbackSummary
func newFetchCallFeedbackSummaryRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchCallFeedbackSummaryFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchCallFeedbackSummary returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Calls/FeedbackSummary/{Sid}.json
func (c *Client) FetchCallFeedbackSummary(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchCallFeedbackSummaryResponse, error) {
	req, err := newFetchCallFeedbackSummaryRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchCallFeedbackSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountCallCallFeedbackSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListCallEvent: GET /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Events.json

type ListCallEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                            `json:"end,omitempty"`
		Events          *[]ApiV2010AccountCallCallEvent `json:"events,omitempty"`
		FirstPageUri    *string                         `json:"first_page_uri,omitempty"`
		NextPageUri     *string                         `json:"next_page_uri,omitempty"`
		Page            *int                            `json:"page,omitempty"`
		PageSize        *int                            `json:"page_size,omitempty"`
		PreviousPageUri *string                         `json:"previous_page_uri,omitempty"`
		Start           *int                            `json:"start,omitempty"`
		Uri             *string                         `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCallEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCallEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListCallEventRequest generates requests for ListCallEvent
func newListCallEventRequest(baseURL *url.URL, accountSid string, callSid string, params *ListCallEventParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListCallEventFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListCallEvent returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Events.json
func (c *Client) ListCallEvent(ctx context.Context, accountSid string, callSid string, params *ListCallEventParams, reqEditors ...client.RequestEditorFn) (*ListCallEventResponse, error) {
	req, err := newListCallEventRequest(c.BaseURL, accountSid, callSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListCallEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                            `json:"end,omitempty"`
			Events          *[]ApiV2010AccountCallCallEvent `json:"events,omitempty"`
			FirstPageUri    *string                         `json:"first_page_uri,omitempty"`
			NextPageUri     *string                         `json:"next_page_uri,omitempty"`
			Page            *int                            `json:"page,omitempty"`
			PageSize        *int                            `json:"page_size,omitempty"`
			PreviousPageUri *string                         `json:"previous_page_uri,omitempty"`
			Start           *int                            `json:"start,omitempty"`
			Uri             *string                         `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchCallFeedback: GET /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Feedback.json

type FetchCallFeedbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountCallCallFeedback
}

// Status returns HTTPResponse.Status
func (r FetchCallFeedbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchCallFeedbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchCallFeedbackRequest generates requests for FetchCallFeedback
func newFetchCallFeedbackRequest(baseURL *url.URL, accountSid string, callSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchCallFeedbackFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchCallFeedback returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Feedback.json
func (c *Client) FetchCallFeedback(ctx context.Context, accountSid string, callSid string, reqEditors ...client.RequestEditorFn) (*FetchCallFeedbackResponse, error) {
	req, err := newFetchCallFeedbackRequest(c.BaseURL, accountSid, callSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchCallFeedbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountCallCallFeedback
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateCallFeedback: POST /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Feedback.json

type UpdateCallFeedbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountCallCallFeedback
}

// Status returns HTTPResponse.Status
func (r UpdateCallFeedbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCallFeedbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateCallFeedbackRequestWithBody generates requests for UpdateCallFeedback with any type of body
func newUpdateCallFeedbackRequestWithBody(baseURL *url.URL, accountSid string, callSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateCallFeedbackFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateCallFeedbackWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Feedback.json
func (c *Client) UpdateCallFeedbackWithBody(ctx context.Context, accountSid string, callSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateCallFeedbackResponse, error) {
	req, err := newUpdateCallFeedbackRequestWithBody(c.BaseURL, accountSid, callSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateCallFeedbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountCallCallFeedback
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListCallNotification: GET /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Notifications.json

type ListCallNotificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                                   `json:"end,omitempty"`
		FirstPageUri    *string                                `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                `json:"next_page_uri,omitempty"`
		Notifications   *[]ApiV2010AccountCallCallNotification `json:"notifications,omitempty"`
		Page            *int                                   `json:"page,omitempty"`
		PageSize        *int                                   `json:"page_size,omitempty"`
		PreviousPageUri *string                                `json:"previous_page_uri,omitempty"`
		Start           *int                                   `json:"start,omitempty"`
		Uri             *string                                `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCallNotificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCallNotificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListCallNotificationRequest generates requests for ListCallNotification
func newListCallNotificationRequest(baseURL *url.URL, accountSid string, callSid string, params *ListCallNotificationParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListCallNotificationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Log != nil {
		if err := client.AddQueryParam(q, "Log", *params.Log); err != nil {
			return nil, err
		}
	}

	if params.MessageDate != nil {
		if err := client.AddQueryParam(q, "MessageDate", *params.MessageDate); err != nil {
			return nil, err
		}
	}

	if params.MessageDate != nil {
		if err := client.AddQueryParam(q, "MessageDate<", *params.MessageDate); err != nil {
			return nil, err
		}
	}

	if params.MessageDate != nil {
		if err := client.AddQueryParam(q, "MessageDate>", *params.MessageDate); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListCallNotification returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Notifications.json
func (c *Client) ListCallNotification(ctx context.Context, accountSid string, callSid string, params *ListCallNotificationParams, reqEditors ...client.RequestEditorFn) (*ListCallNotificationResponse, error) {
	req, err := newListCallNotificationRequest(c.BaseURL, accountSid, callSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListCallNotificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                                   `json:"end,omitempty"`
			FirstPageUri    *string                                `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                `json:"next_page_uri,omitempty"`
			Notifications   *[]ApiV2010AccountCallCallNotification `json:"notifications,omitempty"`
			Page            *int                                   `json:"page,omitempty"`
			PageSize        *int                                   `json:"page_size,omitempty"`
			PreviousPageUri *string                                `json:"previous_page_uri,omitempty"`
			Start           *int                                   `json:"start,omitempty"`
			Uri             *string                                `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchCallNotification: GET /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Notifications/{Sid}.json

type FetchCallNotificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountCallCallNotificationInstance
}

// Status returns HTTPResponse.Status
func (r FetchCallNotificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchCallNotificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchCallNotificationRequest generates requests for FetchCallNotification
func newFetchCallNotificationRequest(baseURL *url.URL, accountSid string, callSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchCallNotificationFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchCallNotification returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Notifications/{Sid}.json
func (c *Client) FetchCallNotification(ctx context.Context, accountSid string, callSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchCallNotificationResponse, error) {
	req, err := newFetchCallNotificationRequest(c.BaseURL, accountSid, callSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchCallNotificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountCallCallNotificationInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreatePayments: POST /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Payments.json

type CreatePaymentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountCallPayments
}

// Status returns HTTPResponse.Status
func (r CreatePaymentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePaymentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreatePaymentsRequestWithBody generates requests for CreatePayments with any type of body
func newCreatePaymentsRequestWithBody(baseURL *url.URL, accountSid string, callSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreatePaymentsFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreatePaymentsWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Payments.json
func (c *Client) CreatePaymentsWithBody(ctx context.Context, accountSid string, callSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreatePaymentsResponse, error) {
	req, err := newCreatePaymentsRequestWithBody(c.BaseURL, accountSid, callSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreatePaymentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountCallPayments
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// UpdatePayments: POST /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Payments/{Sid}.json

type UpdatePaymentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *ApiV2010AccountCallPayments
}

// Status returns HTTPResponse.Status
func (r UpdatePaymentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePaymentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdatePaymentsRequestWithBody generates requests for UpdatePayments with any type of body
func newUpdatePaymentsRequestWithBody(baseURL *url.URL, accountSid string, callSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdatePaymentsFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdatePaymentsWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Payments/{Sid}.json
func (c *Client) UpdatePaymentsWithBody(ctx context.Context, accountSid string, callSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdatePaymentsResponse, error) {
	req, err := newUpdatePaymentsRequestWithBody(c.BaseURL, accountSid, callSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdatePaymentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ApiV2010AccountCallPayments
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest
	}

	return response, nil
}

// ListCallRecording: GET /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings.json

type ListCallRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                                `json:"end,omitempty"`
		FirstPageUri    *string                             `json:"first_page_uri,omitempty"`
		NextPageUri     *string                             `json:"next_page_uri,omitempty"`
		Page            *int                                `json:"page,omitempty"`
		PageSize        *int                                `json:"page_size,omitempty"`
		PreviousPageUri *string                             `json:"previous_page_uri,omitempty"`
		Recordings      *[]ApiV2010AccountCallCallRecording `json:"recordings,omitempty"`
		Start           *int                                `json:"start,omitempty"`
		Uri             *string                             `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCallRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCallRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListCallRecordingRequest generates requests for ListCallRecording
func newListCallRecordingRequest(baseURL *url.URL, accountSid string, callSid string, params *ListCallRecordingParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListCallRecordingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.DateCreated != nil {
		if err := client.AddQueryParam(q, "DateCreated", *params.DateCreated); err != nil {
			return nil, err
		}
	}

	if params.DateCreated != nil {
		if err := client.AddQueryParam(q, "DateCreated<", *params.DateCreated); err != nil {
			return nil, err
		}
	}

	if params.DateCreated != nil {
		if err := client.AddQueryParam(q, "DateCreated>", *params.DateCreated); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListCallRecording returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings.json
func (c *Client) ListCallRecording(ctx context.Context, accountSid string, callSid string, params *ListCallRecordingParams, reqEditors ...client.RequestEditorFn) (*ListCallRecordingResponse, error) {
	req, err := newListCallRecordingRequest(c.BaseURL, accountSid, callSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListCallRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                                `json:"end,omitempty"`
			FirstPageUri    *string                             `json:"first_page_uri,omitempty"`
			NextPageUri     *string                             `json:"next_page_uri,omitempty"`
			Page            *int                                `json:"page,omitempty"`
			PageSize        *int                                `json:"page_size,omitempty"`
			PreviousPageUri *string                             `json:"previous_page_uri,omitempty"`
			Recordings      *[]ApiV2010AccountCallCallRecording `json:"recordings,omitempty"`
			Start           *int                                `json:"start,omitempty"`
			Uri             *string                             `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateCallRecording: POST /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings.json

type CreateCallRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountCallCallRecording
}

// Status returns HTTPResponse.Status
func (r CreateCallRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCallRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateCallRecordingRequestWithBody generates requests for CreateCallRecording with any type of body
func newCreateCallRecordingRequestWithBody(baseURL *url.URL, accountSid string, callSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateCallRecordingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateCallRecordingWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings.json
func (c *Client) CreateCallRecordingWithBody(ctx context.Context, accountSid string, callSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCallRecordingResponse, error) {
	req, err := newCreateCallRecordingRequestWithBody(c.BaseURL, accountSid, callSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateCallRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountCallCallRecording
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteCallRecording: DELETE /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings/{Sid}.json

type DeleteCallRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCallRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCallRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteCallRecordingRequest generates requests for DeleteCallRecording
func newDeleteCallRecordingRequest(baseURL *url.URL, accountSid string, callSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteCallRecordingFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteCallRecording returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings/{Sid}.json
func (c *Client) DeleteCallRecording(ctx context.Context, accountSid string, callSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCallRecordingResponse, error) {
	req, err := newDeleteCallRecordingRequest(c.BaseURL, accountSid, callSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteCallRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchCallRecording: GET /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings/{Sid}.json

type FetchCallRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountCallCallRecording
}

// Status returns HTTPResponse.Status
func (r FetchCallRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchCallRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchCallRecordingRequest generates requests for FetchCallRecording
func newFetchCallRecordingRequest(baseURL *url.URL, accountSid string, callSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchCallRecordingFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchCallRecording returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings/{Sid}.json
func (c *Client) FetchCallRecording(ctx context.Context, accountSid string, callSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchCallRecordingResponse, error) {
	req, err := newFetchCallRecordingRequest(c.BaseURL, accountSid, callSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchCallRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountCallCallRecording
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateCallRecording: POST /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings/{Sid}.json

type UpdateCallRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountCallCallRecording
}

// Status returns HTTPResponse.Status
func (r UpdateCallRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCallRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateCallRecordingRequestWithBody generates requests for UpdateCallRecording with any type of body
func newUpdateCallRecordingRequestWithBody(baseURL *url.URL, accountSid string, callSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateCallRecordingFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateCallRecordingWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Recordings/{Sid}.json
func (c *Client) UpdateCallRecordingWithBody(ctx context.Context, accountSid string, callSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateCallRecordingResponse, error) {
	req, err := newUpdateCallRecordingRequestWithBody(c.BaseURL, accountSid, callSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateCallRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountCallCallRecording
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSiprec: POST /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Siprec.json

type CreateSiprecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountCallSiprec
}

// Status returns HTTPResponse.Status
func (r CreateSiprecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSiprecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSiprecRequestWithBody generates requests for CreateSiprec with any type of body
func newCreateSiprecRequestWithBody(baseURL *url.URL, accountSid string, callSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSiprecFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSiprecWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Siprec.json
func (c *Client) CreateSiprecWithBody(ctx context.Context, accountSid string, callSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSiprecResponse, error) {
	req, err := newCreateSiprecRequestWithBody(c.BaseURL, accountSid, callSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSiprecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountCallSiprec
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// UpdateSiprec: POST /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Siprec/{Sid}.json

type UpdateSiprecResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountCallSiprec
}

// Status returns HTTPResponse.Status
func (r UpdateSiprecResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSiprecResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSiprecRequestWithBody generates requests for UpdateSiprec with any type of body
func newUpdateSiprecRequestWithBody(baseURL *url.URL, accountSid string, callSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSiprecFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSiprecWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Siprec/{Sid}.json
func (c *Client) UpdateSiprecWithBody(ctx context.Context, accountSid string, callSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSiprecResponse, error) {
	req, err := newUpdateSiprecRequestWithBody(c.BaseURL, accountSid, callSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSiprecResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountCallSiprec
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateStream: POST /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Streams.json

type CreateStreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountCallStream
}

// Status returns HTTPResponse.Status
func (r CreateStreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateStreamRequestWithBody generates requests for CreateStream with any type of body
func newCreateStreamRequestWithBody(baseURL *url.URL, accountSid string, callSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateStreamFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateStreamWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Streams.json
func (c *Client) CreateStreamWithBody(ctx context.Context, accountSid string, callSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateStreamResponse, error) {
	req, err := newCreateStreamRequestWithBody(c.BaseURL, accountSid, callSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateStreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountCallStream
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// UpdateStream: POST /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Streams/{Sid}.json

type UpdateStreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountCallStream
}

// Status returns HTTPResponse.Status
func (r UpdateStreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateStreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateStreamRequestWithBody generates requests for UpdateStream with any type of body
func newUpdateStreamRequestWithBody(baseURL *url.URL, accountSid string, callSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateStreamFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateStreamWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Calls/{CallSid}/Streams/{Sid}.json
func (c *Client) UpdateStreamWithBody(ctx context.Context, accountSid string, callSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateStreamResponse, error) {
	req, err := newUpdateStreamRequestWithBody(c.BaseURL, accountSid, callSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateStreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountCallStream
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteCall: DELETE /2010-04-01/Accounts/{AccountSid}/Calls/{Sid}.json

type DeleteCallResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCallResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCallResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteCallRequest generates requests for DeleteCall
func newDeleteCallRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteCallFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteCall returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/Calls/{Sid}.json
func (c *Client) DeleteCall(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCallResponse, error) {
	req, err := newDeleteCallRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteCallResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchCall: GET /2010-04-01/Accounts/{AccountSid}/Calls/{Sid}.json

type FetchCallResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountCall
}

// Status returns HTTPResponse.Status
func (r FetchCallResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchCallResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchCallRequest generates requests for FetchCall
func newFetchCallRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchCallFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchCall returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Calls/{Sid}.json
func (c *Client) FetchCall(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchCallResponse, error) {
	req, err := newFetchCallRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchCallResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountCall
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateCall: POST /2010-04-01/Accounts/{AccountSid}/Calls/{Sid}.json

type UpdateCallResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountCall
}

// Status returns HTTPResponse.Status
func (r UpdateCallResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCallResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateCallRequestWithBody generates requests for UpdateCall with any type of body
func newUpdateCallRequestWithBody(baseURL *url.URL, accountSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateCallFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateCallWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Calls/{Sid}.json
func (c *Client) UpdateCallWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateCallResponse, error) {
	req, err := newUpdateCallRequestWithBody(c.BaseURL, accountSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateCallResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountCall
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListConference: GET /2010-04-01/Accounts/{AccountSid}/Conferences.json

type ListConferenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Conferences     *[]ApiV2010AccountConference `json:"conferences,omitempty"`
		End             *int                         `json:"end,omitempty"`
		FirstPageUri    *string                      `json:"first_page_uri,omitempty"`
		NextPageUri     *string                      `json:"next_page_uri,omitempty"`
		Page            *int                         `json:"page,omitempty"`
		PageSize        *int                         `json:"page_size,omitempty"`
		PreviousPageUri *string                      `json:"previous_page_uri,omitempty"`
		Start           *int                         `json:"start,omitempty"`
		Uri             *string                      `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListConferenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConferenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListConferenceRequest generates requests for ListConference
func newListConferenceRequest(baseURL *url.URL, accountSid string, params *ListConferenceParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListConferenceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.DateCreated != nil {
		if err := client.AddQueryParam(q, "DateCreated", *params.DateCreated); err != nil {
			return nil, err
		}
	}

	if params.DateCreated != nil {
		if err := client.AddQueryParam(q, "DateCreated<", *params.DateCreated); err != nil {
			return nil, err
		}
	}

	if params.DateCreated != nil {
		if err := client.AddQueryParam(q, "DateCreated>", *params.DateCreated); err != nil {
			return nil, err
		}
	}

	if params.DateUpdated != nil {
		if err := client.AddQueryParam(q, "DateUpdated", *params.DateUpdated); err != nil {
			return nil, err
		}
	}

	if params.DateUpdated != nil {
		if err := client.AddQueryParam(q, "DateUpdated<", *params.DateUpdated); err != nil {
			return nil, err
		}
	}

	if params.DateUpdated != nil {
		if err := client.AddQueryParam(q, "DateUpdated>", *params.DateUpdated); err != nil {
			return nil, err
		}
	}

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.Status != nil {
		if err := client.AddQueryParam(q, "Status", *params.Status); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListConference returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Conferences.json
func (c *Client) ListConference(ctx context.Context, accountSid string, params *ListConferenceParams, reqEditors ...client.RequestEditorFn) (*ListConferenceResponse, error) {
	req, err := newListConferenceRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListConferenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Conferences     *[]ApiV2010AccountConference `json:"conferences,omitempty"`
			End             *int                         `json:"end,omitempty"`
			FirstPageUri    *string                      `json:"first_page_uri,omitempty"`
			NextPageUri     *string                      `json:"next_page_uri,omitempty"`
			Page            *int                         `json:"page,omitempty"`
			PageSize        *int                         `json:"page_size,omitempty"`
			PreviousPageUri *string                      `json:"previous_page_uri,omitempty"`
			Start           *int                         `json:"start,omitempty"`
			Uri             *string                      `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListParticipant: GET /2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants.json

type ListParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                                    `json:"end,omitempty"`
		FirstPageUri    *string                                 `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                 `json:"next_page_uri,omitempty"`
		Page            *int                                    `json:"page,omitempty"`
		PageSize        *int                                    `json:"page_size,omitempty"`
		Participants    *[]ApiV2010AccountConferenceParticipant `json:"participants,omitempty"`
		PreviousPageUri *string                                 `json:"previous_page_uri,omitempty"`
		Start           *int                                    `json:"start,omitempty"`
		Uri             *string                                 `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListParticipantRequest generates requests for ListParticipant
func newListParticipantRequest(baseURL *url.URL, accountSid string, conferenceSid string, params *ListParticipantParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConferenceSid", conferenceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListParticipantFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Muted != nil {
		if err := client.AddQueryParam(q, "Muted", *params.Muted); err != nil {
			return nil, err
		}
	}

	if params.Hold != nil {
		if err := client.AddQueryParam(q, "Hold", *params.Hold); err != nil {
			return nil, err
		}
	}

	if params.Coaching != nil {
		if err := client.AddQueryParam(q, "Coaching", *params.Coaching); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListParticipant returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants.json
func (c *Client) ListParticipant(ctx context.Context, accountSid string, conferenceSid string, params *ListParticipantParams, reqEditors ...client.RequestEditorFn) (*ListParticipantResponse, error) {
	req, err := newListParticipantRequest(c.BaseURL, accountSid, conferenceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                                    `json:"end,omitempty"`
			FirstPageUri    *string                                 `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                 `json:"next_page_uri,omitempty"`
			Page            *int                                    `json:"page,omitempty"`
			PageSize        *int                                    `json:"page_size,omitempty"`
			Participants    *[]ApiV2010AccountConferenceParticipant `json:"participants,omitempty"`
			PreviousPageUri *string                                 `json:"previous_page_uri,omitempty"`
			Start           *int                                    `json:"start,omitempty"`
			Uri             *string                                 `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateParticipant: POST /2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants.json

type CreateParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountConferenceParticipant
}

// Status returns HTTPResponse.Status
func (r CreateParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateParticipantRequestWithBody generates requests for CreateParticipant with any type of body
func newCreateParticipantRequestWithBody(baseURL *url.URL, accountSid string, conferenceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConferenceSid", conferenceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateParticipantFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateParticipantWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants.json
func (c *Client) CreateParticipantWithBody(ctx context.Context, accountSid string, conferenceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateParticipantResponse, error) {
	req, err := newCreateParticipantRequestWithBody(c.BaseURL, accountSid, conferenceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountConferenceParticipant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteParticipant: DELETE /2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json

type DeleteParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteParticipantRequest generates requests for DeleteParticipant
func newDeleteParticipantRequest(baseURL *url.URL, accountSid string, conferenceSid string, callSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConferenceSid", conferenceSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteParticipantFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteParticipant returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json
func (c *Client) DeleteParticipant(ctx context.Context, accountSid string, conferenceSid string, callSid string, reqEditors ...client.RequestEditorFn) (*DeleteParticipantResponse, error) {
	req, err := newDeleteParticipantRequest(c.BaseURL, accountSid, conferenceSid, callSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchParticipant: GET /2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json

type FetchParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountConferenceParticipant
}

// Status returns HTTPResponse.Status
func (r FetchParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchParticipantRequest generates requests for FetchParticipant
func newFetchParticipantRequest(baseURL *url.URL, accountSid string, conferenceSid string, callSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConferenceSid", conferenceSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchParticipantFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchParticipant returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json
func (c *Client) FetchParticipant(ctx context.Context, accountSid string, conferenceSid string, callSid string, reqEditors ...client.RequestEditorFn) (*FetchParticipantResponse, error) {
	req, err := newFetchParticipantRequest(c.BaseURL, accountSid, conferenceSid, callSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountConferenceParticipant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateParticipant: POST /2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json

type UpdateParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountConferenceParticipant
}

// Status returns HTTPResponse.Status
func (r UpdateParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateParticipantRequestWithBody generates requests for UpdateParticipant with any type of body
func newUpdateParticipantRequestWithBody(baseURL *url.URL, accountSid string, conferenceSid string, callSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConferenceSid", conferenceSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateParticipantFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateParticipantWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Participants/{CallSid}.json
func (c *Client) UpdateParticipantWithBody(ctx context.Context, accountSid string, conferenceSid string, callSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateParticipantResponse, error) {
	req, err := newUpdateParticipantRequestWithBody(c.BaseURL, accountSid, conferenceSid, callSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountConferenceParticipant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListConferenceRecording: GET /2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings.json

type ListConferenceRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                                            `json:"end,omitempty"`
		FirstPageUri    *string                                         `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                         `json:"next_page_uri,omitempty"`
		Page            *int                                            `json:"page,omitempty"`
		PageSize        *int                                            `json:"page_size,omitempty"`
		PreviousPageUri *string                                         `json:"previous_page_uri,omitempty"`
		Recordings      *[]ApiV2010AccountConferenceConferenceRecording `json:"recordings,omitempty"`
		Start           *int                                            `json:"start,omitempty"`
		Uri             *string                                         `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListConferenceRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConferenceRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListConferenceRecordingRequest generates requests for ListConferenceRecording
func newListConferenceRecordingRequest(baseURL *url.URL, accountSid string, conferenceSid string, params *ListConferenceRecordingParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConferenceSid", conferenceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListConferenceRecordingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.DateCreated != nil {
		if err := client.AddQueryParam(q, "DateCreated", *params.DateCreated); err != nil {
			return nil, err
		}
	}

	if params.DateCreated != nil {
		if err := client.AddQueryParam(q, "DateCreated<", *params.DateCreated); err != nil {
			return nil, err
		}
	}

	if params.DateCreated != nil {
		if err := client.AddQueryParam(q, "DateCreated>", *params.DateCreated); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListConferenceRecording returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings.json
func (c *Client) ListConferenceRecording(ctx context.Context, accountSid string, conferenceSid string, params *ListConferenceRecordingParams, reqEditors ...client.RequestEditorFn) (*ListConferenceRecordingResponse, error) {
	req, err := newListConferenceRecordingRequest(c.BaseURL, accountSid, conferenceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListConferenceRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                                            `json:"end,omitempty"`
			FirstPageUri    *string                                         `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                         `json:"next_page_uri,omitempty"`
			Page            *int                                            `json:"page,omitempty"`
			PageSize        *int                                            `json:"page_size,omitempty"`
			PreviousPageUri *string                                         `json:"previous_page_uri,omitempty"`
			Recordings      *[]ApiV2010AccountConferenceConferenceRecording `json:"recordings,omitempty"`
			Start           *int                                            `json:"start,omitempty"`
			Uri             *string                                         `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteConferenceRecording: DELETE /2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings/{Sid}.json

type DeleteConferenceRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteConferenceRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConferenceRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteConferenceRecordingRequest generates requests for DeleteConferenceRecording
func newDeleteConferenceRecordingRequest(baseURL *url.URL, accountSid string, conferenceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConferenceSid", conferenceSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteConferenceRecordingFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteConferenceRecording returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings/{Sid}.json
func (c *Client) DeleteConferenceRecording(ctx context.Context, accountSid string, conferenceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteConferenceRecordingResponse, error) {
	req, err := newDeleteConferenceRecordingRequest(c.BaseURL, accountSid, conferenceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteConferenceRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchConferenceRecording: GET /2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings/{Sid}.json

type FetchConferenceRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountConferenceConferenceRecording
}

// Status returns HTTPResponse.Status
func (r FetchConferenceRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchConferenceRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchConferenceRecordingRequest generates requests for FetchConferenceRecording
func newFetchConferenceRecordingRequest(baseURL *url.URL, accountSid string, conferenceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConferenceSid", conferenceSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchConferenceRecordingFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchConferenceRecording returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings/{Sid}.json
func (c *Client) FetchConferenceRecording(ctx context.Context, accountSid string, conferenceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchConferenceRecordingResponse, error) {
	req, err := newFetchConferenceRecordingRequest(c.BaseURL, accountSid, conferenceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchConferenceRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountConferenceConferenceRecording
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateConferenceRecording: POST /2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings/{Sid}.json

type UpdateConferenceRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountConferenceConferenceRecording
}

// Status returns HTTPResponse.Status
func (r UpdateConferenceRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConferenceRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateConferenceRecordingRequestWithBody generates requests for UpdateConferenceRecording with any type of body
func newUpdateConferenceRecordingRequestWithBody(baseURL *url.URL, accountSid string, conferenceSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ConferenceSid", conferenceSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateConferenceRecordingFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateConferenceRecordingWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Conferences/{ConferenceSid}/Recordings/{Sid}.json
func (c *Client) UpdateConferenceRecordingWithBody(ctx context.Context, accountSid string, conferenceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConferenceRecordingResponse, error) {
	req, err := newUpdateConferenceRecordingRequestWithBody(c.BaseURL, accountSid, conferenceSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateConferenceRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountConferenceConferenceRecording
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchConference: GET /2010-04-01/Accounts/{AccountSid}/Conferences/{Sid}.json

type FetchConferenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountConference
}

// Status returns HTTPResponse.Status
func (r FetchConferenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchConferenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchConferenceRequest generates requests for FetchConference
func newFetchConferenceRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchConferenceFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchConference returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Conferences/{Sid}.json
func (c *Client) FetchConference(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchConferenceResponse, error) {
	req, err := newFetchConferenceRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchConferenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountConference
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateConference: POST /2010-04-01/Accounts/{AccountSid}/Conferences/{Sid}.json

type UpdateConferenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountConference
}

// Status returns HTTPResponse.Status
func (r UpdateConferenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConferenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateConferenceRequestWithBody generates requests for UpdateConference with any type of body
func newUpdateConferenceRequestWithBody(baseURL *url.URL, accountSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateConferenceFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateConferenceWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Conferences/{Sid}.json
func (c *Client) UpdateConferenceWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConferenceResponse, error) {
	req, err := newUpdateConferenceRequestWithBody(c.BaseURL, accountSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateConferenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountConference
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListConnectApp: GET /2010-04-01/Accounts/{AccountSid}/ConnectApps.json

type ListConnectAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ConnectApps     *[]ApiV2010AccountConnectApp `json:"connect_apps,omitempty"`
		End             *int                         `json:"end,omitempty"`
		FirstPageUri    *string                      `json:"first_page_uri,omitempty"`
		NextPageUri     *string                      `json:"next_page_uri,omitempty"`
		Page            *int                         `json:"page,omitempty"`
		PageSize        *int                         `json:"page_size,omitempty"`
		PreviousPageUri *string                      `json:"previous_page_uri,omitempty"`
		Start           *int                         `json:"start,omitempty"`
		Uri             *string                      `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListConnectAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListConnectAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListConnectAppRequest generates requests for ListConnectApp
func newListConnectAppRequest(baseURL *url.URL, accountSid string, params *ListConnectAppParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListConnectAppFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListConnectApp returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/ConnectApps.json
func (c *Client) ListConnectApp(ctx context.Context, accountSid string, params *ListConnectAppParams, reqEditors ...client.RequestEditorFn) (*ListConnectAppResponse, error) {
	req, err := newListConnectAppRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListConnectAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ConnectApps     *[]ApiV2010AccountConnectApp `json:"connect_apps,omitempty"`
			End             *int                         `json:"end,omitempty"`
			FirstPageUri    *string                      `json:"first_page_uri,omitempty"`
			NextPageUri     *string                      `json:"next_page_uri,omitempty"`
			Page            *int                         `json:"page,omitempty"`
			PageSize        *int                         `json:"page_size,omitempty"`
			PreviousPageUri *string                      `json:"previous_page_uri,omitempty"`
			Start           *int                         `json:"start,omitempty"`
			Uri             *string                      `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteConnectApp: DELETE /2010-04-01/Accounts/{AccountSid}/ConnectApps/{Sid}.json

type DeleteConnectAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteConnectAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConnectAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteConnectAppRequest generates requests for DeleteConnectApp
func newDeleteConnectAppRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteConnectAppFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteConnectApp returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/ConnectApps/{Sid}.json
func (c *Client) DeleteConnectApp(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteConnectAppResponse, error) {
	req, err := newDeleteConnectAppRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteConnectAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchConnectApp: GET /2010-04-01/Accounts/{AccountSid}/ConnectApps/{Sid}.json

type FetchConnectAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountConnectApp
}

// Status returns HTTPResponse.Status
func (r FetchConnectAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchConnectAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchConnectAppRequest generates requests for FetchConnectApp
func newFetchConnectAppRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchConnectAppFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchConnectApp returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/ConnectApps/{Sid}.json
func (c *Client) FetchConnectApp(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchConnectAppResponse, error) {
	req, err := newFetchConnectAppRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchConnectAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountConnectApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateConnectApp: POST /2010-04-01/Accounts/{AccountSid}/ConnectApps/{Sid}.json

type UpdateConnectAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountConnectApp
}

// Status returns HTTPResponse.Status
func (r UpdateConnectAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConnectAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateConnectAppRequestWithBody generates requests for UpdateConnectApp with any type of body
func newUpdateConnectAppRequestWithBody(baseURL *url.URL, accountSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateConnectAppFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateConnectAppWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/ConnectApps/{Sid}.json
func (c *Client) UpdateConnectAppWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateConnectAppResponse, error) {
	req, err := newUpdateConnectAppRequestWithBody(c.BaseURL, accountSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateConnectAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountConnectApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListIncomingPhoneNumber: GET /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers.json

type ListIncomingPhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End                  *int                                  `json:"end,omitempty"`
		FirstPageUri         *string                               `json:"first_page_uri,omitempty"`
		IncomingPhoneNumbers *[]ApiV2010AccountIncomingPhoneNumber `json:"incoming_phone_numbers,omitempty"`
		NextPageUri          *string                               `json:"next_page_uri,omitempty"`
		Page                 *int                                  `json:"page,omitempty"`
		PageSize             *int                                  `json:"page_size,omitempty"`
		PreviousPageUri      *string                               `json:"previous_page_uri,omitempty"`
		Start                *int                                  `json:"start,omitempty"`
		Uri                  *string                               `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListIncomingPhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIncomingPhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListIncomingPhoneNumberRequest generates requests for ListIncomingPhoneNumber
func newListIncomingPhoneNumberRequest(baseURL *url.URL, accountSid string, params *ListIncomingPhoneNumberParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListIncomingPhoneNumberFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Beta != nil {
		if err := client.AddQueryParam(q, "Beta", *params.Beta); err != nil {
			return nil, err
		}
	}

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.PhoneNumber != nil {
		if err := client.AddQueryParam(q, "PhoneNumber", *params.PhoneNumber); err != nil {
			return nil, err
		}
	}

	if params.Origin != nil {
		if err := client.AddQueryParam(q, "Origin", *params.Origin); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListIncomingPhoneNumber returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers.json
func (c *Client) ListIncomingPhoneNumber(ctx context.Context, accountSid string, params *ListIncomingPhoneNumberParams, reqEditors ...client.RequestEditorFn) (*ListIncomingPhoneNumberResponse, error) {
	req, err := newListIncomingPhoneNumberRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListIncomingPhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End                  *int                                  `json:"end,omitempty"`
			FirstPageUri         *string                               `json:"first_page_uri,omitempty"`
			IncomingPhoneNumbers *[]ApiV2010AccountIncomingPhoneNumber `json:"incoming_phone_numbers,omitempty"`
			NextPageUri          *string                               `json:"next_page_uri,omitempty"`
			Page                 *int                                  `json:"page,omitempty"`
			PageSize             *int                                  `json:"page_size,omitempty"`
			PreviousPageUri      *string                               `json:"previous_page_uri,omitempty"`
			Start                *int                                  `json:"start,omitempty"`
			Uri                  *string                               `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateIncomingPhoneNumber: POST /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers.json

type CreateIncomingPhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountIncomingPhoneNumber
}

// Status returns HTTPResponse.Status
func (r CreateIncomingPhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIncomingPhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateIncomingPhoneNumberRequestWithBody generates requests for CreateIncomingPhoneNumber with any type of body
func newCreateIncomingPhoneNumberRequestWithBody(baseURL *url.URL, accountSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateIncomingPhoneNumberFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateIncomingPhoneNumberWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers.json
func (c *Client) CreateIncomingPhoneNumberWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateIncomingPhoneNumberResponse, error) {
	req, err := newCreateIncomingPhoneNumberRequestWithBody(c.BaseURL, accountSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateIncomingPhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountIncomingPhoneNumber
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListIncomingPhoneNumberLocal: GET /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Local.json

type ListIncomingPhoneNumberLocalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End                  *int                                                          `json:"end,omitempty"`
		FirstPageUri         *string                                                       `json:"first_page_uri,omitempty"`
		IncomingPhoneNumbers *[]ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocal `json:"incoming_phone_numbers,omitempty"`
		NextPageUri          *string                                                       `json:"next_page_uri,omitempty"`
		Page                 *int                                                          `json:"page,omitempty"`
		PageSize             *int                                                          `json:"page_size,omitempty"`
		PreviousPageUri      *string                                                       `json:"previous_page_uri,omitempty"`
		Start                *int                                                          `json:"start,omitempty"`
		Uri                  *string                                                       `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListIncomingPhoneNumberLocalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIncomingPhoneNumberLocalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListIncomingPhoneNumberLocalRequest generates requests for ListIncomingPhoneNumberLocal
func newListIncomingPhoneNumberLocalRequest(baseURL *url.URL, accountSid string, params *ListIncomingPhoneNumberLocalParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListIncomingPhoneNumberLocalFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Beta != nil {
		if err := client.AddQueryParam(q, "Beta", *params.Beta); err != nil {
			return nil, err
		}
	}

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.PhoneNumber != nil {
		if err := client.AddQueryParam(q, "PhoneNumber", *params.PhoneNumber); err != nil {
			return nil, err
		}
	}

	if params.Origin != nil {
		if err := client.AddQueryParam(q, "Origin", *params.Origin); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListIncomingPhoneNumberLocal returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Local.json
func (c *Client) ListIncomingPhoneNumberLocal(ctx context.Context, accountSid string, params *ListIncomingPhoneNumberLocalParams, reqEditors ...client.RequestEditorFn) (*ListIncomingPhoneNumberLocalResponse, error) {
	req, err := newListIncomingPhoneNumberLocalRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListIncomingPhoneNumberLocalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End                  *int                                                          `json:"end,omitempty"`
			FirstPageUri         *string                                                       `json:"first_page_uri,omitempty"`
			IncomingPhoneNumbers *[]ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocal `json:"incoming_phone_numbers,omitempty"`
			NextPageUri          *string                                                       `json:"next_page_uri,omitempty"`
			Page                 *int                                                          `json:"page,omitempty"`
			PageSize             *int                                                          `json:"page_size,omitempty"`
			PreviousPageUri      *string                                                       `json:"previous_page_uri,omitempty"`
			Start                *int                                                          `json:"start,omitempty"`
			Uri                  *string                                                       `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateIncomingPhoneNumberLocal: POST /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Local.json

type CreateIncomingPhoneNumberLocalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocal
}

// Status returns HTTPResponse.Status
func (r CreateIncomingPhoneNumberLocalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIncomingPhoneNumberLocalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateIncomingPhoneNumberLocalRequestWithBody generates requests for CreateIncomingPhoneNumberLocal with any type of body
func newCreateIncomingPhoneNumberLocalRequestWithBody(baseURL *url.URL, accountSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateIncomingPhoneNumberLocalFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateIncomingPhoneNumberLocalWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Local.json
func (c *Client) CreateIncomingPhoneNumberLocalWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateIncomingPhoneNumberLocalResponse, error) {
	req, err := newCreateIncomingPhoneNumberLocalRequestWithBody(c.BaseURL, accountSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateIncomingPhoneNumberLocalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberLocal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListIncomingPhoneNumberMobile: GET /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Mobile.json

type ListIncomingPhoneNumberMobileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End                  *int                                                           `json:"end,omitempty"`
		FirstPageUri         *string                                                        `json:"first_page_uri,omitempty"`
		IncomingPhoneNumbers *[]ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobile `json:"incoming_phone_numbers,omitempty"`
		NextPageUri          *string                                                        `json:"next_page_uri,omitempty"`
		Page                 *int                                                           `json:"page,omitempty"`
		PageSize             *int                                                           `json:"page_size,omitempty"`
		PreviousPageUri      *string                                                        `json:"previous_page_uri,omitempty"`
		Start                *int                                                           `json:"start,omitempty"`
		Uri                  *string                                                        `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListIncomingPhoneNumberMobileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIncomingPhoneNumberMobileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListIncomingPhoneNumberMobileRequest generates requests for ListIncomingPhoneNumberMobile
func newListIncomingPhoneNumberMobileRequest(baseURL *url.URL, accountSid string, params *ListIncomingPhoneNumberMobileParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListIncomingPhoneNumberMobileFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Beta != nil {
		if err := client.AddQueryParam(q, "Beta", *params.Beta); err != nil {
			return nil, err
		}
	}

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.PhoneNumber != nil {
		if err := client.AddQueryParam(q, "PhoneNumber", *params.PhoneNumber); err != nil {
			return nil, err
		}
	}

	if params.Origin != nil {
		if err := client.AddQueryParam(q, "Origin", *params.Origin); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListIncomingPhoneNumberMobile returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Mobile.json
func (c *Client) ListIncomingPhoneNumberMobile(ctx context.Context, accountSid string, params *ListIncomingPhoneNumberMobileParams, reqEditors ...client.RequestEditorFn) (*ListIncomingPhoneNumberMobileResponse, error) {
	req, err := newListIncomingPhoneNumberMobileRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListIncomingPhoneNumberMobileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End                  *int                                                           `json:"end,omitempty"`
			FirstPageUri         *string                                                        `json:"first_page_uri,omitempty"`
			IncomingPhoneNumbers *[]ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobile `json:"incoming_phone_numbers,omitempty"`
			NextPageUri          *string                                                        `json:"next_page_uri,omitempty"`
			Page                 *int                                                           `json:"page,omitempty"`
			PageSize             *int                                                           `json:"page_size,omitempty"`
			PreviousPageUri      *string                                                        `json:"previous_page_uri,omitempty"`
			Start                *int                                                           `json:"start,omitempty"`
			Uri                  *string                                                        `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateIncomingPhoneNumberMobile: POST /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Mobile.json

type CreateIncomingPhoneNumberMobileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobile
}

// Status returns HTTPResponse.Status
func (r CreateIncomingPhoneNumberMobileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIncomingPhoneNumberMobileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateIncomingPhoneNumberMobileRequestWithBody generates requests for CreateIncomingPhoneNumberMobile with any type of body
func newCreateIncomingPhoneNumberMobileRequestWithBody(baseURL *url.URL, accountSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateIncomingPhoneNumberMobileFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateIncomingPhoneNumberMobileWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/Mobile.json
func (c *Client) CreateIncomingPhoneNumberMobileWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateIncomingPhoneNumberMobileResponse, error) {
	req, err := newCreateIncomingPhoneNumberMobileRequestWithBody(c.BaseURL, accountSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateIncomingPhoneNumberMobileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberMobile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListIncomingPhoneNumberTollFree: GET /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/TollFree.json

type ListIncomingPhoneNumberTollFreeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End                  *int                                                             `json:"end,omitempty"`
		FirstPageUri         *string                                                          `json:"first_page_uri,omitempty"`
		IncomingPhoneNumbers *[]ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFree `json:"incoming_phone_numbers,omitempty"`
		NextPageUri          *string                                                          `json:"next_page_uri,omitempty"`
		Page                 *int                                                             `json:"page,omitempty"`
		PageSize             *int                                                             `json:"page_size,omitempty"`
		PreviousPageUri      *string                                                          `json:"previous_page_uri,omitempty"`
		Start                *int                                                             `json:"start,omitempty"`
		Uri                  *string                                                          `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListIncomingPhoneNumberTollFreeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIncomingPhoneNumberTollFreeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListIncomingPhoneNumberTollFreeRequest generates requests for ListIncomingPhoneNumberTollFree
func newListIncomingPhoneNumberTollFreeRequest(baseURL *url.URL, accountSid string, params *ListIncomingPhoneNumberTollFreeParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListIncomingPhoneNumberTollFreeFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Beta != nil {
		if err := client.AddQueryParam(q, "Beta", *params.Beta); err != nil {
			return nil, err
		}
	}

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.PhoneNumber != nil {
		if err := client.AddQueryParam(q, "PhoneNumber", *params.PhoneNumber); err != nil {
			return nil, err
		}
	}

	if params.Origin != nil {
		if err := client.AddQueryParam(q, "Origin", *params.Origin); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListIncomingPhoneNumberTollFree returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/TollFree.json
func (c *Client) ListIncomingPhoneNumberTollFree(ctx context.Context, accountSid string, params *ListIncomingPhoneNumberTollFreeParams, reqEditors ...client.RequestEditorFn) (*ListIncomingPhoneNumberTollFreeResponse, error) {
	req, err := newListIncomingPhoneNumberTollFreeRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListIncomingPhoneNumberTollFreeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End                  *int                                                             `json:"end,omitempty"`
			FirstPageUri         *string                                                          `json:"first_page_uri,omitempty"`
			IncomingPhoneNumbers *[]ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFree `json:"incoming_phone_numbers,omitempty"`
			NextPageUri          *string                                                          `json:"next_page_uri,omitempty"`
			Page                 *int                                                             `json:"page,omitempty"`
			PageSize             *int                                                             `json:"page_size,omitempty"`
			PreviousPageUri      *string                                                          `json:"previous_page_uri,omitempty"`
			Start                *int                                                             `json:"start,omitempty"`
			Uri                  *string                                                          `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateIncomingPhoneNumberTollFree: POST /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/TollFree.json

type CreateIncomingPhoneNumberTollFreeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFree
}

// Status returns HTTPResponse.Status
func (r CreateIncomingPhoneNumberTollFreeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIncomingPhoneNumberTollFreeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateIncomingPhoneNumberTollFreeRequestWithBody generates requests for CreateIncomingPhoneNumberTollFree with any type of body
func newCreateIncomingPhoneNumberTollFreeRequestWithBody(baseURL *url.URL, accountSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateIncomingPhoneNumberTollFreeFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateIncomingPhoneNumberTollFreeWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/TollFree.json
func (c *Client) CreateIncomingPhoneNumberTollFreeWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateIncomingPhoneNumberTollFreeResponse, error) {
	req, err := newCreateIncomingPhoneNumberTollFreeRequestWithBody(c.BaseURL, accountSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateIncomingPhoneNumberTollFreeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberTollFree
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListIncomingPhoneNumberAssignedAddOn: GET /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns.json

type ListIncomingPhoneNumberAssignedAddOnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AssignedAddOns  *[]ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn `json:"assigned_add_ons,omitempty"`
		End             *int                                                                  `json:"end,omitempty"`
		FirstPageUri    *string                                                               `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                                               `json:"next_page_uri,omitempty"`
		Page            *int                                                                  `json:"page,omitempty"`
		PageSize        *int                                                                  `json:"page_size,omitempty"`
		PreviousPageUri *string                                                               `json:"previous_page_uri,omitempty"`
		Start           *int                                                                  `json:"start,omitempty"`
		Uri             *string                                                               `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListIncomingPhoneNumberAssignedAddOnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIncomingPhoneNumberAssignedAddOnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListIncomingPhoneNumberAssignedAddOnRequest generates requests for ListIncomingPhoneNumberAssignedAddOn
func newListIncomingPhoneNumberAssignedAddOnRequest(baseURL *url.URL, accountSid string, resourceSid string, params *ListIncomingPhoneNumberAssignedAddOnParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ResourceSid", resourceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListIncomingPhoneNumberAssignedAddOnFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListIncomingPhoneNumberAssignedAddOn returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns.json
func (c *Client) ListIncomingPhoneNumberAssignedAddOn(ctx context.Context, accountSid string, resourceSid string, params *ListIncomingPhoneNumberAssignedAddOnParams, reqEditors ...client.RequestEditorFn) (*ListIncomingPhoneNumberAssignedAddOnResponse, error) {
	req, err := newListIncomingPhoneNumberAssignedAddOnRequest(c.BaseURL, accountSid, resourceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListIncomingPhoneNumberAssignedAddOnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AssignedAddOns  *[]ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn `json:"assigned_add_ons,omitempty"`
			End             *int                                                                  `json:"end,omitempty"`
			FirstPageUri    *string                                                               `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                                               `json:"next_page_uri,omitempty"`
			Page            *int                                                                  `json:"page,omitempty"`
			PageSize        *int                                                                  `json:"page_size,omitempty"`
			PreviousPageUri *string                                                               `json:"previous_page_uri,omitempty"`
			Start           *int                                                                  `json:"start,omitempty"`
			Uri             *string                                                               `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateIncomingPhoneNumberAssignedAddOn: POST /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns.json

type CreateIncomingPhoneNumberAssignedAddOnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn
}

// Status returns HTTPResponse.Status
func (r CreateIncomingPhoneNumberAssignedAddOnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIncomingPhoneNumberAssignedAddOnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateIncomingPhoneNumberAssignedAddOnRequestWithBody generates requests for CreateIncomingPhoneNumberAssignedAddOn with any type of body
func newCreateIncomingPhoneNumberAssignedAddOnRequestWithBody(baseURL *url.URL, accountSid string, resourceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ResourceSid", resourceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateIncomingPhoneNumberAssignedAddOnFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateIncomingPhoneNumberAssignedAddOnWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns.json
func (c *Client) CreateIncomingPhoneNumberAssignedAddOnWithBody(ctx context.Context, accountSid string, resourceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateIncomingPhoneNumberAssignedAddOnResponse, error) {
	req, err := newCreateIncomingPhoneNumberAssignedAddOnRequestWithBody(c.BaseURL, accountSid, resourceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateIncomingPhoneNumberAssignedAddOnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListIncomingPhoneNumberAssignedAddOnExtension: GET /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{AssignedAddOnSid}/Extensions.json

type ListIncomingPhoneNumberAssignedAddOnExtensionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                                                                                                           `json:"end,omitempty"`
		Extensions      *[]ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOnIncomingPhoneNumberAssignedAddOnExtension `json:"extensions,omitempty"`
		FirstPageUri    *string                                                                                                        `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                                                                                        `json:"next_page_uri,omitempty"`
		Page            *int                                                                                                           `json:"page,omitempty"`
		PageSize        *int                                                                                                           `json:"page_size,omitempty"`
		PreviousPageUri *string                                                                                                        `json:"previous_page_uri,omitempty"`
		Start           *int                                                                                                           `json:"start,omitempty"`
		Uri             *string                                                                                                        `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListIncomingPhoneNumberAssignedAddOnExtensionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIncomingPhoneNumberAssignedAddOnExtensionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListIncomingPhoneNumberAssignedAddOnExtensionRequest generates requests for ListIncomingPhoneNumberAssignedAddOnExtension
func newListIncomingPhoneNumberAssignedAddOnExtensionRequest(baseURL *url.URL, accountSid string, resourceSid string, assignedAddOnSid string, params *ListIncomingPhoneNumberAssignedAddOnExtensionParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ResourceSid", resourceSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("AssignedAddOnSid", assignedAddOnSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListIncomingPhoneNumberAssignedAddOnExtensionFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListIncomingPhoneNumberAssignedAddOnExtension returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{AssignedAddOnSid}/Extensions.json
func (c *Client) ListIncomingPhoneNumberAssignedAddOnExtension(ctx context.Context, accountSid string, resourceSid string, assignedAddOnSid string, params *ListIncomingPhoneNumberAssignedAddOnExtensionParams, reqEditors ...client.RequestEditorFn) (*ListIncomingPhoneNumberAssignedAddOnExtensionResponse, error) {
	req, err := newListIncomingPhoneNumberAssignedAddOnExtensionRequest(c.BaseURL, accountSid, resourceSid, assignedAddOnSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListIncomingPhoneNumberAssignedAddOnExtensionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                                                                                                           `json:"end,omitempty"`
			Extensions      *[]ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOnIncomingPhoneNumberAssignedAddOnExtension `json:"extensions,omitempty"`
			FirstPageUri    *string                                                                                                        `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                                                                                        `json:"next_page_uri,omitempty"`
			Page            *int                                                                                                           `json:"page,omitempty"`
			PageSize        *int                                                                                                           `json:"page_size,omitempty"`
			PreviousPageUri *string                                                                                                        `json:"previous_page_uri,omitempty"`
			Start           *int                                                                                                           `json:"start,omitempty"`
			Uri             *string                                                                                                        `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchIncomingPhoneNumberAssignedAddOnExtension: GET /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{AssignedAddOnSid}/Extensions/{Sid}.json

type FetchIncomingPhoneNumberAssignedAddOnExtensionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOnIncomingPhoneNumberAssignedAddOnExtension
}

// Status returns HTTPResponse.Status
func (r FetchIncomingPhoneNumberAssignedAddOnExtensionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchIncomingPhoneNumberAssignedAddOnExtensionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchIncomingPhoneNumberAssignedAddOnExtensionRequest generates requests for FetchIncomingPhoneNumberAssignedAddOnExtension
func newFetchIncomingPhoneNumberAssignedAddOnExtensionRequest(baseURL *url.URL, accountSid string, resourceSid string, assignedAddOnSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ResourceSid", resourceSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("AssignedAddOnSid", assignedAddOnSid)
	if err != nil {
		return nil, err
	}

	pathParam3, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchIncomingPhoneNumberAssignedAddOnExtensionFormat, pathParam0, pathParam1, pathParam2, pathParam3)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchIncomingPhoneNumberAssignedAddOnExtension returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{AssignedAddOnSid}/Extensions/{Sid}.json
func (c *Client) FetchIncomingPhoneNumberAssignedAddOnExtension(ctx context.Context, accountSid string, resourceSid string, assignedAddOnSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchIncomingPhoneNumberAssignedAddOnExtensionResponse, error) {
	req, err := newFetchIncomingPhoneNumberAssignedAddOnExtensionRequest(c.BaseURL, accountSid, resourceSid, assignedAddOnSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchIncomingPhoneNumberAssignedAddOnExtensionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOnIncomingPhoneNumberAssignedAddOnExtension
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteIncomingPhoneNumberAssignedAddOn: DELETE /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{Sid}.json

type DeleteIncomingPhoneNumberAssignedAddOnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteIncomingPhoneNumberAssignedAddOnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIncomingPhoneNumberAssignedAddOnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteIncomingPhoneNumberAssignedAddOnRequest generates requests for DeleteIncomingPhoneNumberAssignedAddOn
func newDeleteIncomingPhoneNumberAssignedAddOnRequest(baseURL *url.URL, accountSid string, resourceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ResourceSid", resourceSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteIncomingPhoneNumberAssignedAddOnFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteIncomingPhoneNumberAssignedAddOn returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{Sid}.json
func (c *Client) DeleteIncomingPhoneNumberAssignedAddOn(ctx context.Context, accountSid string, resourceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteIncomingPhoneNumberAssignedAddOnResponse, error) {
	req, err := newDeleteIncomingPhoneNumberAssignedAddOnRequest(c.BaseURL, accountSid, resourceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteIncomingPhoneNumberAssignedAddOnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchIncomingPhoneNumberAssignedAddOn: GET /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{Sid}.json

type FetchIncomingPhoneNumberAssignedAddOnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn
}

// Status returns HTTPResponse.Status
func (r FetchIncomingPhoneNumberAssignedAddOnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchIncomingPhoneNumberAssignedAddOnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchIncomingPhoneNumberAssignedAddOnRequest generates requests for FetchIncomingPhoneNumberAssignedAddOn
func newFetchIncomingPhoneNumberAssignedAddOnRequest(baseURL *url.URL, accountSid string, resourceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ResourceSid", resourceSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchIncomingPhoneNumberAssignedAddOnFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchIncomingPhoneNumberAssignedAddOn returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{ResourceSid}/AssignedAddOns/{Sid}.json
func (c *Client) FetchIncomingPhoneNumberAssignedAddOn(ctx context.Context, accountSid string, resourceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchIncomingPhoneNumberAssignedAddOnResponse, error) {
	req, err := newFetchIncomingPhoneNumberAssignedAddOnRequest(c.BaseURL, accountSid, resourceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchIncomingPhoneNumberAssignedAddOnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountIncomingPhoneNumberIncomingPhoneNumberAssignedAddOn
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteIncomingPhoneNumber: DELETE /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{Sid}.json

type DeleteIncomingPhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteIncomingPhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIncomingPhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteIncomingPhoneNumberRequest generates requests for DeleteIncomingPhoneNumber
func newDeleteIncomingPhoneNumberRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteIncomingPhoneNumberFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteIncomingPhoneNumber returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{Sid}.json
func (c *Client) DeleteIncomingPhoneNumber(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteIncomingPhoneNumberResponse, error) {
	req, err := newDeleteIncomingPhoneNumberRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteIncomingPhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchIncomingPhoneNumber: GET /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{Sid}.json

type FetchIncomingPhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountIncomingPhoneNumber
}

// Status returns HTTPResponse.Status
func (r FetchIncomingPhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchIncomingPhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchIncomingPhoneNumberRequest generates requests for FetchIncomingPhoneNumber
func newFetchIncomingPhoneNumberRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchIncomingPhoneNumberFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchIncomingPhoneNumber returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{Sid}.json
func (c *Client) FetchIncomingPhoneNumber(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchIncomingPhoneNumberResponse, error) {
	req, err := newFetchIncomingPhoneNumberRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchIncomingPhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountIncomingPhoneNumber
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateIncomingPhoneNumber: POST /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{Sid}.json

type UpdateIncomingPhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountIncomingPhoneNumber
}

// Status returns HTTPResponse.Status
func (r UpdateIncomingPhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateIncomingPhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateIncomingPhoneNumberRequestWithBody generates requests for UpdateIncomingPhoneNumber with any type of body
func newUpdateIncomingPhoneNumberRequestWithBody(baseURL *url.URL, accountSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateIncomingPhoneNumberFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateIncomingPhoneNumberWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/IncomingPhoneNumbers/{Sid}.json
func (c *Client) UpdateIncomingPhoneNumberWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateIncomingPhoneNumberResponse, error) {
	req, err := newUpdateIncomingPhoneNumberRequestWithBody(c.BaseURL, accountSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateIncomingPhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountIncomingPhoneNumber
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListKey: GET /2010-04-01/Accounts/{AccountSid}/Keys.json

type ListKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                  `json:"end,omitempty"`
		FirstPageUri    *string               `json:"first_page_uri,omitempty"`
		Keys            *[]ApiV2010AccountKey `json:"keys,omitempty"`
		NextPageUri     *string               `json:"next_page_uri,omitempty"`
		Page            *int                  `json:"page,omitempty"`
		PageSize        *int                  `json:"page_size,omitempty"`
		PreviousPageUri *string               `json:"previous_page_uri,omitempty"`
		Start           *int                  `json:"start,omitempty"`
		Uri             *string               `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListKeyRequest generates requests for ListKey
func newListKeyRequest(baseURL *url.URL, accountSid string, params *ListKeyParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListKeyFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListKey returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Keys.json
func (c *Client) ListKey(ctx context.Context, accountSid string, params *ListKeyParams, reqEditors ...client.RequestEditorFn) (*ListKeyResponse, error) {
	req, err := newListKeyRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                  `json:"end,omitempty"`
			FirstPageUri    *string               `json:"first_page_uri,omitempty"`
			Keys            *[]ApiV2010AccountKey `json:"keys,omitempty"`
			NextPageUri     *string               `json:"next_page_uri,omitempty"`
			Page            *int                  `json:"page,omitempty"`
			PageSize        *int                  `json:"page_size,omitempty"`
			PreviousPageUri *string               `json:"previous_page_uri,omitempty"`
			Start           *int                  `json:"start,omitempty"`
			Uri             *string               `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateNewKey: POST /2010-04-01/Accounts/{AccountSid}/Keys.json

type CreateNewKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountNewKey
}

// Status returns HTTPResponse.Status
func (r CreateNewKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNewKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateNewKeyRequestWithBody generates requests for CreateNewKey with any type of body
func newCreateNewKeyRequestWithBody(baseURL *url.URL, accountSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateNewKeyFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateNewKeyWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Keys.json
func (c *Client) CreateNewKeyWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateNewKeyResponse, error) {
	req, err := newCreateNewKeyRequestWithBody(c.BaseURL, accountSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateNewKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountNewKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteKey: DELETE /2010-04-01/Accounts/{AccountSid}/Keys/{Sid}.json

type DeleteKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteKeyRequest generates requests for DeleteKey
func newDeleteKeyRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteKeyFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteKey returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/Keys/{Sid}.json
func (c *Client) DeleteKey(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteKeyResponse, error) {
	req, err := newDeleteKeyRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchKey: GET /2010-04-01/Accounts/{AccountSid}/Keys/{Sid}.json

type FetchKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountKey
}

// Status returns HTTPResponse.Status
func (r FetchKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchKeyRequest generates requests for FetchKey
func newFetchKeyRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchKeyFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchKey returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Keys/{Sid}.json
func (c *Client) FetchKey(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchKeyResponse, error) {
	req, err := newFetchKeyRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateKey: POST /2010-04-01/Accounts/{AccountSid}/Keys/{Sid}.json

type UpdateKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountKey
}

// Status returns HTTPResponse.Status
func (r UpdateKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateKeyRequestWithBody generates requests for UpdateKey with any type of body
func newUpdateKeyRequestWithBody(baseURL *url.URL, accountSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateKeyFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateKeyWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Keys/{Sid}.json
func (c *Client) UpdateKeyWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateKeyResponse, error) {
	req, err := newUpdateKeyRequestWithBody(c.BaseURL, accountSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListMessage: GET /2010-04-01/Accounts/{AccountSid}/Messages.json

type ListMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                      `json:"end,omitempty"`
		FirstPageUri    *string                   `json:"first_page_uri,omitempty"`
		Messages        *[]ApiV2010AccountMessage `json:"messages,omitempty"`
		NextPageUri     *string                   `json:"next_page_uri,omitempty"`
		Page            *int                      `json:"page,omitempty"`
		PageSize        *int                      `json:"page_size,omitempty"`
		PreviousPageUri *string                   `json:"previous_page_uri,omitempty"`
		Start           *int                      `json:"start,omitempty"`
		Uri             *string                   `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListMessageRequest generates requests for ListMessage
func newListMessageRequest(baseURL *url.URL, accountSid string, params *ListMessageParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListMessageFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.To != nil {
		if err := client.AddQueryParam(q, "To", *params.To); err != nil {
			return nil, err
		}
	}

	if params.From != nil {
		if err := client.AddQueryParam(q, "From", *params.From); err != nil {
			return nil, err
		}
	}

	if params.DateSent != nil {
		if err := client.AddQueryParam(q, "DateSent", *params.DateSent); err != nil {
			return nil, err
		}
	}

	if params.DateSent != nil {
		if err := client.AddQueryParam(q, "DateSent<", *params.DateSent); err != nil {
			return nil, err
		}
	}

	if params.DateSent != nil {
		if err := client.AddQueryParam(q, "DateSent>", *params.DateSent); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListMessage returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Messages.json
func (c *Client) ListMessage(ctx context.Context, accountSid string, params *ListMessageParams, reqEditors ...client.RequestEditorFn) (*ListMessageResponse, error) {
	req, err := newListMessageRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                      `json:"end,omitempty"`
			FirstPageUri    *string                   `json:"first_page_uri,omitempty"`
			Messages        *[]ApiV2010AccountMessage `json:"messages,omitempty"`
			NextPageUri     *string                   `json:"next_page_uri,omitempty"`
			Page            *int                      `json:"page,omitempty"`
			PageSize        *int                      `json:"page_size,omitempty"`
			PreviousPageUri *string                   `json:"previous_page_uri,omitempty"`
			Start           *int                      `json:"start,omitempty"`
			Uri             *string                   `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateMessage: POST /2010-04-01/Accounts/{AccountSid}/Messages.json

type CreateMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountMessage
}

// Status returns HTTPResponse.Status
func (r CreateMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateMessageRequestWithBody generates requests for CreateMessage with any type of body
func newCreateMessageRequestWithBody(baseURL *url.URL, accountSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateMessageFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateMessageWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Messages.json
func (c *Client) CreateMessageWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateMessageResponse, error) {
	req, err := newCreateMessageRequestWithBody(c.BaseURL, accountSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// CreateMessageFeedback: POST /2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Feedback.json

type CreateMessageFeedbackResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountMessageMessageFeedback
}

// Status returns HTTPResponse.Status
func (r CreateMessageFeedbackResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMessageFeedbackResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateMessageFeedbackRequestWithBody generates requests for CreateMessageFeedback with any type of body
func newCreateMessageFeedbackRequestWithBody(baseURL *url.URL, accountSid string, messageSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("MessageSid", messageSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateMessageFeedbackFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateMessageFeedbackWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Feedback.json
func (c *Client) CreateMessageFeedbackWithBody(ctx context.Context, accountSid string, messageSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateMessageFeedbackResponse, error) {
	req, err := newCreateMessageFeedbackRequestWithBody(c.BaseURL, accountSid, messageSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateMessageFeedbackResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountMessageMessageFeedback
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListMedia: GET /2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media.json

type ListMediaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                           `json:"end,omitempty"`
		FirstPageUri    *string                        `json:"first_page_uri,omitempty"`
		MediaList       *[]ApiV2010AccountMessageMedia `json:"media_list,omitempty"`
		NextPageUri     *string                        `json:"next_page_uri,omitempty"`
		Page            *int                           `json:"page,omitempty"`
		PageSize        *int                           `json:"page_size,omitempty"`
		PreviousPageUri *string                        `json:"previous_page_uri,omitempty"`
		Start           *int                           `json:"start,omitempty"`
		Uri             *string                        `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListMediaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMediaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListMediaRequest generates requests for ListMedia
func newListMediaRequest(baseURL *url.URL, accountSid string, messageSid string, params *ListMediaParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("MessageSid", messageSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListMediaFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.DateCreated != nil {
		if err := client.AddQueryParam(q, "DateCreated", *params.DateCreated); err != nil {
			return nil, err
		}
	}

	if params.DateCreated != nil {
		if err := client.AddQueryParam(q, "DateCreated<", *params.DateCreated); err != nil {
			return nil, err
		}
	}

	if params.DateCreated != nil {
		if err := client.AddQueryParam(q, "DateCreated>", *params.DateCreated); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListMedia returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media.json
func (c *Client) ListMedia(ctx context.Context, accountSid string, messageSid string, params *ListMediaParams, reqEditors ...client.RequestEditorFn) (*ListMediaResponse, error) {
	req, err := newListMediaRequest(c.BaseURL, accountSid, messageSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListMediaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                           `json:"end,omitempty"`
			FirstPageUri    *string                        `json:"first_page_uri,omitempty"`
			MediaList       *[]ApiV2010AccountMessageMedia `json:"media_list,omitempty"`
			NextPageUri     *string                        `json:"next_page_uri,omitempty"`
			Page            *int                           `json:"page,omitempty"`
			PageSize        *int                           `json:"page_size,omitempty"`
			PreviousPageUri *string                        `json:"previous_page_uri,omitempty"`
			Start           *int                           `json:"start,omitempty"`
			Uri             *string                        `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteMedia: DELETE /2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media/{Sid}.json

type DeleteMediaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteMediaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMediaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteMediaRequest generates requests for DeleteMedia
func newDeleteMediaRequest(baseURL *url.URL, accountSid string, messageSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("MessageSid", messageSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteMediaFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteMedia returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media/{Sid}.json
func (c *Client) DeleteMedia(ctx context.Context, accountSid string, messageSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteMediaResponse, error) {
	req, err := newDeleteMediaRequest(c.BaseURL, accountSid, messageSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteMediaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchMedia: GET /2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media/{Sid}.json

type FetchMediaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountMessageMedia
}

// Status returns HTTPResponse.Status
func (r FetchMediaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchMediaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchMediaRequest generates requests for FetchMedia
func newFetchMediaRequest(baseURL *url.URL, accountSid string, messageSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("MessageSid", messageSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchMediaFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchMedia returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Messages/{MessageSid}/Media/{Sid}.json
func (c *Client) FetchMedia(ctx context.Context, accountSid string, messageSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchMediaResponse, error) {
	req, err := newFetchMediaRequest(c.BaseURL, accountSid, messageSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchMediaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountMessageMedia
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteMessage: DELETE /2010-04-01/Accounts/{AccountSid}/Messages/{Sid}.json

type DeleteMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteMessageRequest generates requests for DeleteMessage
func newDeleteMessageRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteMessageFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteMessage returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/Messages/{Sid}.json
func (c *Client) DeleteMessage(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteMessageResponse, error) {
	req, err := newDeleteMessageRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchMessage: GET /2010-04-01/Accounts/{AccountSid}/Messages/{Sid}.json

type FetchMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountMessage
}

// Status returns HTTPResponse.Status
func (r FetchMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchMessageRequest generates requests for FetchMessage
func newFetchMessageRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchMessageFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchMessage returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Messages/{Sid}.json
func (c *Client) FetchMessage(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchMessageResponse, error) {
	req, err := newFetchMessageRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateMessage: POST /2010-04-01/Accounts/{AccountSid}/Messages/{Sid}.json

type UpdateMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountMessage
}

// Status returns HTTPResponse.Status
func (r UpdateMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateMessageRequestWithBody generates requests for UpdateMessage with any type of body
func newUpdateMessageRequestWithBody(baseURL *url.URL, accountSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateMessageFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateMessageWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Messages/{Sid}.json
func (c *Client) UpdateMessageWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateMessageResponse, error) {
	req, err := newUpdateMessageRequestWithBody(c.BaseURL, accountSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListNotification: GET /2010-04-01/Accounts/{AccountSid}/Notifications.json

type ListNotificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                           `json:"end,omitempty"`
		FirstPageUri    *string                        `json:"first_page_uri,omitempty"`
		NextPageUri     *string                        `json:"next_page_uri,omitempty"`
		Notifications   *[]ApiV2010AccountNotification `json:"notifications,omitempty"`
		Page            *int                           `json:"page,omitempty"`
		PageSize        *int                           `json:"page_size,omitempty"`
		PreviousPageUri *string                        `json:"previous_page_uri,omitempty"`
		Start           *int                           `json:"start,omitempty"`
		Uri             *string                        `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListNotificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNotificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListNotificationRequest generates requests for ListNotification
func newListNotificationRequest(baseURL *url.URL, accountSid string, params *ListNotificationParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListNotificationFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Log != nil {
		if err := client.AddQueryParam(q, "Log", *params.Log); err != nil {
			return nil, err
		}
	}

	if params.MessageDate != nil {
		if err := client.AddQueryParam(q, "MessageDate", *params.MessageDate); err != nil {
			return nil, err
		}
	}

	if params.MessageDate != nil {
		if err := client.AddQueryParam(q, "MessageDate<", *params.MessageDate); err != nil {
			return nil, err
		}
	}

	if params.MessageDate != nil {
		if err := client.AddQueryParam(q, "MessageDate>", *params.MessageDate); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListNotification returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Notifications.json
func (c *Client) ListNotification(ctx context.Context, accountSid string, params *ListNotificationParams, reqEditors ...client.RequestEditorFn) (*ListNotificationResponse, error) {
	req, err := newListNotificationRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListNotificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                           `json:"end,omitempty"`
			FirstPageUri    *string                        `json:"first_page_uri,omitempty"`
			NextPageUri     *string                        `json:"next_page_uri,omitempty"`
			Notifications   *[]ApiV2010AccountNotification `json:"notifications,omitempty"`
			Page            *int                           `json:"page,omitempty"`
			PageSize        *int                           `json:"page_size,omitempty"`
			PreviousPageUri *string                        `json:"previous_page_uri,omitempty"`
			Start           *int                           `json:"start,omitempty"`
			Uri             *string                        `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchNotification: GET /2010-04-01/Accounts/{AccountSid}/Notifications/{Sid}.json

type FetchNotificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountNotificationInstance
}

// Status returns HTTPResponse.Status
func (r FetchNotificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchNotificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchNotificationRequest generates requests for FetchNotification
func newFetchNotificationRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchNotificationFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchNotification returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Notifications/{Sid}.json
func (c *Client) FetchNotification(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchNotificationResponse, error) {
	req, err := newFetchNotificationRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchNotificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountNotificationInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListOutgoingCallerId: GET /2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds.json

type ListOutgoingCallerIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End               *int                               `json:"end,omitempty"`
		FirstPageUri      *string                            `json:"first_page_uri,omitempty"`
		NextPageUri       *string                            `json:"next_page_uri,omitempty"`
		OutgoingCallerIds *[]ApiV2010AccountOutgoingCallerId `json:"outgoing_caller_ids,omitempty"`
		Page              *int                               `json:"page,omitempty"`
		PageSize          *int                               `json:"page_size,omitempty"`
		PreviousPageUri   *string                            `json:"previous_page_uri,omitempty"`
		Start             *int                               `json:"start,omitempty"`
		Uri               *string                            `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListOutgoingCallerIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOutgoingCallerIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListOutgoingCallerIdRequest generates requests for ListOutgoingCallerId
func newListOutgoingCallerIdRequest(baseURL *url.URL, accountSid string, params *ListOutgoingCallerIdParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListOutgoingCallerIdFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PhoneNumber != nil {
		if err := client.AddQueryParam(q, "PhoneNumber", *params.PhoneNumber); err != nil {
			return nil, err
		}
	}

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListOutgoingCallerId returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds.json
func (c *Client) ListOutgoingCallerId(ctx context.Context, accountSid string, params *ListOutgoingCallerIdParams, reqEditors ...client.RequestEditorFn) (*ListOutgoingCallerIdResponse, error) {
	req, err := newListOutgoingCallerIdRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListOutgoingCallerIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End               *int                               `json:"end,omitempty"`
			FirstPageUri      *string                            `json:"first_page_uri,omitempty"`
			NextPageUri       *string                            `json:"next_page_uri,omitempty"`
			OutgoingCallerIds *[]ApiV2010AccountOutgoingCallerId `json:"outgoing_caller_ids,omitempty"`
			Page              *int                               `json:"page,omitempty"`
			PageSize          *int                               `json:"page_size,omitempty"`
			PreviousPageUri   *string                            `json:"previous_page_uri,omitempty"`
			Start             *int                               `json:"start,omitempty"`
			Uri               *string                            `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateValidationRequest: POST /2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds.json

type CreateValidationRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountValidationRequest
}

// Status returns HTTPResponse.Status
func (r CreateValidationRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateValidationRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateValidationRequestRequestWithBody generates requests for CreateValidationRequest with any type of body
func newCreateValidationRequestRequestWithBody(baseURL *url.URL, accountSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateValidationRequestFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateValidationRequestWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds.json
func (c *Client) CreateValidationRequestWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateValidationRequestResponse, error) {
	req, err := newCreateValidationRequestRequestWithBody(c.BaseURL, accountSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateValidationRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountValidationRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteOutgoingCallerId: DELETE /2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds/{Sid}.json

type DeleteOutgoingCallerIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteOutgoingCallerIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOutgoingCallerIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteOutgoingCallerIdRequest generates requests for DeleteOutgoingCallerId
func newDeleteOutgoingCallerIdRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteOutgoingCallerIdFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteOutgoingCallerId returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds/{Sid}.json
func (c *Client) DeleteOutgoingCallerId(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteOutgoingCallerIdResponse, error) {
	req, err := newDeleteOutgoingCallerIdRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteOutgoingCallerIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchOutgoingCallerId: GET /2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds/{Sid}.json

type FetchOutgoingCallerIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountOutgoingCallerId
}

// Status returns HTTPResponse.Status
func (r FetchOutgoingCallerIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchOutgoingCallerIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchOutgoingCallerIdRequest generates requests for FetchOutgoingCallerId
func newFetchOutgoingCallerIdRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchOutgoingCallerIdFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchOutgoingCallerId returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds/{Sid}.json
func (c *Client) FetchOutgoingCallerId(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchOutgoingCallerIdResponse, error) {
	req, err := newFetchOutgoingCallerIdRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchOutgoingCallerIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountOutgoingCallerId
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateOutgoingCallerId: POST /2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds/{Sid}.json

type UpdateOutgoingCallerIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountOutgoingCallerId
}

// Status returns HTTPResponse.Status
func (r UpdateOutgoingCallerIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOutgoingCallerIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateOutgoingCallerIdRequestWithBody generates requests for UpdateOutgoingCallerId with any type of body
func newUpdateOutgoingCallerIdRequestWithBody(baseURL *url.URL, accountSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateOutgoingCallerIdFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateOutgoingCallerIdWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/OutgoingCallerIds/{Sid}.json
func (c *Client) UpdateOutgoingCallerIdWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateOutgoingCallerIdResponse, error) {
	req, err := newUpdateOutgoingCallerIdRequestWithBody(c.BaseURL, accountSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateOutgoingCallerIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountOutgoingCallerId
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListQueue: GET /2010-04-01/Accounts/{AccountSid}/Queues.json

type ListQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                    `json:"end,omitempty"`
		FirstPageUri    *string                 `json:"first_page_uri,omitempty"`
		NextPageUri     *string                 `json:"next_page_uri,omitempty"`
		Page            *int                    `json:"page,omitempty"`
		PageSize        *int                    `json:"page_size,omitempty"`
		PreviousPageUri *string                 `json:"previous_page_uri,omitempty"`
		Queues          *[]ApiV2010AccountQueue `json:"queues,omitempty"`
		Start           *int                    `json:"start,omitempty"`
		Uri             *string                 `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListQueueRequest generates requests for ListQueue
func newListQueueRequest(baseURL *url.URL, accountSid string, params *ListQueueParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListQueueFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListQueue returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Queues.json
func (c *Client) ListQueue(ctx context.Context, accountSid string, params *ListQueueParams, reqEditors ...client.RequestEditorFn) (*ListQueueResponse, error) {
	req, err := newListQueueRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                    `json:"end,omitempty"`
			FirstPageUri    *string                 `json:"first_page_uri,omitempty"`
			NextPageUri     *string                 `json:"next_page_uri,omitempty"`
			Page            *int                    `json:"page,omitempty"`
			PageSize        *int                    `json:"page_size,omitempty"`
			PreviousPageUri *string                 `json:"previous_page_uri,omitempty"`
			Queues          *[]ApiV2010AccountQueue `json:"queues,omitempty"`
			Start           *int                    `json:"start,omitempty"`
			Uri             *string                 `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateQueue: POST /2010-04-01/Accounts/{AccountSid}/Queues.json

type CreateQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountQueue
}

// Status returns HTTPResponse.Status
func (r CreateQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateQueueRequestWithBody generates requests for CreateQueue with any type of body
func newCreateQueueRequestWithBody(baseURL *url.URL, accountSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateQueueFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateQueueWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Queues.json
func (c *Client) CreateQueueWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateQueueResponse, error) {
	req, err := newCreateQueueRequestWithBody(c.BaseURL, accountSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountQueue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListMember: GET /2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members.json

type ListMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                          `json:"end,omitempty"`
		FirstPageUri    *string                       `json:"first_page_uri,omitempty"`
		NextPageUri     *string                       `json:"next_page_uri,omitempty"`
		Page            *int                          `json:"page,omitempty"`
		PageSize        *int                          `json:"page_size,omitempty"`
		PreviousPageUri *string                       `json:"previous_page_uri,omitempty"`
		QueueMembers    *[]ApiV2010AccountQueueMember `json:"queue_members,omitempty"`
		Start           *int                          `json:"start,omitempty"`
		Uri             *string                       `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListMemberRequest generates requests for ListMember
func newListMemberRequest(baseURL *url.URL, accountSid string, queueSid string, params *ListMemberParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("QueueSid", queueSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListMemberFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListMember returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members.json
func (c *Client) ListMember(ctx context.Context, accountSid string, queueSid string, params *ListMemberParams, reqEditors ...client.RequestEditorFn) (*ListMemberResponse, error) {
	req, err := newListMemberRequest(c.BaseURL, accountSid, queueSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                          `json:"end,omitempty"`
			FirstPageUri    *string                       `json:"first_page_uri,omitempty"`
			NextPageUri     *string                       `json:"next_page_uri,omitempty"`
			Page            *int                          `json:"page,omitempty"`
			PageSize        *int                          `json:"page_size,omitempty"`
			PreviousPageUri *string                       `json:"previous_page_uri,omitempty"`
			QueueMembers    *[]ApiV2010AccountQueueMember `json:"queue_members,omitempty"`
			Start           *int                          `json:"start,omitempty"`
			Uri             *string                       `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchMember: GET /2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members/{CallSid}.json

type FetchMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountQueueMember
}

// Status returns HTTPResponse.Status
func (r FetchMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchMemberRequest generates requests for FetchMember
func newFetchMemberRequest(baseURL *url.URL, accountSid string, queueSid string, callSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("QueueSid", queueSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchMemberFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchMember returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members/{CallSid}.json
func (c *Client) FetchMember(ctx context.Context, accountSid string, queueSid string, callSid string, reqEditors ...client.RequestEditorFn) (*FetchMemberResponse, error) {
	req, err := newFetchMemberRequest(c.BaseURL, accountSid, queueSid, callSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountQueueMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateMember: POST /2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members/{CallSid}.json

type UpdateMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountQueueMember
}

// Status returns HTTPResponse.Status
func (r UpdateMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateMemberRequestWithBody generates requests for UpdateMember with any type of body
func newUpdateMemberRequestWithBody(baseURL *url.URL, accountSid string, queueSid string, callSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("QueueSid", queueSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("CallSid", callSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateMemberFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateMemberWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Queues/{QueueSid}/Members/{CallSid}.json
func (c *Client) UpdateMemberWithBody(ctx context.Context, accountSid string, queueSid string, callSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateMemberResponse, error) {
	req, err := newUpdateMemberRequestWithBody(c.BaseURL, accountSid, queueSid, callSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountQueueMember
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteQueue: DELETE /2010-04-01/Accounts/{AccountSid}/Queues/{Sid}.json

type DeleteQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteQueueRequest generates requests for DeleteQueue
func newDeleteQueueRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteQueueFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteQueue returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/Queues/{Sid}.json
func (c *Client) DeleteQueue(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteQueueResponse, error) {
	req, err := newDeleteQueueRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchQueue: GET /2010-04-01/Accounts/{AccountSid}/Queues/{Sid}.json

type FetchQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountQueue
}

// Status returns HTTPResponse.Status
func (r FetchQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchQueueRequest generates requests for FetchQueue
func newFetchQueueRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchQueueFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchQueue returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Queues/{Sid}.json
func (c *Client) FetchQueue(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchQueueResponse, error) {
	req, err := newFetchQueueRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountQueue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateQueue: POST /2010-04-01/Accounts/{AccountSid}/Queues/{Sid}.json

type UpdateQueueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountQueue
}

// Status returns HTTPResponse.Status
func (r UpdateQueueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateQueueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateQueueRequestWithBody generates requests for UpdateQueue with any type of body
func newUpdateQueueRequestWithBody(baseURL *url.URL, accountSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateQueueFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateQueueWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Queues/{Sid}.json
func (c *Client) UpdateQueueWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateQueueResponse, error) {
	req, err := newUpdateQueueRequestWithBody(c.BaseURL, accountSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateQueueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountQueue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListRecording: GET /2010-04-01/Accounts/{AccountSid}/Recordings.json

type ListRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                        `json:"end,omitempty"`
		FirstPageUri    *string                     `json:"first_page_uri,omitempty"`
		NextPageUri     *string                     `json:"next_page_uri,omitempty"`
		Page            *int                        `json:"page,omitempty"`
		PageSize        *int                        `json:"page_size,omitempty"`
		PreviousPageUri *string                     `json:"previous_page_uri,omitempty"`
		Recordings      *[]ApiV2010AccountRecording `json:"recordings,omitempty"`
		Start           *int                        `json:"start,omitempty"`
		Uri             *string                     `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListRecordingRequest generates requests for ListRecording
func newListRecordingRequest(baseURL *url.URL, accountSid string, params *ListRecordingParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListRecordingFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.DateCreated != nil {
		if err := client.AddQueryParam(q, "DateCreated", *params.DateCreated); err != nil {
			return nil, err
		}
	}

	if params.DateCreated != nil {
		if err := client.AddQueryParam(q, "DateCreated<", *params.DateCreated); err != nil {
			return nil, err
		}
	}

	if params.DateCreated != nil {
		if err := client.AddQueryParam(q, "DateCreated>", *params.DateCreated); err != nil {
			return nil, err
		}
	}

	if params.CallSid != nil {
		if err := client.AddQueryParam(q, "CallSid", *params.CallSid); err != nil {
			return nil, err
		}
	}

	if params.ConferenceSid != nil {
		if err := client.AddQueryParam(q, "ConferenceSid", *params.ConferenceSid); err != nil {
			return nil, err
		}
	}

	if params.IncludeSoftDeleted != nil {
		if err := client.AddQueryParam(q, "IncludeSoftDeleted", *params.IncludeSoftDeleted); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListRecording returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Recordings.json
func (c *Client) ListRecording(ctx context.Context, accountSid string, params *ListRecordingParams, reqEditors ...client.RequestEditorFn) (*ListRecordingResponse, error) {
	req, err := newListRecordingRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                        `json:"end,omitempty"`
			FirstPageUri    *string                     `json:"first_page_uri,omitempty"`
			NextPageUri     *string                     `json:"next_page_uri,omitempty"`
			Page            *int                        `json:"page,omitempty"`
			PageSize        *int                        `json:"page_size,omitempty"`
			PreviousPageUri *string                     `json:"previous_page_uri,omitempty"`
			Recordings      *[]ApiV2010AccountRecording `json:"recordings,omitempty"`
			Start           *int                        `json:"start,omitempty"`
			Uri             *string                     `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListRecordingTranscription: GET /2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions.json

type ListRecordingTranscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                                              `json:"end,omitempty"`
		FirstPageUri    *string                                           `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                           `json:"next_page_uri,omitempty"`
		Page            *int                                              `json:"page,omitempty"`
		PageSize        *int                                              `json:"page_size,omitempty"`
		PreviousPageUri *string                                           `json:"previous_page_uri,omitempty"`
		Start           *int                                              `json:"start,omitempty"`
		Transcriptions  *[]ApiV2010AccountRecordingRecordingTranscription `json:"transcriptions,omitempty"`
		Uri             *string                                           `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRecordingTranscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRecordingTranscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListRecordingTranscriptionRequest generates requests for ListRecordingTranscription
func newListRecordingTranscriptionRequest(baseURL *url.URL, accountSid string, recordingSid string, params *ListRecordingTranscriptionParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("RecordingSid", recordingSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListRecordingTranscriptionFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListRecordingTranscription returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions.json
func (c *Client) ListRecordingTranscription(ctx context.Context, accountSid string, recordingSid string, params *ListRecordingTranscriptionParams, reqEditors ...client.RequestEditorFn) (*ListRecordingTranscriptionResponse, error) {
	req, err := newListRecordingTranscriptionRequest(c.BaseURL, accountSid, recordingSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListRecordingTranscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                                              `json:"end,omitempty"`
			FirstPageUri    *string                                           `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                           `json:"next_page_uri,omitempty"`
			Page            *int                                              `json:"page,omitempty"`
			PageSize        *int                                              `json:"page_size,omitempty"`
			PreviousPageUri *string                                           `json:"previous_page_uri,omitempty"`
			Start           *int                                              `json:"start,omitempty"`
			Transcriptions  *[]ApiV2010AccountRecordingRecordingTranscription `json:"transcriptions,omitempty"`
			Uri             *string                                           `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteRecordingTranscription: DELETE /2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions/{Sid}.json

type DeleteRecordingTranscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRecordingTranscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRecordingTranscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteRecordingTranscriptionRequest generates requests for DeleteRecordingTranscription
func newDeleteRecordingTranscriptionRequest(baseURL *url.URL, accountSid string, recordingSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("RecordingSid", recordingSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteRecordingTranscriptionFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteRecordingTranscription returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions/{Sid}.json
func (c *Client) DeleteRecordingTranscription(ctx context.Context, accountSid string, recordingSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteRecordingTranscriptionResponse, error) {
	req, err := newDeleteRecordingTranscriptionRequest(c.BaseURL, accountSid, recordingSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteRecordingTranscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchRecordingTranscription: GET /2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions/{Sid}.json

type FetchRecordingTranscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountRecordingRecordingTranscription
}

// Status returns HTTPResponse.Status
func (r FetchRecordingTranscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchRecordingTranscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchRecordingTranscriptionRequest generates requests for FetchRecordingTranscription
func newFetchRecordingTranscriptionRequest(baseURL *url.URL, accountSid string, recordingSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("RecordingSid", recordingSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchRecordingTranscriptionFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchRecordingTranscription returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Recordings/{RecordingSid}/Transcriptions/{Sid}.json
func (c *Client) FetchRecordingTranscription(ctx context.Context, accountSid string, recordingSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchRecordingTranscriptionResponse, error) {
	req, err := newFetchRecordingTranscriptionRequest(c.BaseURL, accountSid, recordingSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchRecordingTranscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountRecordingRecordingTranscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListRecordingAddOnResult: GET /2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults.json

type ListRecordingAddOnResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AddOnResults    *[]ApiV2010AccountRecordingRecordingAddOnResult `json:"add_on_results,omitempty"`
		End             *int                                            `json:"end,omitempty"`
		FirstPageUri    *string                                         `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                         `json:"next_page_uri,omitempty"`
		Page            *int                                            `json:"page,omitempty"`
		PageSize        *int                                            `json:"page_size,omitempty"`
		PreviousPageUri *string                                         `json:"previous_page_uri,omitempty"`
		Start           *int                                            `json:"start,omitempty"`
		Uri             *string                                         `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRecordingAddOnResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRecordingAddOnResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListRecordingAddOnResultRequest generates requests for ListRecordingAddOnResult
func newListRecordingAddOnResultRequest(baseURL *url.URL, accountSid string, referenceSid string, params *ListRecordingAddOnResultParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ReferenceSid", referenceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListRecordingAddOnResultFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListRecordingAddOnResult returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults.json
func (c *Client) ListRecordingAddOnResult(ctx context.Context, accountSid string, referenceSid string, params *ListRecordingAddOnResultParams, reqEditors ...client.RequestEditorFn) (*ListRecordingAddOnResultResponse, error) {
	req, err := newListRecordingAddOnResultRequest(c.BaseURL, accountSid, referenceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListRecordingAddOnResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AddOnResults    *[]ApiV2010AccountRecordingRecordingAddOnResult `json:"add_on_results,omitempty"`
			End             *int                                            `json:"end,omitempty"`
			FirstPageUri    *string                                         `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                         `json:"next_page_uri,omitempty"`
			Page            *int                                            `json:"page,omitempty"`
			PageSize        *int                                            `json:"page_size,omitempty"`
			PreviousPageUri *string                                         `json:"previous_page_uri,omitempty"`
			Start           *int                                            `json:"start,omitempty"`
			Uri             *string                                         `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListRecordingAddOnResultPayload: GET /2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads.json

type ListRecordingAddOnResultPayloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                                                                       `json:"end,omitempty"`
		FirstPageUri    *string                                                                    `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                                                    `json:"next_page_uri,omitempty"`
		Page            *int                                                                       `json:"page,omitempty"`
		PageSize        *int                                                                       `json:"page_size,omitempty"`
		Payloads        *[]ApiV2010AccountRecordingRecordingAddOnResultRecordingAddOnResultPayload `json:"payloads,omitempty"`
		PreviousPageUri *string                                                                    `json:"previous_page_uri,omitempty"`
		Start           *int                                                                       `json:"start,omitempty"`
		Uri             *string                                                                    `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListRecordingAddOnResultPayloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRecordingAddOnResultPayloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListRecordingAddOnResultPayloadRequest generates requests for ListRecordingAddOnResultPayload
func newListRecordingAddOnResultPayloadRequest(baseURL *url.URL, accountSid string, referenceSid string, addOnResultSid string, params *ListRecordingAddOnResultPayloadParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ReferenceSid", referenceSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("AddOnResultSid", addOnResultSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListRecordingAddOnResultPayloadFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListRecordingAddOnResultPayload returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads.json
func (c *Client) ListRecordingAddOnResultPayload(ctx context.Context, accountSid string, referenceSid string, addOnResultSid string, params *ListRecordingAddOnResultPayloadParams, reqEditors ...client.RequestEditorFn) (*ListRecordingAddOnResultPayloadResponse, error) {
	req, err := newListRecordingAddOnResultPayloadRequest(c.BaseURL, accountSid, referenceSid, addOnResultSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListRecordingAddOnResultPayloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                                                                       `json:"end,omitempty"`
			FirstPageUri    *string                                                                    `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                                                    `json:"next_page_uri,omitempty"`
			Page            *int                                                                       `json:"page,omitempty"`
			PageSize        *int                                                                       `json:"page_size,omitempty"`
			Payloads        *[]ApiV2010AccountRecordingRecordingAddOnResultRecordingAddOnResultPayload `json:"payloads,omitempty"`
			PreviousPageUri *string                                                                    `json:"previous_page_uri,omitempty"`
			Start           *int                                                                       `json:"start,omitempty"`
			Uri             *string                                                                    `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteRecordingAddOnResultPayload: DELETE /2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads/{Sid}.json

type DeleteRecordingAddOnResultPayloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRecordingAddOnResultPayloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRecordingAddOnResultPayloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteRecordingAddOnResultPayloadRequest generates requests for DeleteRecordingAddOnResultPayload
func newDeleteRecordingAddOnResultPayloadRequest(baseURL *url.URL, accountSid string, referenceSid string, addOnResultSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ReferenceSid", referenceSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("AddOnResultSid", addOnResultSid)
	if err != nil {
		return nil, err
	}

	pathParam3, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteRecordingAddOnResultPayloadFormat, pathParam0, pathParam1, pathParam2, pathParam3)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteRecordingAddOnResultPayload returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads/{Sid}.json
func (c *Client) DeleteRecordingAddOnResultPayload(ctx context.Context, accountSid string, referenceSid string, addOnResultSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteRecordingAddOnResultPayloadResponse, error) {
	req, err := newDeleteRecordingAddOnResultPayloadRequest(c.BaseURL, accountSid, referenceSid, addOnResultSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteRecordingAddOnResultPayloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchRecordingAddOnResultPayload: GET /2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads/{Sid}.json

type FetchRecordingAddOnResultPayloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountRecordingRecordingAddOnResultRecordingAddOnResultPayload
}

// Status returns HTTPResponse.Status
func (r FetchRecordingAddOnResultPayloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchRecordingAddOnResultPayloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchRecordingAddOnResultPayloadRequest generates requests for FetchRecordingAddOnResultPayload
func newFetchRecordingAddOnResultPayloadRequest(baseURL *url.URL, accountSid string, referenceSid string, addOnResultSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ReferenceSid", referenceSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("AddOnResultSid", addOnResultSid)
	if err != nil {
		return nil, err
	}

	pathParam3, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchRecordingAddOnResultPayloadFormat, pathParam0, pathParam1, pathParam2, pathParam3)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchRecordingAddOnResultPayload returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{AddOnResultSid}/Payloads/{Sid}.json
func (c *Client) FetchRecordingAddOnResultPayload(ctx context.Context, accountSid string, referenceSid string, addOnResultSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchRecordingAddOnResultPayloadResponse, error) {
	req, err := newFetchRecordingAddOnResultPayloadRequest(c.BaseURL, accountSid, referenceSid, addOnResultSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchRecordingAddOnResultPayloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountRecordingRecordingAddOnResultRecordingAddOnResultPayload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteRecordingAddOnResult: DELETE /2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{Sid}.json

type DeleteRecordingAddOnResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRecordingAddOnResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRecordingAddOnResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteRecordingAddOnResultRequest generates requests for DeleteRecordingAddOnResult
func newDeleteRecordingAddOnResultRequest(baseURL *url.URL, accountSid string, referenceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ReferenceSid", referenceSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteRecordingAddOnResultFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteRecordingAddOnResult returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{Sid}.json
func (c *Client) DeleteRecordingAddOnResult(ctx context.Context, accountSid string, referenceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteRecordingAddOnResultResponse, error) {
	req, err := newDeleteRecordingAddOnResultRequest(c.BaseURL, accountSid, referenceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteRecordingAddOnResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchRecordingAddOnResult: GET /2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{Sid}.json

type FetchRecordingAddOnResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountRecordingRecordingAddOnResult
}

// Status returns HTTPResponse.Status
func (r FetchRecordingAddOnResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchRecordingAddOnResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchRecordingAddOnResultRequest generates requests for FetchRecordingAddOnResult
func newFetchRecordingAddOnResultRequest(baseURL *url.URL, accountSid string, referenceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("ReferenceSid", referenceSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchRecordingAddOnResultFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchRecordingAddOnResult returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Recordings/{ReferenceSid}/AddOnResults/{Sid}.json
func (c *Client) FetchRecordingAddOnResult(ctx context.Context, accountSid string, referenceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchRecordingAddOnResultResponse, error) {
	req, err := newFetchRecordingAddOnResultRequest(c.BaseURL, accountSid, referenceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchRecordingAddOnResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountRecordingRecordingAddOnResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteRecording: DELETE /2010-04-01/Accounts/{AccountSid}/Recordings/{Sid}.json

type DeleteRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteRecordingRequest generates requests for DeleteRecording
func newDeleteRecordingRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteRecordingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteRecording returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/Recordings/{Sid}.json
func (c *Client) DeleteRecording(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteRecordingResponse, error) {
	req, err := newDeleteRecordingRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchRecording: GET /2010-04-01/Accounts/{AccountSid}/Recordings/{Sid}.json

type FetchRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountRecording
}

// Status returns HTTPResponse.Status
func (r FetchRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchRecordingRequest generates requests for FetchRecording
func newFetchRecordingRequest(baseURL *url.URL, accountSid string, sid string, params *FetchRecordingParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchRecordingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.IncludeSoftDeleted != nil {
		if err := client.AddQueryParam(q, "IncludeSoftDeleted", *params.IncludeSoftDeleted); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchRecording returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Recordings/{Sid}.json
func (c *Client) FetchRecording(ctx context.Context, accountSid string, sid string, params *FetchRecordingParams, reqEditors ...client.RequestEditorFn) (*FetchRecordingResponse, error) {
	req, err := newFetchRecordingRequest(c.BaseURL, accountSid, sid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountRecording
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSipCredentialList: GET /2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists.json

type ListSipCredentialListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CredentialLists *[]ApiV2010AccountSipSipCredentialList `json:"credential_lists,omitempty"`
		End             *int                                   `json:"end,omitempty"`
		FirstPageUri    *string                                `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                `json:"next_page_uri,omitempty"`
		Page            *int                                   `json:"page,omitempty"`
		PageSize        *int                                   `json:"page_size,omitempty"`
		PreviousPageUri *string                                `json:"previous_page_uri,omitempty"`
		Start           *int                                   `json:"start,omitempty"`
		Uri             *string                                `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSipCredentialListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSipCredentialListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSipCredentialListRequest generates requests for ListSipCredentialList
func newListSipCredentialListRequest(baseURL *url.URL, accountSid string, params *ListSipCredentialListParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSipCredentialListFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSipCredentialList returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists.json
func (c *Client) ListSipCredentialList(ctx context.Context, accountSid string, params *ListSipCredentialListParams, reqEditors ...client.RequestEditorFn) (*ListSipCredentialListResponse, error) {
	req, err := newListSipCredentialListRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSipCredentialListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CredentialLists *[]ApiV2010AccountSipSipCredentialList `json:"credential_lists,omitempty"`
			End             *int                                   `json:"end,omitempty"`
			FirstPageUri    *string                                `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                `json:"next_page_uri,omitempty"`
			Page            *int                                   `json:"page,omitempty"`
			PageSize        *int                                   `json:"page_size,omitempty"`
			PreviousPageUri *string                                `json:"previous_page_uri,omitempty"`
			Start           *int                                   `json:"start,omitempty"`
			Uri             *string                                `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSipCredentialList: POST /2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists.json

type CreateSipCredentialListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountSipSipCredentialList
}

// Status returns HTTPResponse.Status
func (r CreateSipCredentialListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSipCredentialListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSipCredentialListRequestWithBody generates requests for CreateSipCredentialList with any type of body
func newCreateSipCredentialListRequestWithBody(baseURL *url.URL, accountSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSipCredentialListFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSipCredentialListWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists.json
func (c *Client) CreateSipCredentialListWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSipCredentialListResponse, error) {
	req, err := newCreateSipCredentialListRequestWithBody(c.BaseURL, accountSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSipCredentialListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountSipSipCredentialList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListSipCredential: GET /2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials.json

type ListSipCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Credentials     *[]ApiV2010AccountSipSipCredentialListSipCredential `json:"credentials,omitempty"`
		End             *int                                                `json:"end,omitempty"`
		FirstPageUri    *string                                             `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                             `json:"next_page_uri,omitempty"`
		Page            *int                                                `json:"page,omitempty"`
		PageSize        *int                                                `json:"page_size,omitempty"`
		PreviousPageUri *string                                             `json:"previous_page_uri,omitempty"`
		Start           *int                                                `json:"start,omitempty"`
		Uri             *string                                             `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSipCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSipCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSipCredentialRequest generates requests for ListSipCredential
func newListSipCredentialRequest(baseURL *url.URL, accountSid string, credentialListSid string, params *ListSipCredentialParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CredentialListSid", credentialListSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSipCredentialFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSipCredential returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials.json
func (c *Client) ListSipCredential(ctx context.Context, accountSid string, credentialListSid string, params *ListSipCredentialParams, reqEditors ...client.RequestEditorFn) (*ListSipCredentialResponse, error) {
	req, err := newListSipCredentialRequest(c.BaseURL, accountSid, credentialListSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSipCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Credentials     *[]ApiV2010AccountSipSipCredentialListSipCredential `json:"credentials,omitempty"`
			End             *int                                                `json:"end,omitempty"`
			FirstPageUri    *string                                             `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                             `json:"next_page_uri,omitempty"`
			Page            *int                                                `json:"page,omitempty"`
			PageSize        *int                                                `json:"page_size,omitempty"`
			PreviousPageUri *string                                             `json:"previous_page_uri,omitempty"`
			Start           *int                                                `json:"start,omitempty"`
			Uri             *string                                             `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSipCredential: POST /2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials.json

type CreateSipCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountSipSipCredentialListSipCredential
}

// Status returns HTTPResponse.Status
func (r CreateSipCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSipCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSipCredentialRequestWithBody generates requests for CreateSipCredential with any type of body
func newCreateSipCredentialRequestWithBody(baseURL *url.URL, accountSid string, credentialListSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CredentialListSid", credentialListSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSipCredentialFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSipCredentialWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials.json
func (c *Client) CreateSipCredentialWithBody(ctx context.Context, accountSid string, credentialListSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSipCredentialResponse, error) {
	req, err := newCreateSipCredentialRequestWithBody(c.BaseURL, accountSid, credentialListSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSipCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountSipSipCredentialListSipCredential
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteSipCredential: DELETE /2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json

type DeleteSipCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSipCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSipCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSipCredentialRequest generates requests for DeleteSipCredential
func newDeleteSipCredentialRequest(baseURL *url.URL, accountSid string, credentialListSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CredentialListSid", credentialListSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSipCredentialFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSipCredential returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json
func (c *Client) DeleteSipCredential(ctx context.Context, accountSid string, credentialListSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSipCredentialResponse, error) {
	req, err := newDeleteSipCredentialRequest(c.BaseURL, accountSid, credentialListSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSipCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSipCredential: GET /2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json

type FetchSipCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountSipSipCredentialListSipCredential
}

// Status returns HTTPResponse.Status
func (r FetchSipCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSipCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSipCredentialRequest generates requests for FetchSipCredential
func newFetchSipCredentialRequest(baseURL *url.URL, accountSid string, credentialListSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CredentialListSid", credentialListSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSipCredentialFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSipCredential returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json
func (c *Client) FetchSipCredential(ctx context.Context, accountSid string, credentialListSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSipCredentialResponse, error) {
	req, err := newFetchSipCredentialRequest(c.BaseURL, accountSid, credentialListSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSipCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountSipSipCredentialListSipCredential
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSipCredential: POST /2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json

type UpdateSipCredentialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountSipSipCredentialListSipCredential
}

// Status returns HTTPResponse.Status
func (r UpdateSipCredentialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSipCredentialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSipCredentialRequestWithBody generates requests for UpdateSipCredential with any type of body
func newUpdateSipCredentialRequestWithBody(baseURL *url.URL, accountSid string, credentialListSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("CredentialListSid", credentialListSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSipCredentialFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSipCredentialWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json
func (c *Client) UpdateSipCredentialWithBody(ctx context.Context, accountSid string, credentialListSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSipCredentialResponse, error) {
	req, err := newUpdateSipCredentialRequestWithBody(c.BaseURL, accountSid, credentialListSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSipCredentialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountSipSipCredentialListSipCredential
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteSipCredentialList: DELETE /2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{Sid}.json

type DeleteSipCredentialListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSipCredentialListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSipCredentialListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSipCredentialListRequest generates requests for DeleteSipCredentialList
func newDeleteSipCredentialListRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSipCredentialListFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSipCredentialList returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{Sid}.json
func (c *Client) DeleteSipCredentialList(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSipCredentialListResponse, error) {
	req, err := newDeleteSipCredentialListRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSipCredentialListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSipCredentialList: GET /2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{Sid}.json

type FetchSipCredentialListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountSipSipCredentialList
}

// Status returns HTTPResponse.Status
func (r FetchSipCredentialListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSipCredentialListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSipCredentialListRequest generates requests for FetchSipCredentialList
func newFetchSipCredentialListRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSipCredentialListFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSipCredentialList returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{Sid}.json
func (c *Client) FetchSipCredentialList(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSipCredentialListResponse, error) {
	req, err := newFetchSipCredentialListRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSipCredentialListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountSipSipCredentialList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSipCredentialList: POST /2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{Sid}.json

type UpdateSipCredentialListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountSipSipCredentialList
}

// Status returns HTTPResponse.Status
func (r UpdateSipCredentialListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSipCredentialListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSipCredentialListRequestWithBody generates requests for UpdateSipCredentialList with any type of body
func newUpdateSipCredentialListRequestWithBody(baseURL *url.URL, accountSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSipCredentialListFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSipCredentialListWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{Sid}.json
func (c *Client) UpdateSipCredentialListWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSipCredentialListResponse, error) {
	req, err := newUpdateSipCredentialListRequestWithBody(c.BaseURL, accountSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSipCredentialListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountSipSipCredentialList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSipDomain: GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains.json

type ListSipDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Domains         *[]ApiV2010AccountSipSipDomain `json:"domains,omitempty"`
		End             *int                           `json:"end,omitempty"`
		FirstPageUri    *string                        `json:"first_page_uri,omitempty"`
		NextPageUri     *string                        `json:"next_page_uri,omitempty"`
		Page            *int                           `json:"page,omitempty"`
		PageSize        *int                           `json:"page_size,omitempty"`
		PreviousPageUri *string                        `json:"previous_page_uri,omitempty"`
		Start           *int                           `json:"start,omitempty"`
		Uri             *string                        `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSipDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSipDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSipDomainRequest generates requests for ListSipDomain
func newListSipDomainRequest(baseURL *url.URL, accountSid string, params *ListSipDomainParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSipDomainFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSipDomain returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains.json
func (c *Client) ListSipDomain(ctx context.Context, accountSid string, params *ListSipDomainParams, reqEditors ...client.RequestEditorFn) (*ListSipDomainResponse, error) {
	req, err := newListSipDomainRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSipDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Domains         *[]ApiV2010AccountSipSipDomain `json:"domains,omitempty"`
			End             *int                           `json:"end,omitempty"`
			FirstPageUri    *string                        `json:"first_page_uri,omitempty"`
			NextPageUri     *string                        `json:"next_page_uri,omitempty"`
			Page            *int                           `json:"page,omitempty"`
			PageSize        *int                           `json:"page_size,omitempty"`
			PreviousPageUri *string                        `json:"previous_page_uri,omitempty"`
			Start           *int                           `json:"start,omitempty"`
			Uri             *string                        `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSipDomain: POST /2010-04-01/Accounts/{AccountSid}/SIP/Domains.json

type CreateSipDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountSipSipDomain
}

// Status returns HTTPResponse.Status
func (r CreateSipDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSipDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSipDomainRequestWithBody generates requests for CreateSipDomain with any type of body
func newCreateSipDomainRequestWithBody(baseURL *url.URL, accountSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSipDomainFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSipDomainWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/SIP/Domains.json
func (c *Client) CreateSipDomainWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSipDomainResponse, error) {
	req, err := newCreateSipDomainRequestWithBody(c.BaseURL, accountSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSipDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountSipSipDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListSipAuthCallsCredentialListMapping: GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings.json

type ListSipAuthCallsCredentialListMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Contents        *[]ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping `json:"contents,omitempty"`
		End             *int                                                                               `json:"end,omitempty"`
		FirstPageUri    *string                                                                            `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                                                            `json:"next_page_uri,omitempty"`
		Page            *int                                                                               `json:"page,omitempty"`
		PageSize        *int                                                                               `json:"page_size,omitempty"`
		PreviousPageUri *string                                                                            `json:"previous_page_uri,omitempty"`
		Start           *int                                                                               `json:"start,omitempty"`
		Uri             *string                                                                            `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSipAuthCallsCredentialListMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSipAuthCallsCredentialListMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSipAuthCallsCredentialListMappingRequest generates requests for ListSipAuthCallsCredentialListMapping
func newListSipAuthCallsCredentialListMappingRequest(baseURL *url.URL, accountSid string, domainSid string, params *ListSipAuthCallsCredentialListMappingParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DomainSid", domainSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSipAuthCallsCredentialListMappingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSipAuthCallsCredentialListMapping returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings.json
func (c *Client) ListSipAuthCallsCredentialListMapping(ctx context.Context, accountSid string, domainSid string, params *ListSipAuthCallsCredentialListMappingParams, reqEditors ...client.RequestEditorFn) (*ListSipAuthCallsCredentialListMappingResponse, error) {
	req, err := newListSipAuthCallsCredentialListMappingRequest(c.BaseURL, accountSid, domainSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSipAuthCallsCredentialListMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Contents        *[]ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping `json:"contents,omitempty"`
			End             *int                                                                               `json:"end,omitempty"`
			FirstPageUri    *string                                                                            `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                                                            `json:"next_page_uri,omitempty"`
			Page            *int                                                                               `json:"page,omitempty"`
			PageSize        *int                                                                               `json:"page_size,omitempty"`
			PreviousPageUri *string                                                                            `json:"previous_page_uri,omitempty"`
			Start           *int                                                                               `json:"start,omitempty"`
			Uri             *string                                                                            `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSipAuthCallsCredentialListMapping: POST /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings.json

type CreateSipAuthCallsCredentialListMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping
}

// Status returns HTTPResponse.Status
func (r CreateSipAuthCallsCredentialListMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSipAuthCallsCredentialListMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSipAuthCallsCredentialListMappingRequestWithBody generates requests for CreateSipAuthCallsCredentialListMapping with any type of body
func newCreateSipAuthCallsCredentialListMappingRequestWithBody(baseURL *url.URL, accountSid string, domainSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DomainSid", domainSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSipAuthCallsCredentialListMappingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSipAuthCallsCredentialListMappingWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings.json
func (c *Client) CreateSipAuthCallsCredentialListMappingWithBody(ctx context.Context, accountSid string, domainSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSipAuthCallsCredentialListMappingResponse, error) {
	req, err := newCreateSipAuthCallsCredentialListMappingRequestWithBody(c.BaseURL, accountSid, domainSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSipAuthCallsCredentialListMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteSipAuthCallsCredentialListMapping: DELETE /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings/{Sid}.json

type DeleteSipAuthCallsCredentialListMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSipAuthCallsCredentialListMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSipAuthCallsCredentialListMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSipAuthCallsCredentialListMappingRequest generates requests for DeleteSipAuthCallsCredentialListMapping
func newDeleteSipAuthCallsCredentialListMappingRequest(baseURL *url.URL, accountSid string, domainSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DomainSid", domainSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSipAuthCallsCredentialListMappingFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSipAuthCallsCredentialListMapping returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings/{Sid}.json
func (c *Client) DeleteSipAuthCallsCredentialListMapping(ctx context.Context, accountSid string, domainSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSipAuthCallsCredentialListMappingResponse, error) {
	req, err := newDeleteSipAuthCallsCredentialListMappingRequest(c.BaseURL, accountSid, domainSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSipAuthCallsCredentialListMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSipAuthCallsCredentialListMapping: GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings/{Sid}.json

type FetchSipAuthCallsCredentialListMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping
}

// Status returns HTTPResponse.Status
func (r FetchSipAuthCallsCredentialListMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSipAuthCallsCredentialListMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSipAuthCallsCredentialListMappingRequest generates requests for FetchSipAuthCallsCredentialListMapping
func newFetchSipAuthCallsCredentialListMappingRequest(baseURL *url.URL, accountSid string, domainSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DomainSid", domainSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSipAuthCallsCredentialListMappingFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSipAuthCallsCredentialListMapping returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/CredentialListMappings/{Sid}.json
func (c *Client) FetchSipAuthCallsCredentialListMapping(ctx context.Context, accountSid string, domainSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSipAuthCallsCredentialListMappingResponse, error) {
	req, err := newFetchSipAuthCallsCredentialListMappingRequest(c.BaseURL, accountSid, domainSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSipAuthCallsCredentialListMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsCredentialListMapping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSipAuthCallsIpAccessControlListMapping: GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings.json

type ListSipAuthCallsIpAccessControlListMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Contents        *[]ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping `json:"contents,omitempty"`
		End             *int                                                                                    `json:"end,omitempty"`
		FirstPageUri    *string                                                                                 `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                                                                 `json:"next_page_uri,omitempty"`
		Page            *int                                                                                    `json:"page,omitempty"`
		PageSize        *int                                                                                    `json:"page_size,omitempty"`
		PreviousPageUri *string                                                                                 `json:"previous_page_uri,omitempty"`
		Start           *int                                                                                    `json:"start,omitempty"`
		Uri             *string                                                                                 `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSipAuthCallsIpAccessControlListMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSipAuthCallsIpAccessControlListMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSipAuthCallsIpAccessControlListMappingRequest generates requests for ListSipAuthCallsIpAccessControlListMapping
func newListSipAuthCallsIpAccessControlListMappingRequest(baseURL *url.URL, accountSid string, domainSid string, params *ListSipAuthCallsIpAccessControlListMappingParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DomainSid", domainSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSipAuthCallsIpAccessControlListMappingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSipAuthCallsIpAccessControlListMapping returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings.json
func (c *Client) ListSipAuthCallsIpAccessControlListMapping(ctx context.Context, accountSid string, domainSid string, params *ListSipAuthCallsIpAccessControlListMappingParams, reqEditors ...client.RequestEditorFn) (*ListSipAuthCallsIpAccessControlListMappingResponse, error) {
	req, err := newListSipAuthCallsIpAccessControlListMappingRequest(c.BaseURL, accountSid, domainSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSipAuthCallsIpAccessControlListMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Contents        *[]ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping `json:"contents,omitempty"`
			End             *int                                                                                    `json:"end,omitempty"`
			FirstPageUri    *string                                                                                 `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                                                                 `json:"next_page_uri,omitempty"`
			Page            *int                                                                                    `json:"page,omitempty"`
			PageSize        *int                                                                                    `json:"page_size,omitempty"`
			PreviousPageUri *string                                                                                 `json:"previous_page_uri,omitempty"`
			Start           *int                                                                                    `json:"start,omitempty"`
			Uri             *string                                                                                 `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSipAuthCallsIpAccessControlListMapping: POST /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings.json

type CreateSipAuthCallsIpAccessControlListMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping
}

// Status returns HTTPResponse.Status
func (r CreateSipAuthCallsIpAccessControlListMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSipAuthCallsIpAccessControlListMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSipAuthCallsIpAccessControlListMappingRequestWithBody generates requests for CreateSipAuthCallsIpAccessControlListMapping with any type of body
func newCreateSipAuthCallsIpAccessControlListMappingRequestWithBody(baseURL *url.URL, accountSid string, domainSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DomainSid", domainSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSipAuthCallsIpAccessControlListMappingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSipAuthCallsIpAccessControlListMappingWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings.json
func (c *Client) CreateSipAuthCallsIpAccessControlListMappingWithBody(ctx context.Context, accountSid string, domainSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSipAuthCallsIpAccessControlListMappingResponse, error) {
	req, err := newCreateSipAuthCallsIpAccessControlListMappingRequestWithBody(c.BaseURL, accountSid, domainSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSipAuthCallsIpAccessControlListMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteSipAuthCallsIpAccessControlListMapping: DELETE /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings/{Sid}.json

type DeleteSipAuthCallsIpAccessControlListMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSipAuthCallsIpAccessControlListMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSipAuthCallsIpAccessControlListMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSipAuthCallsIpAccessControlListMappingRequest generates requests for DeleteSipAuthCallsIpAccessControlListMapping
func newDeleteSipAuthCallsIpAccessControlListMappingRequest(baseURL *url.URL, accountSid string, domainSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DomainSid", domainSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSipAuthCallsIpAccessControlListMappingFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSipAuthCallsIpAccessControlListMapping returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings/{Sid}.json
func (c *Client) DeleteSipAuthCallsIpAccessControlListMapping(ctx context.Context, accountSid string, domainSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSipAuthCallsIpAccessControlListMappingResponse, error) {
	req, err := newDeleteSipAuthCallsIpAccessControlListMappingRequest(c.BaseURL, accountSid, domainSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSipAuthCallsIpAccessControlListMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSipAuthCallsIpAccessControlListMapping: GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings/{Sid}.json

type FetchSipAuthCallsIpAccessControlListMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping
}

// Status returns HTTPResponse.Status
func (r FetchSipAuthCallsIpAccessControlListMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSipAuthCallsIpAccessControlListMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSipAuthCallsIpAccessControlListMappingRequest generates requests for FetchSipAuthCallsIpAccessControlListMapping
func newFetchSipAuthCallsIpAccessControlListMappingRequest(baseURL *url.URL, accountSid string, domainSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DomainSid", domainSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSipAuthCallsIpAccessControlListMappingFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSipAuthCallsIpAccessControlListMapping returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Calls/IpAccessControlListMappings/{Sid}.json
func (c *Client) FetchSipAuthCallsIpAccessControlListMapping(ctx context.Context, accountSid string, domainSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSipAuthCallsIpAccessControlListMappingResponse, error) {
	req, err := newFetchSipAuthCallsIpAccessControlListMappingRequest(c.BaseURL, accountSid, domainSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSipAuthCallsIpAccessControlListMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountSipSipDomainSipAuthSipAuthCallsSipAuthCallsIpAccessControlListMapping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSipAuthRegistrationsCredentialListMapping: GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings.json

type ListSipAuthRegistrationsCredentialListMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Contents        *[]ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping `json:"contents,omitempty"`
		End             *int                                                                                               `json:"end,omitempty"`
		FirstPageUri    *string                                                                                            `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                                                                            `json:"next_page_uri,omitempty"`
		Page            *int                                                                                               `json:"page,omitempty"`
		PageSize        *int                                                                                               `json:"page_size,omitempty"`
		PreviousPageUri *string                                                                                            `json:"previous_page_uri,omitempty"`
		Start           *int                                                                                               `json:"start,omitempty"`
		Uri             *string                                                                                            `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSipAuthRegistrationsCredentialListMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSipAuthRegistrationsCredentialListMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSipAuthRegistrationsCredentialListMappingRequest generates requests for ListSipAuthRegistrationsCredentialListMapping
func newListSipAuthRegistrationsCredentialListMappingRequest(baseURL *url.URL, accountSid string, domainSid string, params *ListSipAuthRegistrationsCredentialListMappingParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DomainSid", domainSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSipAuthRegistrationsCredentialListMappingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSipAuthRegistrationsCredentialListMapping returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings.json
func (c *Client) ListSipAuthRegistrationsCredentialListMapping(ctx context.Context, accountSid string, domainSid string, params *ListSipAuthRegistrationsCredentialListMappingParams, reqEditors ...client.RequestEditorFn) (*ListSipAuthRegistrationsCredentialListMappingResponse, error) {
	req, err := newListSipAuthRegistrationsCredentialListMappingRequest(c.BaseURL, accountSid, domainSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSipAuthRegistrationsCredentialListMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Contents        *[]ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping `json:"contents,omitempty"`
			End             *int                                                                                               `json:"end,omitempty"`
			FirstPageUri    *string                                                                                            `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                                                                            `json:"next_page_uri,omitempty"`
			Page            *int                                                                                               `json:"page,omitempty"`
			PageSize        *int                                                                                               `json:"page_size,omitempty"`
			PreviousPageUri *string                                                                                            `json:"previous_page_uri,omitempty"`
			Start           *int                                                                                               `json:"start,omitempty"`
			Uri             *string                                                                                            `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSipAuthRegistrationsCredentialListMapping: POST /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings.json

type CreateSipAuthRegistrationsCredentialListMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping
}

// Status returns HTTPResponse.Status
func (r CreateSipAuthRegistrationsCredentialListMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSipAuthRegistrationsCredentialListMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSipAuthRegistrationsCredentialListMappingRequestWithBody generates requests for CreateSipAuthRegistrationsCredentialListMapping with any type of body
func newCreateSipAuthRegistrationsCredentialListMappingRequestWithBody(baseURL *url.URL, accountSid string, domainSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DomainSid", domainSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSipAuthRegistrationsCredentialListMappingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSipAuthRegistrationsCredentialListMappingWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings.json
func (c *Client) CreateSipAuthRegistrationsCredentialListMappingWithBody(ctx context.Context, accountSid string, domainSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSipAuthRegistrationsCredentialListMappingResponse, error) {
	req, err := newCreateSipAuthRegistrationsCredentialListMappingRequestWithBody(c.BaseURL, accountSid, domainSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSipAuthRegistrationsCredentialListMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteSipAuthRegistrationsCredentialListMapping: DELETE /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings/{Sid}.json

type DeleteSipAuthRegistrationsCredentialListMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSipAuthRegistrationsCredentialListMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSipAuthRegistrationsCredentialListMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSipAuthRegistrationsCredentialListMappingRequest generates requests for DeleteSipAuthRegistrationsCredentialListMapping
func newDeleteSipAuthRegistrationsCredentialListMappingRequest(baseURL *url.URL, accountSid string, domainSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DomainSid", domainSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSipAuthRegistrationsCredentialListMappingFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSipAuthRegistrationsCredentialListMapping returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings/{Sid}.json
func (c *Client) DeleteSipAuthRegistrationsCredentialListMapping(ctx context.Context, accountSid string, domainSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSipAuthRegistrationsCredentialListMappingResponse, error) {
	req, err := newDeleteSipAuthRegistrationsCredentialListMappingRequest(c.BaseURL, accountSid, domainSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSipAuthRegistrationsCredentialListMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSipAuthRegistrationsCredentialListMapping: GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings/{Sid}.json

type FetchSipAuthRegistrationsCredentialListMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping
}

// Status returns HTTPResponse.Status
func (r FetchSipAuthRegistrationsCredentialListMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSipAuthRegistrationsCredentialListMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSipAuthRegistrationsCredentialListMappingRequest generates requests for FetchSipAuthRegistrationsCredentialListMapping
func newFetchSipAuthRegistrationsCredentialListMappingRequest(baseURL *url.URL, accountSid string, domainSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DomainSid", domainSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSipAuthRegistrationsCredentialListMappingFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSipAuthRegistrationsCredentialListMapping returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/Auth/Registrations/CredentialListMappings/{Sid}.json
func (c *Client) FetchSipAuthRegistrationsCredentialListMapping(ctx context.Context, accountSid string, domainSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSipAuthRegistrationsCredentialListMappingResponse, error) {
	req, err := newFetchSipAuthRegistrationsCredentialListMappingRequest(c.BaseURL, accountSid, domainSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSipAuthRegistrationsCredentialListMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountSipSipDomainSipAuthSipAuthRegistrationsSipAuthRegistrationsCredentialListMapping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSipCredentialListMapping: GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings.json

type ListSipCredentialListMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CredentialListMappings *[]ApiV2010AccountSipSipDomainSipCredentialListMapping `json:"credential_list_mappings,omitempty"`
		End                    *int                                                   `json:"end,omitempty"`
		FirstPageUri           *string                                                `json:"first_page_uri,omitempty"`
		NextPageUri            *string                                                `json:"next_page_uri,omitempty"`
		Page                   *int                                                   `json:"page,omitempty"`
		PageSize               *int                                                   `json:"page_size,omitempty"`
		PreviousPageUri        *string                                                `json:"previous_page_uri,omitempty"`
		Start                  *int                                                   `json:"start,omitempty"`
		Uri                    *string                                                `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSipCredentialListMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSipCredentialListMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSipCredentialListMappingRequest generates requests for ListSipCredentialListMapping
func newListSipCredentialListMappingRequest(baseURL *url.URL, accountSid string, domainSid string, params *ListSipCredentialListMappingParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DomainSid", domainSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSipCredentialListMappingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSipCredentialListMapping returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings.json
func (c *Client) ListSipCredentialListMapping(ctx context.Context, accountSid string, domainSid string, params *ListSipCredentialListMappingParams, reqEditors ...client.RequestEditorFn) (*ListSipCredentialListMappingResponse, error) {
	req, err := newListSipCredentialListMappingRequest(c.BaseURL, accountSid, domainSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSipCredentialListMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CredentialListMappings *[]ApiV2010AccountSipSipDomainSipCredentialListMapping `json:"credential_list_mappings,omitempty"`
			End                    *int                                                   `json:"end,omitempty"`
			FirstPageUri           *string                                                `json:"first_page_uri,omitempty"`
			NextPageUri            *string                                                `json:"next_page_uri,omitempty"`
			Page                   *int                                                   `json:"page,omitempty"`
			PageSize               *int                                                   `json:"page_size,omitempty"`
			PreviousPageUri        *string                                                `json:"previous_page_uri,omitempty"`
			Start                  *int                                                   `json:"start,omitempty"`
			Uri                    *string                                                `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSipCredentialListMapping: POST /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings.json

type CreateSipCredentialListMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountSipSipDomainSipCredentialListMapping
}

// Status returns HTTPResponse.Status
func (r CreateSipCredentialListMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSipCredentialListMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSipCredentialListMappingRequestWithBody generates requests for CreateSipCredentialListMapping with any type of body
func newCreateSipCredentialListMappingRequestWithBody(baseURL *url.URL, accountSid string, domainSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DomainSid", domainSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSipCredentialListMappingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSipCredentialListMappingWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings.json
func (c *Client) CreateSipCredentialListMappingWithBody(ctx context.Context, accountSid string, domainSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSipCredentialListMappingResponse, error) {
	req, err := newCreateSipCredentialListMappingRequestWithBody(c.BaseURL, accountSid, domainSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSipCredentialListMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountSipSipDomainSipCredentialListMapping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteSipCredentialListMapping: DELETE /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings/{Sid}.json

type DeleteSipCredentialListMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSipCredentialListMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSipCredentialListMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSipCredentialListMappingRequest generates requests for DeleteSipCredentialListMapping
func newDeleteSipCredentialListMappingRequest(baseURL *url.URL, accountSid string, domainSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DomainSid", domainSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSipCredentialListMappingFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSipCredentialListMapping returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings/{Sid}.json
func (c *Client) DeleteSipCredentialListMapping(ctx context.Context, accountSid string, domainSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSipCredentialListMappingResponse, error) {
	req, err := newDeleteSipCredentialListMappingRequest(c.BaseURL, accountSid, domainSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSipCredentialListMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSipCredentialListMapping: GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings/{Sid}.json

type FetchSipCredentialListMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountSipSipDomainSipCredentialListMapping
}

// Status returns HTTPResponse.Status
func (r FetchSipCredentialListMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSipCredentialListMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSipCredentialListMappingRequest generates requests for FetchSipCredentialListMapping
func newFetchSipCredentialListMappingRequest(baseURL *url.URL, accountSid string, domainSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DomainSid", domainSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSipCredentialListMappingFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSipCredentialListMapping returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/CredentialListMappings/{Sid}.json
func (c *Client) FetchSipCredentialListMapping(ctx context.Context, accountSid string, domainSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSipCredentialListMappingResponse, error) {
	req, err := newFetchSipCredentialListMappingRequest(c.BaseURL, accountSid, domainSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSipCredentialListMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountSipSipDomainSipCredentialListMapping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSipIpAccessControlListMapping: GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings.json

type ListSipIpAccessControlListMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End                         *int                                                        `json:"end,omitempty"`
		FirstPageUri                *string                                                     `json:"first_page_uri,omitempty"`
		IpAccessControlListMappings *[]ApiV2010AccountSipSipDomainSipIpAccessControlListMapping `json:"ip_access_control_list_mappings,omitempty"`
		NextPageUri                 *string                                                     `json:"next_page_uri,omitempty"`
		Page                        *int                                                        `json:"page,omitempty"`
		PageSize                    *int                                                        `json:"page_size,omitempty"`
		PreviousPageUri             *string                                                     `json:"previous_page_uri,omitempty"`
		Start                       *int                                                        `json:"start,omitempty"`
		Uri                         *string                                                     `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSipIpAccessControlListMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSipIpAccessControlListMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSipIpAccessControlListMappingRequest generates requests for ListSipIpAccessControlListMapping
func newListSipIpAccessControlListMappingRequest(baseURL *url.URL, accountSid string, domainSid string, params *ListSipIpAccessControlListMappingParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DomainSid", domainSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSipIpAccessControlListMappingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSipIpAccessControlListMapping returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings.json
func (c *Client) ListSipIpAccessControlListMapping(ctx context.Context, accountSid string, domainSid string, params *ListSipIpAccessControlListMappingParams, reqEditors ...client.RequestEditorFn) (*ListSipIpAccessControlListMappingResponse, error) {
	req, err := newListSipIpAccessControlListMappingRequest(c.BaseURL, accountSid, domainSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSipIpAccessControlListMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End                         *int                                                        `json:"end,omitempty"`
			FirstPageUri                *string                                                     `json:"first_page_uri,omitempty"`
			IpAccessControlListMappings *[]ApiV2010AccountSipSipDomainSipIpAccessControlListMapping `json:"ip_access_control_list_mappings,omitempty"`
			NextPageUri                 *string                                                     `json:"next_page_uri,omitempty"`
			Page                        *int                                                        `json:"page,omitempty"`
			PageSize                    *int                                                        `json:"page_size,omitempty"`
			PreviousPageUri             *string                                                     `json:"previous_page_uri,omitempty"`
			Start                       *int                                                        `json:"start,omitempty"`
			Uri                         *string                                                     `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSipIpAccessControlListMapping: POST /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings.json

type CreateSipIpAccessControlListMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountSipSipDomainSipIpAccessControlListMapping
}

// Status returns HTTPResponse.Status
func (r CreateSipIpAccessControlListMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSipIpAccessControlListMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSipIpAccessControlListMappingRequestWithBody generates requests for CreateSipIpAccessControlListMapping with any type of body
func newCreateSipIpAccessControlListMappingRequestWithBody(baseURL *url.URL, accountSid string, domainSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DomainSid", domainSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSipIpAccessControlListMappingFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSipIpAccessControlListMappingWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings.json
func (c *Client) CreateSipIpAccessControlListMappingWithBody(ctx context.Context, accountSid string, domainSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSipIpAccessControlListMappingResponse, error) {
	req, err := newCreateSipIpAccessControlListMappingRequestWithBody(c.BaseURL, accountSid, domainSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSipIpAccessControlListMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountSipSipDomainSipIpAccessControlListMapping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteSipIpAccessControlListMapping: DELETE /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings/{Sid}.json

type DeleteSipIpAccessControlListMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSipIpAccessControlListMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSipIpAccessControlListMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSipIpAccessControlListMappingRequest generates requests for DeleteSipIpAccessControlListMapping
func newDeleteSipIpAccessControlListMappingRequest(baseURL *url.URL, accountSid string, domainSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DomainSid", domainSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSipIpAccessControlListMappingFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSipIpAccessControlListMapping returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings/{Sid}.json
func (c *Client) DeleteSipIpAccessControlListMapping(ctx context.Context, accountSid string, domainSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSipIpAccessControlListMappingResponse, error) {
	req, err := newDeleteSipIpAccessControlListMappingRequest(c.BaseURL, accountSid, domainSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSipIpAccessControlListMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSipIpAccessControlListMapping: GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings/{Sid}.json

type FetchSipIpAccessControlListMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountSipSipDomainSipIpAccessControlListMapping
}

// Status returns HTTPResponse.Status
func (r FetchSipIpAccessControlListMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSipIpAccessControlListMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSipIpAccessControlListMappingRequest generates requests for FetchSipIpAccessControlListMapping
func newFetchSipIpAccessControlListMappingRequest(baseURL *url.URL, accountSid string, domainSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("DomainSid", domainSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSipIpAccessControlListMappingFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSipIpAccessControlListMapping returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{DomainSid}/IpAccessControlListMappings/{Sid}.json
func (c *Client) FetchSipIpAccessControlListMapping(ctx context.Context, accountSid string, domainSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSipIpAccessControlListMappingResponse, error) {
	req, err := newFetchSipIpAccessControlListMappingRequest(c.BaseURL, accountSid, domainSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSipIpAccessControlListMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountSipSipDomainSipIpAccessControlListMapping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteSipDomain: DELETE /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{Sid}.json

type DeleteSipDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSipDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSipDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSipDomainRequest generates requests for DeleteSipDomain
func newDeleteSipDomainRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSipDomainFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSipDomain returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{Sid}.json
func (c *Client) DeleteSipDomain(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSipDomainResponse, error) {
	req, err := newDeleteSipDomainRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSipDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSipDomain: GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{Sid}.json

type FetchSipDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountSipSipDomain
}

// Status returns HTTPResponse.Status
func (r FetchSipDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSipDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSipDomainRequest generates requests for FetchSipDomain
func newFetchSipDomainRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSipDomainFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSipDomain returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{Sid}.json
func (c *Client) FetchSipDomain(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSipDomainResponse, error) {
	req, err := newFetchSipDomainRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSipDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountSipSipDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSipDomain: POST /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{Sid}.json

type UpdateSipDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountSipSipDomain
}

// Status returns HTTPResponse.Status
func (r UpdateSipDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSipDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSipDomainRequestWithBody generates requests for UpdateSipDomain with any type of body
func newUpdateSipDomainRequestWithBody(baseURL *url.URL, accountSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSipDomainFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSipDomainWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/SIP/Domains/{Sid}.json
func (c *Client) UpdateSipDomainWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSipDomainResponse, error) {
	req, err := newUpdateSipDomainRequestWithBody(c.BaseURL, accountSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSipDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountSipSipDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSipIpAccessControlList: GET /2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists.json

type ListSipIpAccessControlListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End                  *int                                        `json:"end,omitempty"`
		FirstPageUri         *string                                     `json:"first_page_uri,omitempty"`
		IpAccessControlLists *[]ApiV2010AccountSipSipIpAccessControlList `json:"ip_access_control_lists,omitempty"`
		NextPageUri          *string                                     `json:"next_page_uri,omitempty"`
		Page                 *int                                        `json:"page,omitempty"`
		PageSize             *int                                        `json:"page_size,omitempty"`
		PreviousPageUri      *string                                     `json:"previous_page_uri,omitempty"`
		Start                *int                                        `json:"start,omitempty"`
		Uri                  *string                                     `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSipIpAccessControlListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSipIpAccessControlListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSipIpAccessControlListRequest generates requests for ListSipIpAccessControlList
func newListSipIpAccessControlListRequest(baseURL *url.URL, accountSid string, params *ListSipIpAccessControlListParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSipIpAccessControlListFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSipIpAccessControlList returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists.json
func (c *Client) ListSipIpAccessControlList(ctx context.Context, accountSid string, params *ListSipIpAccessControlListParams, reqEditors ...client.RequestEditorFn) (*ListSipIpAccessControlListResponse, error) {
	req, err := newListSipIpAccessControlListRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSipIpAccessControlListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End                  *int                                        `json:"end,omitempty"`
			FirstPageUri         *string                                     `json:"first_page_uri,omitempty"`
			IpAccessControlLists *[]ApiV2010AccountSipSipIpAccessControlList `json:"ip_access_control_lists,omitempty"`
			NextPageUri          *string                                     `json:"next_page_uri,omitempty"`
			Page                 *int                                        `json:"page,omitempty"`
			PageSize             *int                                        `json:"page_size,omitempty"`
			PreviousPageUri      *string                                     `json:"previous_page_uri,omitempty"`
			Start                *int                                        `json:"start,omitempty"`
			Uri                  *string                                     `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSipIpAccessControlList: POST /2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists.json

type CreateSipIpAccessControlListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountSipSipIpAccessControlList
}

// Status returns HTTPResponse.Status
func (r CreateSipIpAccessControlListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSipIpAccessControlListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSipIpAccessControlListRequestWithBody generates requests for CreateSipIpAccessControlList with any type of body
func newCreateSipIpAccessControlListRequestWithBody(baseURL *url.URL, accountSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSipIpAccessControlListFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSipIpAccessControlListWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists.json
func (c *Client) CreateSipIpAccessControlListWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSipIpAccessControlListResponse, error) {
	req, err := newCreateSipIpAccessControlListRequestWithBody(c.BaseURL, accountSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSipIpAccessControlListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountSipSipIpAccessControlList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListSipIpAddress: GET /2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses.json

type ListSipIpAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                                                    `json:"end,omitempty"`
		FirstPageUri    *string                                                 `json:"first_page_uri,omitempty"`
		IpAddresses     *[]ApiV2010AccountSipSipIpAccessControlListSipIpAddress `json:"ip_addresses,omitempty"`
		NextPageUri     *string                                                 `json:"next_page_uri,omitempty"`
		Page            *int                                                    `json:"page,omitempty"`
		PageSize        *int                                                    `json:"page_size,omitempty"`
		PreviousPageUri *string                                                 `json:"previous_page_uri,omitempty"`
		Start           *int                                                    `json:"start,omitempty"`
		Uri             *string                                                 `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSipIpAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSipIpAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSipIpAddressRequest generates requests for ListSipIpAddress
func newListSipIpAddressRequest(baseURL *url.URL, accountSid string, ipAccessControlListSid string, params *ListSipIpAddressParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("IpAccessControlListSid", ipAccessControlListSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSipIpAddressFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSipIpAddress returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses.json
func (c *Client) ListSipIpAddress(ctx context.Context, accountSid string, ipAccessControlListSid string, params *ListSipIpAddressParams, reqEditors ...client.RequestEditorFn) (*ListSipIpAddressResponse, error) {
	req, err := newListSipIpAddressRequest(c.BaseURL, accountSid, ipAccessControlListSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSipIpAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                                                    `json:"end,omitempty"`
			FirstPageUri    *string                                                 `json:"first_page_uri,omitempty"`
			IpAddresses     *[]ApiV2010AccountSipSipIpAccessControlListSipIpAddress `json:"ip_addresses,omitempty"`
			NextPageUri     *string                                                 `json:"next_page_uri,omitempty"`
			Page            *int                                                    `json:"page,omitempty"`
			PageSize        *int                                                    `json:"page_size,omitempty"`
			PreviousPageUri *string                                                 `json:"previous_page_uri,omitempty"`
			Start           *int                                                    `json:"start,omitempty"`
			Uri             *string                                                 `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSipIpAddress: POST /2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses.json

type CreateSipIpAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountSipSipIpAccessControlListSipIpAddress
}

// Status returns HTTPResponse.Status
func (r CreateSipIpAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSipIpAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSipIpAddressRequestWithBody generates requests for CreateSipIpAddress with any type of body
func newCreateSipIpAddressRequestWithBody(baseURL *url.URL, accountSid string, ipAccessControlListSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("IpAccessControlListSid", ipAccessControlListSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSipIpAddressFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSipIpAddressWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses.json
func (c *Client) CreateSipIpAddressWithBody(ctx context.Context, accountSid string, ipAccessControlListSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSipIpAddressResponse, error) {
	req, err := newCreateSipIpAddressRequestWithBody(c.BaseURL, accountSid, ipAccessControlListSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSipIpAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountSipSipIpAccessControlListSipIpAddress
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteSipIpAddress: DELETE /2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{Sid}.json

type DeleteSipIpAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSipIpAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSipIpAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSipIpAddressRequest generates requests for DeleteSipIpAddress
func newDeleteSipIpAddressRequest(baseURL *url.URL, accountSid string, ipAccessControlListSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("IpAccessControlListSid", ipAccessControlListSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSipIpAddressFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSipIpAddress returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{Sid}.json
func (c *Client) DeleteSipIpAddress(ctx context.Context, accountSid string, ipAccessControlListSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSipIpAddressResponse, error) {
	req, err := newDeleteSipIpAddressRequest(c.BaseURL, accountSid, ipAccessControlListSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSipIpAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSipIpAddress: GET /2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{Sid}.json

type FetchSipIpAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountSipSipIpAccessControlListSipIpAddress
}

// Status returns HTTPResponse.Status
func (r FetchSipIpAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSipIpAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSipIpAddressRequest generates requests for FetchSipIpAddress
func newFetchSipIpAddressRequest(baseURL *url.URL, accountSid string, ipAccessControlListSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("IpAccessControlListSid", ipAccessControlListSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSipIpAddressFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSipIpAddress returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{Sid}.json
func (c *Client) FetchSipIpAddress(ctx context.Context, accountSid string, ipAccessControlListSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSipIpAddressResponse, error) {
	req, err := newFetchSipIpAddressRequest(c.BaseURL, accountSid, ipAccessControlListSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSipIpAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountSipSipIpAccessControlListSipIpAddress
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSipIpAddress: POST /2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{Sid}.json

type UpdateSipIpAddressResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountSipSipIpAccessControlListSipIpAddress
}

// Status returns HTTPResponse.Status
func (r UpdateSipIpAddressResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSipIpAddressResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSipIpAddressRequestWithBody generates requests for UpdateSipIpAddress with any type of body
func newUpdateSipIpAddressRequestWithBody(baseURL *url.URL, accountSid string, ipAccessControlListSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("IpAccessControlListSid", ipAccessControlListSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSipIpAddressFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSipIpAddressWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{IpAccessControlListSid}/IpAddresses/{Sid}.json
func (c *Client) UpdateSipIpAddressWithBody(ctx context.Context, accountSid string, ipAccessControlListSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSipIpAddressResponse, error) {
	req, err := newUpdateSipIpAddressRequestWithBody(c.BaseURL, accountSid, ipAccessControlListSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSipIpAddressResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountSipSipIpAccessControlListSipIpAddress
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteSipIpAccessControlList: DELETE /2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{Sid}.json

type DeleteSipIpAccessControlListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSipIpAccessControlListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSipIpAccessControlListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSipIpAccessControlListRequest generates requests for DeleteSipIpAccessControlList
func newDeleteSipIpAccessControlListRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSipIpAccessControlListFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSipIpAccessControlList returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{Sid}.json
func (c *Client) DeleteSipIpAccessControlList(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSipIpAccessControlListResponse, error) {
	req, err := newDeleteSipIpAccessControlListRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSipIpAccessControlListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSipIpAccessControlList: GET /2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{Sid}.json

type FetchSipIpAccessControlListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountSipSipIpAccessControlList
}

// Status returns HTTPResponse.Status
func (r FetchSipIpAccessControlListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSipIpAccessControlListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSipIpAccessControlListRequest generates requests for FetchSipIpAccessControlList
func newFetchSipIpAccessControlListRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSipIpAccessControlListFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSipIpAccessControlList returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{Sid}.json
func (c *Client) FetchSipIpAccessControlList(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSipIpAccessControlListResponse, error) {
	req, err := newFetchSipIpAccessControlListRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSipIpAccessControlListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountSipSipIpAccessControlList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSipIpAccessControlList: POST /2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{Sid}.json

type UpdateSipIpAccessControlListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountSipSipIpAccessControlList
}

// Status returns HTTPResponse.Status
func (r UpdateSipIpAccessControlListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSipIpAccessControlListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSipIpAccessControlListRequestWithBody generates requests for UpdateSipIpAccessControlList with any type of body
func newUpdateSipIpAccessControlListRequestWithBody(baseURL *url.URL, accountSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSipIpAccessControlListFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSipIpAccessControlListWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/SIP/IpAccessControlLists/{Sid}.json
func (c *Client) UpdateSipIpAccessControlListWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSipIpAccessControlListResponse, error) {
	req, err := newUpdateSipIpAccessControlListRequestWithBody(c.BaseURL, accountSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSipIpAccessControlListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountSipSipIpAccessControlList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListShortCode: GET /2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes.json

type ListShortCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                        `json:"end,omitempty"`
		FirstPageUri    *string                     `json:"first_page_uri,omitempty"`
		NextPageUri     *string                     `json:"next_page_uri,omitempty"`
		Page            *int                        `json:"page,omitempty"`
		PageSize        *int                        `json:"page_size,omitempty"`
		PreviousPageUri *string                     `json:"previous_page_uri,omitempty"`
		ShortCodes      *[]ApiV2010AccountShortCode `json:"short_codes,omitempty"`
		Start           *int                        `json:"start,omitempty"`
		Uri             *string                     `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListShortCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListShortCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListShortCodeRequest generates requests for ListShortCode
func newListShortCodeRequest(baseURL *url.URL, accountSid string, params *ListShortCodeParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListShortCodeFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.FriendlyName != nil {
		if err := client.AddQueryParam(q, "FriendlyName", *params.FriendlyName); err != nil {
			return nil, err
		}
	}

	if params.ShortCode != nil {
		if err := client.AddQueryParam(q, "ShortCode", *params.ShortCode); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListShortCode returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes.json
func (c *Client) ListShortCode(ctx context.Context, accountSid string, params *ListShortCodeParams, reqEditors ...client.RequestEditorFn) (*ListShortCodeResponse, error) {
	req, err := newListShortCodeRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListShortCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                        `json:"end,omitempty"`
			FirstPageUri    *string                     `json:"first_page_uri,omitempty"`
			NextPageUri     *string                     `json:"next_page_uri,omitempty"`
			Page            *int                        `json:"page,omitempty"`
			PageSize        *int                        `json:"page_size,omitempty"`
			PreviousPageUri *string                     `json:"previous_page_uri,omitempty"`
			ShortCodes      *[]ApiV2010AccountShortCode `json:"short_codes,omitempty"`
			Start           *int                        `json:"start,omitempty"`
			Uri             *string                     `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchShortCode: GET /2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes/{Sid}.json

type FetchShortCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountShortCode
}

// Status returns HTTPResponse.Status
func (r FetchShortCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchShortCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchShortCodeRequest generates requests for FetchShortCode
func newFetchShortCodeRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchShortCodeFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchShortCode returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes/{Sid}.json
func (c *Client) FetchShortCode(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchShortCodeResponse, error) {
	req, err := newFetchShortCodeRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchShortCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountShortCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateShortCode: POST /2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes/{Sid}.json

type UpdateShortCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountShortCode
}

// Status returns HTTPResponse.Status
func (r UpdateShortCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateShortCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateShortCodeRequestWithBody generates requests for UpdateShortCode with any type of body
func newUpdateShortCodeRequestWithBody(baseURL *url.URL, accountSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateShortCodeFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateShortCodeWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/SMS/ShortCodes/{Sid}.json
func (c *Client) UpdateShortCodeWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateShortCodeResponse, error) {
	req, err := newUpdateShortCodeRequestWithBody(c.BaseURL, accountSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateShortCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountShortCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSigningKey: GET /2010-04-01/Accounts/{AccountSid}/SigningKeys.json

type ListSigningKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                         `json:"end,omitempty"`
		FirstPageUri    *string                      `json:"first_page_uri,omitempty"`
		NextPageUri     *string                      `json:"next_page_uri,omitempty"`
		Page            *int                         `json:"page,omitempty"`
		PageSize        *int                         `json:"page_size,omitempty"`
		PreviousPageUri *string                      `json:"previous_page_uri,omitempty"`
		SigningKeys     *[]ApiV2010AccountSigningKey `json:"signing_keys,omitempty"`
		Start           *int                         `json:"start,omitempty"`
		Uri             *string                      `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSigningKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSigningKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSigningKeyRequest generates requests for ListSigningKey
func newListSigningKeyRequest(baseURL *url.URL, accountSid string, params *ListSigningKeyParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSigningKeyFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSigningKey returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SigningKeys.json
func (c *Client) ListSigningKey(ctx context.Context, accountSid string, params *ListSigningKeyParams, reqEditors ...client.RequestEditorFn) (*ListSigningKeyResponse, error) {
	req, err := newListSigningKeyRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSigningKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                         `json:"end,omitempty"`
			FirstPageUri    *string                      `json:"first_page_uri,omitempty"`
			NextPageUri     *string                      `json:"next_page_uri,omitempty"`
			Page            *int                         `json:"page,omitempty"`
			PageSize        *int                         `json:"page_size,omitempty"`
			PreviousPageUri *string                      `json:"previous_page_uri,omitempty"`
			SigningKeys     *[]ApiV2010AccountSigningKey `json:"signing_keys,omitempty"`
			Start           *int                         `json:"start,omitempty"`
			Uri             *string                      `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateNewSigningKey: POST /2010-04-01/Accounts/{AccountSid}/SigningKeys.json

type CreateNewSigningKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountNewSigningKey
}

// Status returns HTTPResponse.Status
func (r CreateNewSigningKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNewSigningKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateNewSigningKeyRequestWithBody generates requests for CreateNewSigningKey with any type of body
func newCreateNewSigningKeyRequestWithBody(baseURL *url.URL, accountSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateNewSigningKeyFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateNewSigningKeyWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/SigningKeys.json
func (c *Client) CreateNewSigningKeyWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateNewSigningKeyResponse, error) {
	req, err := newCreateNewSigningKeyRequestWithBody(c.BaseURL, accountSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateNewSigningKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountNewSigningKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteSigningKey: DELETE /2010-04-01/Accounts/{AccountSid}/SigningKeys/{Sid}.json

type DeleteSigningKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSigningKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSigningKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSigningKeyRequest generates requests for DeleteSigningKey
func newDeleteSigningKeyRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSigningKeyFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSigningKey returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/SigningKeys/{Sid}.json
func (c *Client) DeleteSigningKey(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSigningKeyResponse, error) {
	req, err := newDeleteSigningKeyRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSigningKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSigningKey: GET /2010-04-01/Accounts/{AccountSid}/SigningKeys/{Sid}.json

type FetchSigningKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountSigningKey
}

// Status returns HTTPResponse.Status
func (r FetchSigningKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSigningKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSigningKeyRequest generates requests for FetchSigningKey
func newFetchSigningKeyRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSigningKeyFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSigningKey returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/SigningKeys/{Sid}.json
func (c *Client) FetchSigningKey(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSigningKeyResponse, error) {
	req, err := newFetchSigningKeyRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSigningKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountSigningKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSigningKey: POST /2010-04-01/Accounts/{AccountSid}/SigningKeys/{Sid}.json

type UpdateSigningKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountSigningKey
}

// Status returns HTTPResponse.Status
func (r UpdateSigningKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSigningKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSigningKeyRequestWithBody generates requests for UpdateSigningKey with any type of body
func newUpdateSigningKeyRequestWithBody(baseURL *url.URL, accountSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSigningKeyFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSigningKeyWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/SigningKeys/{Sid}.json
func (c *Client) UpdateSigningKeyWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSigningKeyResponse, error) {
	req, err := newUpdateSigningKeyRequestWithBody(c.BaseURL, accountSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSigningKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountSigningKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateToken: POST /2010-04-01/Accounts/{AccountSid}/Tokens.json

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountToken
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func newCreateTokenRequestWithBody(baseURL *url.URL, accountSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateTokenFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateTokenWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Tokens.json
func (c *Client) CreateTokenWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateTokenResponse, error) {
	req, err := newCreateTokenRequestWithBody(c.BaseURL, accountSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListTranscription: GET /2010-04-01/Accounts/{AccountSid}/Transcriptions.json

type ListTranscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                            `json:"end,omitempty"`
		FirstPageUri    *string                         `json:"first_page_uri,omitempty"`
		NextPageUri     *string                         `json:"next_page_uri,omitempty"`
		Page            *int                            `json:"page,omitempty"`
		PageSize        *int                            `json:"page_size,omitempty"`
		PreviousPageUri *string                         `json:"previous_page_uri,omitempty"`
		Start           *int                            `json:"start,omitempty"`
		Transcriptions  *[]ApiV2010AccountTranscription `json:"transcriptions,omitempty"`
		Uri             *string                         `json:"uri,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListTranscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTranscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListTranscriptionRequest generates requests for ListTranscription
func newListTranscriptionRequest(baseURL *url.URL, accountSid string, params *ListTranscriptionParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListTranscriptionFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListTranscription returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Transcriptions.json
func (c *Client) ListTranscription(ctx context.Context, accountSid string, params *ListTranscriptionParams, reqEditors ...client.RequestEditorFn) (*ListTranscriptionResponse, error) {
	req, err := newListTranscriptionRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListTranscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                            `json:"end,omitempty"`
			FirstPageUri    *string                         `json:"first_page_uri,omitempty"`
			NextPageUri     *string                         `json:"next_page_uri,omitempty"`
			Page            *int                            `json:"page,omitempty"`
			PageSize        *int                            `json:"page_size,omitempty"`
			PreviousPageUri *string                         `json:"previous_page_uri,omitempty"`
			Start           *int                            `json:"start,omitempty"`
			Transcriptions  *[]ApiV2010AccountTranscription `json:"transcriptions,omitempty"`
			Uri             *string                         `json:"uri,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteTranscription: DELETE /2010-04-01/Accounts/{AccountSid}/Transcriptions/{Sid}.json

type DeleteTranscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTranscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTranscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteTranscriptionRequest generates requests for DeleteTranscription
func newDeleteTranscriptionRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteTranscriptionFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteTranscription returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/Transcriptions/{Sid}.json
func (c *Client) DeleteTranscription(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteTranscriptionResponse, error) {
	req, err := newDeleteTranscriptionRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteTranscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchTranscription: GET /2010-04-01/Accounts/{AccountSid}/Transcriptions/{Sid}.json

type FetchTranscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountTranscription
}

// Status returns HTTPResponse.Status
func (r FetchTranscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTranscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchTranscriptionRequest generates requests for FetchTranscription
func newFetchTranscriptionRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchTranscriptionFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchTranscription returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Transcriptions/{Sid}.json
func (c *Client) FetchTranscription(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchTranscriptionResponse, error) {
	req, err := newFetchTranscriptionRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchTranscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountTranscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListUsageRecord: GET /2010-04-01/Accounts/{AccountSid}/Usage/Records.json

type ListUsageRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                               `json:"end,omitempty"`
		FirstPageUri    *string                            `json:"first_page_uri,omitempty"`
		NextPageUri     *string                            `json:"next_page_uri,omitempty"`
		Page            *int                               `json:"page,omitempty"`
		PageSize        *int                               `json:"page_size,omitempty"`
		PreviousPageUri *string                            `json:"previous_page_uri,omitempty"`
		Start           *int                               `json:"start,omitempty"`
		Uri             *string                            `json:"uri,omitempty"`
		UsageRecords    *[]ApiV2010AccountUsageUsageRecord `json:"usage_records,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUsageRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsageRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListUsageRecordRequest generates requests for ListUsageRecord
func newListUsageRecordRequest(baseURL *url.URL, accountSid string, params *ListUsageRecordParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListUsageRecordFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Category != nil {
		if err := client.AddQueryParam(q, "Category", *params.Category); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.IncludeSubaccounts != nil {
		if err := client.AddQueryParam(q, "IncludeSubaccounts", *params.IncludeSubaccounts); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListUsageRecord returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Usage/Records.json
func (c *Client) ListUsageRecord(ctx context.Context, accountSid string, params *ListUsageRecordParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordResponse, error) {
	req, err := newListUsageRecordRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListUsageRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                               `json:"end,omitempty"`
			FirstPageUri    *string                            `json:"first_page_uri,omitempty"`
			NextPageUri     *string                            `json:"next_page_uri,omitempty"`
			Page            *int                               `json:"page,omitempty"`
			PageSize        *int                               `json:"page_size,omitempty"`
			PreviousPageUri *string                            `json:"previous_page_uri,omitempty"`
			Start           *int                               `json:"start,omitempty"`
			Uri             *string                            `json:"uri,omitempty"`
			UsageRecords    *[]ApiV2010AccountUsageUsageRecord `json:"usage_records,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListUsageRecordAllTime: GET /2010-04-01/Accounts/{AccountSid}/Usage/Records/AllTime.json

type ListUsageRecordAllTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                                                 `json:"end,omitempty"`
		FirstPageUri    *string                                              `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                              `json:"next_page_uri,omitempty"`
		Page            *int                                                 `json:"page,omitempty"`
		PageSize        *int                                                 `json:"page_size,omitempty"`
		PreviousPageUri *string                                              `json:"previous_page_uri,omitempty"`
		Start           *int                                                 `json:"start,omitempty"`
		Uri             *string                                              `json:"uri,omitempty"`
		UsageRecords    *[]ApiV2010AccountUsageUsageRecordUsageRecordAllTime `json:"usage_records,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUsageRecordAllTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsageRecordAllTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListUsageRecordAllTimeRequest generates requests for ListUsageRecordAllTime
func newListUsageRecordAllTimeRequest(baseURL *url.URL, accountSid string, params *ListUsageRecordAllTimeParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListUsageRecordAllTimeFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Category != nil {
		if err := client.AddQueryParam(q, "Category", *params.Category); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.IncludeSubaccounts != nil {
		if err := client.AddQueryParam(q, "IncludeSubaccounts", *params.IncludeSubaccounts); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListUsageRecordAllTime returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Usage/Records/AllTime.json
func (c *Client) ListUsageRecordAllTime(ctx context.Context, accountSid string, params *ListUsageRecordAllTimeParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordAllTimeResponse, error) {
	req, err := newListUsageRecordAllTimeRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListUsageRecordAllTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                                                 `json:"end,omitempty"`
			FirstPageUri    *string                                              `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                              `json:"next_page_uri,omitempty"`
			Page            *int                                                 `json:"page,omitempty"`
			PageSize        *int                                                 `json:"page_size,omitempty"`
			PreviousPageUri *string                                              `json:"previous_page_uri,omitempty"`
			Start           *int                                                 `json:"start,omitempty"`
			Uri             *string                                              `json:"uri,omitempty"`
			UsageRecords    *[]ApiV2010AccountUsageUsageRecordUsageRecordAllTime `json:"usage_records,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListUsageRecordDaily: GET /2010-04-01/Accounts/{AccountSid}/Usage/Records/Daily.json

type ListUsageRecordDailyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                                               `json:"end,omitempty"`
		FirstPageUri    *string                                            `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                            `json:"next_page_uri,omitempty"`
		Page            *int                                               `json:"page,omitempty"`
		PageSize        *int                                               `json:"page_size,omitempty"`
		PreviousPageUri *string                                            `json:"previous_page_uri,omitempty"`
		Start           *int                                               `json:"start,omitempty"`
		Uri             *string                                            `json:"uri,omitempty"`
		UsageRecords    *[]ApiV2010AccountUsageUsageRecordUsageRecordDaily `json:"usage_records,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUsageRecordDailyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsageRecordDailyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListUsageRecordDailyRequest generates requests for ListUsageRecordDaily
func newListUsageRecordDailyRequest(baseURL *url.URL, accountSid string, params *ListUsageRecordDailyParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListUsageRecordDailyFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Category != nil {
		if err := client.AddQueryParam(q, "Category", *params.Category); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.IncludeSubaccounts != nil {
		if err := client.AddQueryParam(q, "IncludeSubaccounts", *params.IncludeSubaccounts); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListUsageRecordDaily returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Usage/Records/Daily.json
func (c *Client) ListUsageRecordDaily(ctx context.Context, accountSid string, params *ListUsageRecordDailyParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordDailyResponse, error) {
	req, err := newListUsageRecordDailyRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListUsageRecordDailyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                                               `json:"end,omitempty"`
			FirstPageUri    *string                                            `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                            `json:"next_page_uri,omitempty"`
			Page            *int                                               `json:"page,omitempty"`
			PageSize        *int                                               `json:"page_size,omitempty"`
			PreviousPageUri *string                                            `json:"previous_page_uri,omitempty"`
			Start           *int                                               `json:"start,omitempty"`
			Uri             *string                                            `json:"uri,omitempty"`
			UsageRecords    *[]ApiV2010AccountUsageUsageRecordUsageRecordDaily `json:"usage_records,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListUsageRecordLastMonth: GET /2010-04-01/Accounts/{AccountSid}/Usage/Records/LastMonth.json

type ListUsageRecordLastMonthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                                                   `json:"end,omitempty"`
		FirstPageUri    *string                                                `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                                `json:"next_page_uri,omitempty"`
		Page            *int                                                   `json:"page,omitempty"`
		PageSize        *int                                                   `json:"page_size,omitempty"`
		PreviousPageUri *string                                                `json:"previous_page_uri,omitempty"`
		Start           *int                                                   `json:"start,omitempty"`
		Uri             *string                                                `json:"uri,omitempty"`
		UsageRecords    *[]ApiV2010AccountUsageUsageRecordUsageRecordLastMonth `json:"usage_records,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUsageRecordLastMonthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsageRecordLastMonthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListUsageRecordLastMonthRequest generates requests for ListUsageRecordLastMonth
func newListUsageRecordLastMonthRequest(baseURL *url.URL, accountSid string, params *ListUsageRecordLastMonthParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListUsageRecordLastMonthFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Category != nil {
		if err := client.AddQueryParam(q, "Category", *params.Category); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.IncludeSubaccounts != nil {
		if err := client.AddQueryParam(q, "IncludeSubaccounts", *params.IncludeSubaccounts); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListUsageRecordLastMonth returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Usage/Records/LastMonth.json
func (c *Client) ListUsageRecordLastMonth(ctx context.Context, accountSid string, params *ListUsageRecordLastMonthParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordLastMonthResponse, error) {
	req, err := newListUsageRecordLastMonthRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListUsageRecordLastMonthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                                                   `json:"end,omitempty"`
			FirstPageUri    *string                                                `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                                `json:"next_page_uri,omitempty"`
			Page            *int                                                   `json:"page,omitempty"`
			PageSize        *int                                                   `json:"page_size,omitempty"`
			PreviousPageUri *string                                                `json:"previous_page_uri,omitempty"`
			Start           *int                                                   `json:"start,omitempty"`
			Uri             *string                                                `json:"uri,omitempty"`
			UsageRecords    *[]ApiV2010AccountUsageUsageRecordUsageRecordLastMonth `json:"usage_records,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListUsageRecordMonthly: GET /2010-04-01/Accounts/{AccountSid}/Usage/Records/Monthly.json

type ListUsageRecordMonthlyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                                                 `json:"end,omitempty"`
		FirstPageUri    *string                                              `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                              `json:"next_page_uri,omitempty"`
		Page            *int                                                 `json:"page,omitempty"`
		PageSize        *int                                                 `json:"page_size,omitempty"`
		PreviousPageUri *string                                              `json:"previous_page_uri,omitempty"`
		Start           *int                                                 `json:"start,omitempty"`
		Uri             *string                                              `json:"uri,omitempty"`
		UsageRecords    *[]ApiV2010AccountUsageUsageRecordUsageRecordMonthly `json:"usage_records,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUsageRecordMonthlyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsageRecordMonthlyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListUsageRecordMonthlyRequest generates requests for ListUsageRecordMonthly
func newListUsageRecordMonthlyRequest(baseURL *url.URL, accountSid string, params *ListUsageRecordMonthlyParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListUsageRecordMonthlyFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Category != nil {
		if err := client.AddQueryParam(q, "Category", *params.Category); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.IncludeSubaccounts != nil {
		if err := client.AddQueryParam(q, "IncludeSubaccounts", *params.IncludeSubaccounts); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListUsageRecordMonthly returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Usage/Records/Monthly.json
func (c *Client) ListUsageRecordMonthly(ctx context.Context, accountSid string, params *ListUsageRecordMonthlyParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordMonthlyResponse, error) {
	req, err := newListUsageRecordMonthlyRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListUsageRecordMonthlyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                                                 `json:"end,omitempty"`
			FirstPageUri    *string                                              `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                              `json:"next_page_uri,omitempty"`
			Page            *int                                                 `json:"page,omitempty"`
			PageSize        *int                                                 `json:"page_size,omitempty"`
			PreviousPageUri *string                                              `json:"previous_page_uri,omitempty"`
			Start           *int                                                 `json:"start,omitempty"`
			Uri             *string                                              `json:"uri,omitempty"`
			UsageRecords    *[]ApiV2010AccountUsageUsageRecordUsageRecordMonthly `json:"usage_records,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListUsageRecordThisMonth: GET /2010-04-01/Accounts/{AccountSid}/Usage/Records/ThisMonth.json

type ListUsageRecordThisMonthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                                                   `json:"end,omitempty"`
		FirstPageUri    *string                                                `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                                `json:"next_page_uri,omitempty"`
		Page            *int                                                   `json:"page,omitempty"`
		PageSize        *int                                                   `json:"page_size,omitempty"`
		PreviousPageUri *string                                                `json:"previous_page_uri,omitempty"`
		Start           *int                                                   `json:"start,omitempty"`
		Uri             *string                                                `json:"uri,omitempty"`
		UsageRecords    *[]ApiV2010AccountUsageUsageRecordUsageRecordThisMonth `json:"usage_records,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUsageRecordThisMonthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsageRecordThisMonthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListUsageRecordThisMonthRequest generates requests for ListUsageRecordThisMonth
func newListUsageRecordThisMonthRequest(baseURL *url.URL, accountSid string, params *ListUsageRecordThisMonthParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListUsageRecordThisMonthFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Category != nil {
		if err := client.AddQueryParam(q, "Category", *params.Category); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.IncludeSubaccounts != nil {
		if err := client.AddQueryParam(q, "IncludeSubaccounts", *params.IncludeSubaccounts); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListUsageRecordThisMonth returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Usage/Records/ThisMonth.json
func (c *Client) ListUsageRecordThisMonth(ctx context.Context, accountSid string, params *ListUsageRecordThisMonthParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordThisMonthResponse, error) {
	req, err := newListUsageRecordThisMonthRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListUsageRecordThisMonthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                                                   `json:"end,omitempty"`
			FirstPageUri    *string                                                `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                                `json:"next_page_uri,omitempty"`
			Page            *int                                                   `json:"page,omitempty"`
			PageSize        *int                                                   `json:"page_size,omitempty"`
			PreviousPageUri *string                                                `json:"previous_page_uri,omitempty"`
			Start           *int                                                   `json:"start,omitempty"`
			Uri             *string                                                `json:"uri,omitempty"`
			UsageRecords    *[]ApiV2010AccountUsageUsageRecordUsageRecordThisMonth `json:"usage_records,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListUsageRecordToday: GET /2010-04-01/Accounts/{AccountSid}/Usage/Records/Today.json

type ListUsageRecordTodayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                                               `json:"end,omitempty"`
		FirstPageUri    *string                                            `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                            `json:"next_page_uri,omitempty"`
		Page            *int                                               `json:"page,omitempty"`
		PageSize        *int                                               `json:"page_size,omitempty"`
		PreviousPageUri *string                                            `json:"previous_page_uri,omitempty"`
		Start           *int                                               `json:"start,omitempty"`
		Uri             *string                                            `json:"uri,omitempty"`
		UsageRecords    *[]ApiV2010AccountUsageUsageRecordUsageRecordToday `json:"usage_records,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUsageRecordTodayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsageRecordTodayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListUsageRecordTodayRequest generates requests for ListUsageRecordToday
func newListUsageRecordTodayRequest(baseURL *url.URL, accountSid string, params *ListUsageRecordTodayParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListUsageRecordTodayFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Category != nil {
		if err := client.AddQueryParam(q, "Category", *params.Category); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.IncludeSubaccounts != nil {
		if err := client.AddQueryParam(q, "IncludeSubaccounts", *params.IncludeSubaccounts); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListUsageRecordToday returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Usage/Records/Today.json
func (c *Client) ListUsageRecordToday(ctx context.Context, accountSid string, params *ListUsageRecordTodayParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordTodayResponse, error) {
	req, err := newListUsageRecordTodayRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListUsageRecordTodayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                                               `json:"end,omitempty"`
			FirstPageUri    *string                                            `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                            `json:"next_page_uri,omitempty"`
			Page            *int                                               `json:"page,omitempty"`
			PageSize        *int                                               `json:"page_size,omitempty"`
			PreviousPageUri *string                                            `json:"previous_page_uri,omitempty"`
			Start           *int                                               `json:"start,omitempty"`
			Uri             *string                                            `json:"uri,omitempty"`
			UsageRecords    *[]ApiV2010AccountUsageUsageRecordUsageRecordToday `json:"usage_records,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListUsageRecordYearly: GET /2010-04-01/Accounts/{AccountSid}/Usage/Records/Yearly.json

type ListUsageRecordYearlyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                                                `json:"end,omitempty"`
		FirstPageUri    *string                                             `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                             `json:"next_page_uri,omitempty"`
		Page            *int                                                `json:"page,omitempty"`
		PageSize        *int                                                `json:"page_size,omitempty"`
		PreviousPageUri *string                                             `json:"previous_page_uri,omitempty"`
		Start           *int                                                `json:"start,omitempty"`
		Uri             *string                                             `json:"uri,omitempty"`
		UsageRecords    *[]ApiV2010AccountUsageUsageRecordUsageRecordYearly `json:"usage_records,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUsageRecordYearlyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsageRecordYearlyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListUsageRecordYearlyRequest generates requests for ListUsageRecordYearly
func newListUsageRecordYearlyRequest(baseURL *url.URL, accountSid string, params *ListUsageRecordYearlyParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListUsageRecordYearlyFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Category != nil {
		if err := client.AddQueryParam(q, "Category", *params.Category); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.IncludeSubaccounts != nil {
		if err := client.AddQueryParam(q, "IncludeSubaccounts", *params.IncludeSubaccounts); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListUsageRecordYearly returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Usage/Records/Yearly.json
func (c *Client) ListUsageRecordYearly(ctx context.Context, accountSid string, params *ListUsageRecordYearlyParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordYearlyResponse, error) {
	req, err := newListUsageRecordYearlyRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListUsageRecordYearlyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                                                `json:"end,omitempty"`
			FirstPageUri    *string                                             `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                             `json:"next_page_uri,omitempty"`
			Page            *int                                                `json:"page,omitempty"`
			PageSize        *int                                                `json:"page_size,omitempty"`
			PreviousPageUri *string                                             `json:"previous_page_uri,omitempty"`
			Start           *int                                                `json:"start,omitempty"`
			Uri             *string                                             `json:"uri,omitempty"`
			UsageRecords    *[]ApiV2010AccountUsageUsageRecordUsageRecordYearly `json:"usage_records,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListUsageRecordYesterday: GET /2010-04-01/Accounts/{AccountSid}/Usage/Records/Yesterday.json

type ListUsageRecordYesterdayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                                                   `json:"end,omitempty"`
		FirstPageUri    *string                                                `json:"first_page_uri,omitempty"`
		NextPageUri     *string                                                `json:"next_page_uri,omitempty"`
		Page            *int                                                   `json:"page,omitempty"`
		PageSize        *int                                                   `json:"page_size,omitempty"`
		PreviousPageUri *string                                                `json:"previous_page_uri,omitempty"`
		Start           *int                                                   `json:"start,omitempty"`
		Uri             *string                                                `json:"uri,omitempty"`
		UsageRecords    *[]ApiV2010AccountUsageUsageRecordUsageRecordYesterday `json:"usage_records,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUsageRecordYesterdayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsageRecordYesterdayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListUsageRecordYesterdayRequest generates requests for ListUsageRecordYesterday
func newListUsageRecordYesterdayRequest(baseURL *url.URL, accountSid string, params *ListUsageRecordYesterdayParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListUsageRecordYesterdayFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Category != nil {
		if err := client.AddQueryParam(q, "Category", *params.Category); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.IncludeSubaccounts != nil {
		if err := client.AddQueryParam(q, "IncludeSubaccounts", *params.IncludeSubaccounts); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListUsageRecordYesterday returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Usage/Records/Yesterday.json
func (c *Client) ListUsageRecordYesterday(ctx context.Context, accountSid string, params *ListUsageRecordYesterdayParams, reqEditors ...client.RequestEditorFn) (*ListUsageRecordYesterdayResponse, error) {
	req, err := newListUsageRecordYesterdayRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListUsageRecordYesterdayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                                                   `json:"end,omitempty"`
			FirstPageUri    *string                                                `json:"first_page_uri,omitempty"`
			NextPageUri     *string                                                `json:"next_page_uri,omitempty"`
			Page            *int                                                   `json:"page,omitempty"`
			PageSize        *int                                                   `json:"page_size,omitempty"`
			PreviousPageUri *string                                                `json:"previous_page_uri,omitempty"`
			Start           *int                                                   `json:"start,omitempty"`
			Uri             *string                                                `json:"uri,omitempty"`
			UsageRecords    *[]ApiV2010AccountUsageUsageRecordUsageRecordYesterday `json:"usage_records,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListUsageTrigger: GET /2010-04-01/Accounts/{AccountSid}/Usage/Triggers.json

type ListUsageTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		End             *int                                `json:"end,omitempty"`
		FirstPageUri    *string                             `json:"first_page_uri,omitempty"`
		NextPageUri     *string                             `json:"next_page_uri,omitempty"`
		Page            *int                                `json:"page,omitempty"`
		PageSize        *int                                `json:"page_size,omitempty"`
		PreviousPageUri *string                             `json:"previous_page_uri,omitempty"`
		Start           *int                                `json:"start,omitempty"`
		Uri             *string                             `json:"uri,omitempty"`
		UsageTriggers   *[]ApiV2010AccountUsageUsageTrigger `json:"usage_triggers,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListUsageTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsageTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListUsageTriggerRequest generates requests for ListUsageTrigger
func newListUsageTriggerRequest(baseURL *url.URL, accountSid string, params *ListUsageTriggerParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListUsageTriggerFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.Recurring != nil {
		if err := client.AddQueryParam(q, "Recurring", *params.Recurring); err != nil {
			return nil, err
		}
	}

	if params.TriggerBy != nil {
		if err := client.AddQueryParam(q, "TriggerBy", *params.TriggerBy); err != nil {
			return nil, err
		}
	}

	if params.UsageCategory != nil {
		if err := client.AddQueryParam(q, "UsageCategory", *params.UsageCategory); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListUsageTrigger returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Usage/Triggers.json
func (c *Client) ListUsageTrigger(ctx context.Context, accountSid string, params *ListUsageTriggerParams, reqEditors ...client.RequestEditorFn) (*ListUsageTriggerResponse, error) {
	req, err := newListUsageTriggerRequest(c.BaseURL, accountSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListUsageTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			End             *int                                `json:"end,omitempty"`
			FirstPageUri    *string                             `json:"first_page_uri,omitempty"`
			NextPageUri     *string                             `json:"next_page_uri,omitempty"`
			Page            *int                                `json:"page,omitempty"`
			PageSize        *int                                `json:"page_size,omitempty"`
			PreviousPageUri *string                             `json:"previous_page_uri,omitempty"`
			Start           *int                                `json:"start,omitempty"`
			Uri             *string                             `json:"uri,omitempty"`
			UsageTriggers   *[]ApiV2010AccountUsageUsageTrigger `json:"usage_triggers,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateUsageTrigger: POST /2010-04-01/Accounts/{AccountSid}/Usage/Triggers.json

type CreateUsageTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiV2010AccountUsageUsageTrigger
}

// Status returns HTTPResponse.Status
func (r CreateUsageTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUsageTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateUsageTriggerRequestWithBody generates requests for CreateUsageTrigger with any type of body
func newCreateUsageTriggerRequestWithBody(baseURL *url.URL, accountSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateUsageTriggerFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateUsageTriggerWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Usage/Triggers.json
func (c *Client) CreateUsageTriggerWithBody(ctx context.Context, accountSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateUsageTriggerResponse, error) {
	req, err := newCreateUsageTriggerRequestWithBody(c.BaseURL, accountSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateUsageTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiV2010AccountUsageUsageTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteUsageTrigger: DELETE /2010-04-01/Accounts/{AccountSid}/Usage/Triggers/{Sid}.json

type DeleteUsageTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteUsageTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUsageTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteUsageTriggerRequest generates requests for DeleteUsageTrigger
func newDeleteUsageTriggerRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteUsageTriggerFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteUsageTrigger returns a parsed response.
// DELETE /2010-04-01/Accounts/{AccountSid}/Usage/Triggers/{Sid}.json
func (c *Client) DeleteUsageTrigger(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteUsageTriggerResponse, error) {
	req, err := newDeleteUsageTriggerRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteUsageTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchUsageTrigger: GET /2010-04-01/Accounts/{AccountSid}/Usage/Triggers/{Sid}.json

type FetchUsageTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountUsageUsageTrigger
}

// Status returns HTTPResponse.Status
func (r FetchUsageTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchUsageTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchUsageTriggerRequest generates requests for FetchUsageTrigger
func newFetchUsageTriggerRequest(baseURL *url.URL, accountSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchUsageTriggerFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchUsageTrigger returns a parsed response.
// GET /2010-04-01/Accounts/{AccountSid}/Usage/Triggers/{Sid}.json
func (c *Client) FetchUsageTrigger(ctx context.Context, accountSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchUsageTriggerResponse, error) {
	req, err := newFetchUsageTriggerRequest(c.BaseURL, accountSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchUsageTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountUsageUsageTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateUsageTrigger: POST /2010-04-01/Accounts/{AccountSid}/Usage/Triggers/{Sid}.json

type UpdateUsageTriggerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010AccountUsageUsageTrigger
}

// Status returns HTTPResponse.Status
func (r UpdateUsageTriggerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUsageTriggerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateUsageTriggerRequestWithBody generates requests for UpdateUsageTrigger with any type of body
func newUpdateUsageTriggerRequestWithBody(baseURL *url.URL, accountSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("AccountSid", accountSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateUsageTriggerFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateUsageTriggerWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{AccountSid}/Usage/Triggers/{Sid}.json
func (c *Client) UpdateUsageTriggerWithBody(ctx context.Context, accountSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateUsageTriggerResponse, error) {
	req, err := newUpdateUsageTriggerRequestWithBody(c.BaseURL, accountSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateUsageTriggerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010AccountUsageUsageTrigger
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchAccount: GET /2010-04-01/Accounts/{Sid}.json

type FetchAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010Account
}

// Status returns HTTPResponse.Status
func (r FetchAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchAccountRequest generates requests for FetchAccount
func newFetchAccountRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchAccountFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchAccount returns a parsed response.
// GET /2010-04-01/Accounts/{Sid}.json
func (c *Client) FetchAccount(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchAccountResponse, error) {
	req, err := newFetchAccountRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010Account
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateAccount: POST /2010-04-01/Accounts/{Sid}.json

type UpdateAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiV2010Account
}

// Status returns HTTPResponse.Status
func (r UpdateAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateAccountRequestWithBody generates requests for UpdateAccount with any type of body
func newUpdateAccountRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateAccountFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateAccountWithBody returns a parsed response.
// POST /2010-04-01/Accounts/{Sid}.json
func (c *Client) UpdateAccountWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateAccountResponse, error) {
	req, err := newUpdateAccountRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiV2010Account
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
