// Package proxy provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package proxy

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/faetools/client"
)

// operation paths

const (
	opPathListPhoneNumberFormat          = "./v1/Services/%s/PhoneNumbers"
	opPathCreatePhoneNumberFormat        = "./v1/Services/%s/PhoneNumbers"
	opPathDeletePhoneNumberFormat        = "./v1/Services/%s/PhoneNumbers/%s"
	opPathFetchPhoneNumberFormat         = "./v1/Services/%s/PhoneNumbers/%s"
	opPathUpdatePhoneNumberFormat        = "./v1/Services/%s/PhoneNumbers/%s"
	opPathListSessionFormat              = "./v1/Services/%s/Sessions"
	opPathCreateSessionFormat            = "./v1/Services/%s/Sessions"
	opPathListInteractionFormat          = "./v1/Services/%s/Sessions/%s/Interactions"
	opPathDeleteInteractionFormat        = "./v1/Services/%s/Sessions/%s/Interactions/%s"
	opPathFetchInteractionFormat         = "./v1/Services/%s/Sessions/%s/Interactions/%s"
	opPathListParticipantFormat          = "./v1/Services/%s/Sessions/%s/Participants"
	opPathCreateParticipantFormat        = "./v1/Services/%s/Sessions/%s/Participants"
	opPathListMessageInteractionFormat   = "./v1/Services/%s/Sessions/%s/Participants/%s/MessageInteractions"
	opPathCreateMessageInteractionFormat = "./v1/Services/%s/Sessions/%s/Participants/%s/MessageInteractions"
	opPathFetchMessageInteractionFormat  = "./v1/Services/%s/Sessions/%s/Participants/%s/MessageInteractions/%s"
	opPathDeleteParticipantFormat        = "./v1/Services/%s/Sessions/%s/Participants/%s"
	opPathFetchParticipantFormat         = "./v1/Services/%s/Sessions/%s/Participants/%s"
	opPathDeleteSessionFormat            = "./v1/Services/%s/Sessions/%s"
	opPathFetchSessionFormat             = "./v1/Services/%s/Sessions/%s"
	opPathUpdateSessionFormat            = "./v1/Services/%s/Sessions/%s"
	opPathListShortCodeFormat            = "./v1/Services/%s/ShortCodes"
	opPathCreateShortCodeFormat          = "./v1/Services/%s/ShortCodes"
	opPathDeleteShortCodeFormat          = "./v1/Services/%s/ShortCodes/%s"
	opPathFetchShortCodeFormat           = "./v1/Services/%s/ShortCodes/%s"
	opPathUpdateShortCodeFormat          = "./v1/Services/%s/ShortCodes/%s"
	opPathDeleteServiceFormat            = "./v1/Services/%s"
	opPathFetchServiceFormat             = "./v1/Services/%s"
	opPathUpdateServiceFormat            = "./v1/Services/%s"
)

var (
	opPathListService   = client.MustParseURL("./v1/Services")
	opPathCreateService = client.MustParseURL("./v1/Services")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// ListService request
	ListService(ctx context.Context, params *ListServiceParams, reqEditors ...client.RequestEditorFn) (*ListServiceResponse, error)

	// CreateService request with any body
	CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceResponse, error)

	// ListPhoneNumber request
	ListPhoneNumber(ctx context.Context, serviceSid string, params *ListPhoneNumberParams, reqEditors ...client.RequestEditorFn) (*ListPhoneNumberResponse, error)

	// CreatePhoneNumber request with any body
	CreatePhoneNumberWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreatePhoneNumberResponse, error)

	// DeletePhoneNumber request
	DeletePhoneNumber(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeletePhoneNumberResponse, error)

	// FetchPhoneNumber request
	FetchPhoneNumber(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchPhoneNumberResponse, error)

	// UpdatePhoneNumber request with any body
	UpdatePhoneNumberWithBody(ctx context.Context, serviceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdatePhoneNumberResponse, error)

	// ListSession request
	ListSession(ctx context.Context, serviceSid string, params *ListSessionParams, reqEditors ...client.RequestEditorFn) (*ListSessionResponse, error)

	// CreateSession request with any body
	CreateSessionWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSessionResponse, error)

	// ListInteraction request
	ListInteraction(ctx context.Context, serviceSid string, sessionSid string, params *ListInteractionParams, reqEditors ...client.RequestEditorFn) (*ListInteractionResponse, error)

	// DeleteInteraction request
	DeleteInteraction(ctx context.Context, serviceSid string, sessionSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteInteractionResponse, error)

	// FetchInteraction request
	FetchInteraction(ctx context.Context, serviceSid string, sessionSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchInteractionResponse, error)

	// ListParticipant request
	ListParticipant(ctx context.Context, serviceSid string, sessionSid string, params *ListParticipantParams, reqEditors ...client.RequestEditorFn) (*ListParticipantResponse, error)

	// CreateParticipant request with any body
	CreateParticipantWithBody(ctx context.Context, serviceSid string, sessionSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateParticipantResponse, error)

	// ListMessageInteraction request
	ListMessageInteraction(ctx context.Context, serviceSid string, sessionSid string, participantSid string, params *ListMessageInteractionParams, reqEditors ...client.RequestEditorFn) (*ListMessageInteractionResponse, error)

	// CreateMessageInteraction request with any body
	CreateMessageInteractionWithBody(ctx context.Context, serviceSid string, sessionSid string, participantSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateMessageInteractionResponse, error)

	// FetchMessageInteraction request
	FetchMessageInteraction(ctx context.Context, serviceSid string, sessionSid string, participantSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchMessageInteractionResponse, error)

	// DeleteParticipant request
	DeleteParticipant(ctx context.Context, serviceSid string, sessionSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteParticipantResponse, error)

	// FetchParticipant request
	FetchParticipant(ctx context.Context, serviceSid string, sessionSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchParticipantResponse, error)

	// DeleteSession request
	DeleteSession(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSessionResponse, error)

	// FetchSession request
	FetchSession(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSessionResponse, error)

	// UpdateSession request with any body
	UpdateSessionWithBody(ctx context.Context, serviceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSessionResponse, error)

	// ListShortCode request
	ListShortCode(ctx context.Context, serviceSid string, params *ListShortCodeParams, reqEditors ...client.RequestEditorFn) (*ListShortCodeResponse, error)

	// CreateShortCode request with any body
	CreateShortCodeWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateShortCodeResponse, error)

	// DeleteShortCode request
	DeleteShortCode(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteShortCodeResponse, error)

	// FetchShortCode request
	FetchShortCode(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchShortCodeResponse, error)

	// UpdateShortCode request with any body
	UpdateShortCodeWithBody(ctx context.Context, serviceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateShortCodeResponse, error)

	// DeleteService request
	DeleteService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteServiceResponse, error)

	// FetchService request
	FetchService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceResponse, error)

	// UpdateService request with any body
	UpdateServiceWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// ListService: GET /v1/Services

type ListServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Services *[]ProxyV1Service `json:"services,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListServiceRequest generates requests for ListService
func newListServiceRequest(baseURL *url.URL, params *ListServiceParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListService)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListService returns a parsed response.
// GET /v1/Services
func (c *Client) ListService(ctx context.Context, params *ListServiceParams, reqEditors ...client.RequestEditorFn) (*ListServiceResponse, error) {
	req, err := newListServiceRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Services *[]ProxyV1Service `json:"services,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateService: POST /v1/Services

type CreateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProxyV1Service
}

// Status returns HTTPResponse.Status
func (r CreateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateServiceRequestWithBody generates requests for CreateService with any type of body
func newCreateServiceRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateService)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateServiceWithBody returns a parsed response.
// POST /v1/Services
func (c *Client) CreateServiceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateServiceResponse, error) {
	req, err := newCreateServiceRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProxyV1Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListPhoneNumber: GET /v1/Services/{ServiceSid}/PhoneNumbers

type ListPhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		PhoneNumbers *[]ProxyV1ServicePhoneNumber `json:"phone_numbers,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListPhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListPhoneNumberRequest generates requests for ListPhoneNumber
func newListPhoneNumberRequest(baseURL *url.URL, serviceSid string, params *ListPhoneNumberParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListPhoneNumberFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListPhoneNumber returns a parsed response.
// GET /v1/Services/{ServiceSid}/PhoneNumbers
func (c *Client) ListPhoneNumber(ctx context.Context, serviceSid string, params *ListPhoneNumberParams, reqEditors ...client.RequestEditorFn) (*ListPhoneNumberResponse, error) {
	req, err := newListPhoneNumberRequest(c.BaseURL, serviceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListPhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			PhoneNumbers *[]ProxyV1ServicePhoneNumber `json:"phone_numbers,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreatePhoneNumber: POST /v1/Services/{ServiceSid}/PhoneNumbers

type CreatePhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProxyV1ServicePhoneNumber
}

// Status returns HTTPResponse.Status
func (r CreatePhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreatePhoneNumberRequestWithBody generates requests for CreatePhoneNumber with any type of body
func newCreatePhoneNumberRequestWithBody(baseURL *url.URL, serviceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreatePhoneNumberFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreatePhoneNumberWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/PhoneNumbers
func (c *Client) CreatePhoneNumberWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreatePhoneNumberResponse, error) {
	req, err := newCreatePhoneNumberRequestWithBody(c.BaseURL, serviceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreatePhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProxyV1ServicePhoneNumber
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeletePhoneNumber: DELETE /v1/Services/{ServiceSid}/PhoneNumbers/{Sid}

type DeletePhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeletePhoneNumberRequest generates requests for DeletePhoneNumber
func newDeletePhoneNumberRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeletePhoneNumberFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeletePhoneNumber returns a parsed response.
// DELETE /v1/Services/{ServiceSid}/PhoneNumbers/{Sid}
func (c *Client) DeletePhoneNumber(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeletePhoneNumberResponse, error) {
	req, err := newDeletePhoneNumberRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeletePhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchPhoneNumber: GET /v1/Services/{ServiceSid}/PhoneNumbers/{Sid}

type FetchPhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProxyV1ServicePhoneNumber
}

// Status returns HTTPResponse.Status
func (r FetchPhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchPhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchPhoneNumberRequest generates requests for FetchPhoneNumber
func newFetchPhoneNumberRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchPhoneNumberFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchPhoneNumber returns a parsed response.
// GET /v1/Services/{ServiceSid}/PhoneNumbers/{Sid}
func (c *Client) FetchPhoneNumber(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchPhoneNumberResponse, error) {
	req, err := newFetchPhoneNumberRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchPhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProxyV1ServicePhoneNumber
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdatePhoneNumber: POST /v1/Services/{ServiceSid}/PhoneNumbers/{Sid}

type UpdatePhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProxyV1ServicePhoneNumber
}

// Status returns HTTPResponse.Status
func (r UpdatePhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdatePhoneNumberRequestWithBody generates requests for UpdatePhoneNumber with any type of body
func newUpdatePhoneNumberRequestWithBody(baseURL *url.URL, serviceSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdatePhoneNumberFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdatePhoneNumberWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/PhoneNumbers/{Sid}
func (c *Client) UpdatePhoneNumberWithBody(ctx context.Context, serviceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdatePhoneNumberResponse, error) {
	req, err := newUpdatePhoneNumberRequestWithBody(c.BaseURL, serviceSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdatePhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProxyV1ServicePhoneNumber
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListSession: GET /v1/Services/{ServiceSid}/Sessions

type ListSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Sessions *[]ProxyV1ServiceSession `json:"sessions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListSessionRequest generates requests for ListSession
func newListSessionRequest(baseURL *url.URL, serviceSid string, params *ListSessionParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListSessionFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListSession returns a parsed response.
// GET /v1/Services/{ServiceSid}/Sessions
func (c *Client) ListSession(ctx context.Context, serviceSid string, params *ListSessionParams, reqEditors ...client.RequestEditorFn) (*ListSessionResponse, error) {
	req, err := newListSessionRequest(c.BaseURL, serviceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Sessions *[]ProxyV1ServiceSession `json:"sessions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateSession: POST /v1/Services/{ServiceSid}/Sessions

type CreateSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProxyV1ServiceSession
}

// Status returns HTTPResponse.Status
func (r CreateSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateSessionRequestWithBody generates requests for CreateSession with any type of body
func newCreateSessionRequestWithBody(baseURL *url.URL, serviceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateSessionFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateSessionWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/Sessions
func (c *Client) CreateSessionWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateSessionResponse, error) {
	req, err := newCreateSessionRequestWithBody(c.BaseURL, serviceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProxyV1ServiceSession
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListInteraction: GET /v1/Services/{ServiceSid}/Sessions/{SessionSid}/Interactions

type ListInteractionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Interactions *[]ProxyV1ServiceSessionInteraction `json:"interactions,omitempty"`
		Meta         *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListInteractionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInteractionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListInteractionRequest generates requests for ListInteraction
func newListInteractionRequest(baseURL *url.URL, serviceSid string, sessionSid string, params *ListInteractionParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("SessionSid", sessionSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListInteractionFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListInteraction returns a parsed response.
// GET /v1/Services/{ServiceSid}/Sessions/{SessionSid}/Interactions
func (c *Client) ListInteraction(ctx context.Context, serviceSid string, sessionSid string, params *ListInteractionParams, reqEditors ...client.RequestEditorFn) (*ListInteractionResponse, error) {
	req, err := newListInteractionRequest(c.BaseURL, serviceSid, sessionSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListInteractionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Interactions *[]ProxyV1ServiceSessionInteraction `json:"interactions,omitempty"`
			Meta         *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteInteraction: DELETE /v1/Services/{ServiceSid}/Sessions/{SessionSid}/Interactions/{Sid}

type DeleteInteractionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteInteractionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInteractionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteInteractionRequest generates requests for DeleteInteraction
func newDeleteInteractionRequest(baseURL *url.URL, serviceSid string, sessionSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("SessionSid", sessionSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteInteractionFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteInteraction returns a parsed response.
// DELETE /v1/Services/{ServiceSid}/Sessions/{SessionSid}/Interactions/{Sid}
func (c *Client) DeleteInteraction(ctx context.Context, serviceSid string, sessionSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteInteractionResponse, error) {
	req, err := newDeleteInteractionRequest(c.BaseURL, serviceSid, sessionSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteInteractionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchInteraction: GET /v1/Services/{ServiceSid}/Sessions/{SessionSid}/Interactions/{Sid}

type FetchInteractionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProxyV1ServiceSessionInteraction
}

// Status returns HTTPResponse.Status
func (r FetchInteractionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchInteractionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchInteractionRequest generates requests for FetchInteraction
func newFetchInteractionRequest(baseURL *url.URL, serviceSid string, sessionSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("SessionSid", sessionSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchInteractionFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchInteraction returns a parsed response.
// GET /v1/Services/{ServiceSid}/Sessions/{SessionSid}/Interactions/{Sid}
func (c *Client) FetchInteraction(ctx context.Context, serviceSid string, sessionSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchInteractionResponse, error) {
	req, err := newFetchInteractionRequest(c.BaseURL, serviceSid, sessionSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchInteractionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProxyV1ServiceSessionInteraction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListParticipant: GET /v1/Services/{ServiceSid}/Sessions/{SessionSid}/Participants

type ListParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Participants *[]ProxyV1ServiceSessionParticipant `json:"participants,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListParticipantRequest generates requests for ListParticipant
func newListParticipantRequest(baseURL *url.URL, serviceSid string, sessionSid string, params *ListParticipantParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("SessionSid", sessionSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListParticipantFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListParticipant returns a parsed response.
// GET /v1/Services/{ServiceSid}/Sessions/{SessionSid}/Participants
func (c *Client) ListParticipant(ctx context.Context, serviceSid string, sessionSid string, params *ListParticipantParams, reqEditors ...client.RequestEditorFn) (*ListParticipantResponse, error) {
	req, err := newListParticipantRequest(c.BaseURL, serviceSid, sessionSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Participants *[]ProxyV1ServiceSessionParticipant `json:"participants,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateParticipant: POST /v1/Services/{ServiceSid}/Sessions/{SessionSid}/Participants

type CreateParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProxyV1ServiceSessionParticipant
}

// Status returns HTTPResponse.Status
func (r CreateParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateParticipantRequestWithBody generates requests for CreateParticipant with any type of body
func newCreateParticipantRequestWithBody(baseURL *url.URL, serviceSid string, sessionSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("SessionSid", sessionSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateParticipantFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateParticipantWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/Sessions/{SessionSid}/Participants
func (c *Client) CreateParticipantWithBody(ctx context.Context, serviceSid string, sessionSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateParticipantResponse, error) {
	req, err := newCreateParticipantRequestWithBody(c.BaseURL, serviceSid, sessionSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProxyV1ServiceSessionParticipant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// ListMessageInteraction: GET /v1/Services/{ServiceSid}/Sessions/{SessionSid}/Participants/{ParticipantSid}/MessageInteractions

type ListMessageInteractionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Interactions *[]ProxyV1ServiceSessionParticipantMessageInteraction `json:"interactions,omitempty"`
		Meta         *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListMessageInteractionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMessageInteractionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListMessageInteractionRequest generates requests for ListMessageInteraction
func newListMessageInteractionRequest(baseURL *url.URL, serviceSid string, sessionSid string, participantSid string, params *ListMessageInteractionParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("SessionSid", sessionSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("ParticipantSid", participantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListMessageInteractionFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListMessageInteraction returns a parsed response.
// GET /v1/Services/{ServiceSid}/Sessions/{SessionSid}/Participants/{ParticipantSid}/MessageInteractions
func (c *Client) ListMessageInteraction(ctx context.Context, serviceSid string, sessionSid string, participantSid string, params *ListMessageInteractionParams, reqEditors ...client.RequestEditorFn) (*ListMessageInteractionResponse, error) {
	req, err := newListMessageInteractionRequest(c.BaseURL, serviceSid, sessionSid, participantSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListMessageInteractionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Interactions *[]ProxyV1ServiceSessionParticipantMessageInteraction `json:"interactions,omitempty"`
			Meta         *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateMessageInteraction: POST /v1/Services/{ServiceSid}/Sessions/{SessionSid}/Participants/{ParticipantSid}/MessageInteractions

type CreateMessageInteractionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProxyV1ServiceSessionParticipantMessageInteraction
}

// Status returns HTTPResponse.Status
func (r CreateMessageInteractionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMessageInteractionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateMessageInteractionRequestWithBody generates requests for CreateMessageInteraction with any type of body
func newCreateMessageInteractionRequestWithBody(baseURL *url.URL, serviceSid string, sessionSid string, participantSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("SessionSid", sessionSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("ParticipantSid", participantSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateMessageInteractionFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateMessageInteractionWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/Sessions/{SessionSid}/Participants/{ParticipantSid}/MessageInteractions
func (c *Client) CreateMessageInteractionWithBody(ctx context.Context, serviceSid string, sessionSid string, participantSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateMessageInteractionResponse, error) {
	req, err := newCreateMessageInteractionRequestWithBody(c.BaseURL, serviceSid, sessionSid, participantSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateMessageInteractionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProxyV1ServiceSessionParticipantMessageInteraction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// FetchMessageInteraction: GET /v1/Services/{ServiceSid}/Sessions/{SessionSid}/Participants/{ParticipantSid}/MessageInteractions/{Sid}

type FetchMessageInteractionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProxyV1ServiceSessionParticipantMessageInteraction
}

// Status returns HTTPResponse.Status
func (r FetchMessageInteractionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchMessageInteractionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchMessageInteractionRequest generates requests for FetchMessageInteraction
func newFetchMessageInteractionRequest(baseURL *url.URL, serviceSid string, sessionSid string, participantSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("SessionSid", sessionSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("ParticipantSid", participantSid)
	if err != nil {
		return nil, err
	}

	pathParam3, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchMessageInteractionFormat, pathParam0, pathParam1, pathParam2, pathParam3)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchMessageInteraction returns a parsed response.
// GET /v1/Services/{ServiceSid}/Sessions/{SessionSid}/Participants/{ParticipantSid}/MessageInteractions/{Sid}
func (c *Client) FetchMessageInteraction(ctx context.Context, serviceSid string, sessionSid string, participantSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchMessageInteractionResponse, error) {
	req, err := newFetchMessageInteractionRequest(c.BaseURL, serviceSid, sessionSid, participantSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchMessageInteractionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProxyV1ServiceSessionParticipantMessageInteraction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteParticipant: DELETE /v1/Services/{ServiceSid}/Sessions/{SessionSid}/Participants/{Sid}

type DeleteParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteParticipantRequest generates requests for DeleteParticipant
func newDeleteParticipantRequest(baseURL *url.URL, serviceSid string, sessionSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("SessionSid", sessionSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteParticipantFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteParticipant returns a parsed response.
// DELETE /v1/Services/{ServiceSid}/Sessions/{SessionSid}/Participants/{Sid}
func (c *Client) DeleteParticipant(ctx context.Context, serviceSid string, sessionSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteParticipantResponse, error) {
	req, err := newDeleteParticipantRequest(c.BaseURL, serviceSid, sessionSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchParticipant: GET /v1/Services/{ServiceSid}/Sessions/{SessionSid}/Participants/{Sid}

type FetchParticipantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProxyV1ServiceSessionParticipant
}

// Status returns HTTPResponse.Status
func (r FetchParticipantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchParticipantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchParticipantRequest generates requests for FetchParticipant
func newFetchParticipantRequest(baseURL *url.URL, serviceSid string, sessionSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("SessionSid", sessionSid)
	if err != nil {
		return nil, err
	}

	pathParam2, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchParticipantFormat, pathParam0, pathParam1, pathParam2)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchParticipant returns a parsed response.
// GET /v1/Services/{ServiceSid}/Sessions/{SessionSid}/Participants/{Sid}
func (c *Client) FetchParticipant(ctx context.Context, serviceSid string, sessionSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchParticipantResponse, error) {
	req, err := newFetchParticipantRequest(c.BaseURL, serviceSid, sessionSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchParticipantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProxyV1ServiceSessionParticipant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteSession: DELETE /v1/Services/{ServiceSid}/Sessions/{Sid}

type DeleteSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteSessionRequest generates requests for DeleteSession
func newDeleteSessionRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteSessionFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteSession returns a parsed response.
// DELETE /v1/Services/{ServiceSid}/Sessions/{Sid}
func (c *Client) DeleteSession(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteSessionResponse, error) {
	req, err := newDeleteSessionRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchSession: GET /v1/Services/{ServiceSid}/Sessions/{Sid}

type FetchSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProxyV1ServiceSession
}

// Status returns HTTPResponse.Status
func (r FetchSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchSessionRequest generates requests for FetchSession
func newFetchSessionRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchSessionFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchSession returns a parsed response.
// GET /v1/Services/{ServiceSid}/Sessions/{Sid}
func (c *Client) FetchSession(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchSessionResponse, error) {
	req, err := newFetchSessionRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProxyV1ServiceSession
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateSession: POST /v1/Services/{ServiceSid}/Sessions/{Sid}

type UpdateSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProxyV1ServiceSession
}

// Status returns HTTPResponse.Status
func (r UpdateSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateSessionRequestWithBody generates requests for UpdateSession with any type of body
func newUpdateSessionRequestWithBody(baseURL *url.URL, serviceSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateSessionFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateSessionWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/Sessions/{Sid}
func (c *Client) UpdateSessionWithBody(ctx context.Context, serviceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateSessionResponse, error) {
	req, err := newUpdateSessionRequestWithBody(c.BaseURL, serviceSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProxyV1ServiceSession
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListShortCode: GET /v1/Services/{ServiceSid}/ShortCodes

type ListShortCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		ShortCodes *[]ProxyV1ServiceShortCode `json:"short_codes,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListShortCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListShortCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListShortCodeRequest generates requests for ListShortCode
func newListShortCodeRequest(baseURL *url.URL, serviceSid string, params *ListShortCodeParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListShortCodeFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListShortCode returns a parsed response.
// GET /v1/Services/{ServiceSid}/ShortCodes
func (c *Client) ListShortCode(ctx context.Context, serviceSid string, params *ListShortCodeParams, reqEditors ...client.RequestEditorFn) (*ListShortCodeResponse, error) {
	req, err := newListShortCodeRequest(c.BaseURL, serviceSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListShortCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			ShortCodes *[]ProxyV1ServiceShortCode `json:"short_codes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateShortCode: POST /v1/Services/{ServiceSid}/ShortCodes

type CreateShortCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProxyV1ServiceShortCode
}

// Status returns HTTPResponse.Status
func (r CreateShortCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateShortCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateShortCodeRequestWithBody generates requests for CreateShortCode with any type of body
func newCreateShortCodeRequestWithBody(baseURL *url.URL, serviceSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateShortCodeFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateShortCodeWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/ShortCodes
func (c *Client) CreateShortCodeWithBody(ctx context.Context, serviceSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateShortCodeResponse, error) {
	req, err := newCreateShortCodeRequestWithBody(c.BaseURL, serviceSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateShortCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProxyV1ServiceShortCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteShortCode: DELETE /v1/Services/{ServiceSid}/ShortCodes/{Sid}

type DeleteShortCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteShortCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteShortCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteShortCodeRequest generates requests for DeleteShortCode
func newDeleteShortCodeRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteShortCodeFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteShortCode returns a parsed response.
// DELETE /v1/Services/{ServiceSid}/ShortCodes/{Sid}
func (c *Client) DeleteShortCode(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteShortCodeResponse, error) {
	req, err := newDeleteShortCodeRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteShortCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchShortCode: GET /v1/Services/{ServiceSid}/ShortCodes/{Sid}

type FetchShortCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProxyV1ServiceShortCode
}

// Status returns HTTPResponse.Status
func (r FetchShortCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchShortCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchShortCodeRequest generates requests for FetchShortCode
func newFetchShortCodeRequest(baseURL *url.URL, serviceSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchShortCodeFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchShortCode returns a parsed response.
// GET /v1/Services/{ServiceSid}/ShortCodes/{Sid}
func (c *Client) FetchShortCode(ctx context.Context, serviceSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchShortCodeResponse, error) {
	req, err := newFetchShortCodeRequest(c.BaseURL, serviceSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchShortCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProxyV1ServiceShortCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateShortCode: POST /v1/Services/{ServiceSid}/ShortCodes/{Sid}

type UpdateShortCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProxyV1ServiceShortCode
}

// Status returns HTTPResponse.Status
func (r UpdateShortCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateShortCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateShortCodeRequestWithBody generates requests for UpdateShortCode with any type of body
func newUpdateShortCodeRequestWithBody(baseURL *url.URL, serviceSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("ServiceSid", serviceSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateShortCodeFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateShortCodeWithBody returns a parsed response.
// POST /v1/Services/{ServiceSid}/ShortCodes/{Sid}
func (c *Client) UpdateShortCodeWithBody(ctx context.Context, serviceSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateShortCodeResponse, error) {
	req, err := newUpdateShortCodeRequestWithBody(c.BaseURL, serviceSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateShortCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProxyV1ServiceShortCode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// DeleteService: DELETE /v1/Services/{Sid}

type DeleteServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteServiceRequest generates requests for DeleteService
func newDeleteServiceRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteServiceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteService returns a parsed response.
// DELETE /v1/Services/{Sid}
func (c *Client) DeleteService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteServiceResponse, error) {
	req, err := newDeleteServiceRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchService: GET /v1/Services/{Sid}

type FetchServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProxyV1Service
}

// Status returns HTTPResponse.Status
func (r FetchServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchServiceRequest generates requests for FetchService
func newFetchServiceRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchServiceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchService returns a parsed response.
// GET /v1/Services/{Sid}
func (c *Client) FetchService(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchServiceResponse, error) {
	req, err := newFetchServiceRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProxyV1Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateService: POST /v1/Services/{Sid}

type UpdateServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProxyV1Service
}

// Status returns HTTPResponse.Status
func (r UpdateServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateServiceRequestWithBody generates requests for UpdateService with any type of body
func newUpdateServiceRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateServiceFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateServiceWithBody returns a parsed response.
// POST /v1/Services/{Sid}
func (c *Client) UpdateServiceWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateServiceResponse, error) {
	req, err := newUpdateServiceRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProxyV1Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
