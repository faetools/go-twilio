// Package monitor provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package monitor

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/faetools/client"
)

// operation paths

const (
	opPathFetchAlertFormat = "./v1/Alerts/%s"
	opPathFetchEventFormat = "./v1/Events/%s"
)

var (
	opPathListAlert = client.MustParseURL("./v1/Alerts")
	opPathListEvent = client.MustParseURL("./v1/Events")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// ListAlert request
	ListAlert(ctx context.Context, params *ListAlertParams, reqEditors ...client.RequestEditorFn) (*ListAlertResponse, error)

	// FetchAlert request
	FetchAlert(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchAlertResponse, error)

	// ListEvent request
	ListEvent(ctx context.Context, params *ListEventParams, reqEditors ...client.RequestEditorFn) (*ListEventResponse, error)

	// FetchEvent request
	FetchEvent(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchEventResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// ListAlert: GET /v1/Alerts

type ListAlertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Alerts *[]MonitorV1Alert `json:"alerts,omitempty"`
		Meta   *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAlertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAlertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListAlertRequest generates requests for ListAlert
func newListAlertRequest(baseURL *url.URL, params *ListAlertParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListAlert)

	q := queryURL.Query()

	if params.LogLevel != nil {
		if err := client.AddQueryParam(q, "LogLevel", *params.LogLevel); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListAlert returns a parsed response.
// GET /v1/Alerts
func (c *Client) ListAlert(ctx context.Context, params *ListAlertParams, reqEditors ...client.RequestEditorFn) (*ListAlertResponse, error) {
	req, err := newListAlertRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListAlertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Alerts *[]MonitorV1Alert `json:"alerts,omitempty"`
			Meta   *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchAlert: GET /v1/Alerts/{Sid}

type FetchAlertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MonitorV1AlertInstance
}

// Status returns HTTPResponse.Status
func (r FetchAlertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchAlertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchAlertRequest generates requests for FetchAlert
func newFetchAlertRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchAlertFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchAlert returns a parsed response.
// GET /v1/Alerts/{Sid}
func (c *Client) FetchAlert(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchAlertResponse, error) {
	req, err := newFetchAlertRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchAlertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MonitorV1AlertInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListEvent: GET /v1/Events

type ListEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Events *[]MonitorV1Event `json:"events,omitempty"`
		Meta   *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListEventRequest generates requests for ListEvent
func newListEventRequest(baseURL *url.URL, params *ListEventParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListEvent)

	q := queryURL.Query()

	if params.ActorSid != nil {
		if err := client.AddQueryParam(q, "ActorSid", *params.ActorSid); err != nil {
			return nil, err
		}
	}

	if params.EventType != nil {
		if err := client.AddQueryParam(q, "EventType", *params.EventType); err != nil {
			return nil, err
		}
	}

	if params.ResourceSid != nil {
		if err := client.AddQueryParam(q, "ResourceSid", *params.ResourceSid); err != nil {
			return nil, err
		}
	}

	if params.SourceIpAddress != nil {
		if err := client.AddQueryParam(q, "SourceIpAddress", *params.SourceIpAddress); err != nil {
			return nil, err
		}
	}

	if params.StartDate != nil {
		if err := client.AddQueryParam(q, "StartDate", *params.StartDate); err != nil {
			return nil, err
		}
	}

	if params.EndDate != nil {
		if err := client.AddQueryParam(q, "EndDate", *params.EndDate); err != nil {
			return nil, err
		}
	}

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListEvent returns a parsed response.
// GET /v1/Events
func (c *Client) ListEvent(ctx context.Context, params *ListEventParams, reqEditors ...client.RequestEditorFn) (*ListEventResponse, error) {
	req, err := newListEventRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Events *[]MonitorV1Event `json:"events,omitempty"`
			Meta   *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchEvent: GET /v1/Events/{Sid}

type FetchEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MonitorV1Event
}

// Status returns HTTPResponse.Status
func (r FetchEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchEventRequest generates requests for FetchEvent
func newFetchEventRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchEventFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchEvent returns a parsed response.
// GET /v1/Events/{Sid}
func (c *Client) FetchEvent(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchEventResponse, error) {
	req, err := newFetchEventRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MonitorV1Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
