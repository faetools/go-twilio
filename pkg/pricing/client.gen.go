// Package pricing provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package pricing

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/faetools/client"
)

// operation paths

const (
	opPathFetchTrunkingCountryFormat = "./v2/Trunking/Countries/%s"
	opPathFetchTrunkingNumberFormat  = "./v2/Trunking/Numbers/%s"
	opPathFetchVoiceCountryFormat    = "./v2/Voice/Countries/%s"
	opPathFetchVoiceNumberFormat     = "./v2/Voice/Numbers/%s"
)

var (
	opPathListTrunkingCountry = client.MustParseURL("./v2/Trunking/Countries")
	opPathListVoiceCountry    = client.MustParseURL("./v2/Voice/Countries")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// ListTrunkingCountry request
	ListTrunkingCountry(ctx context.Context, params *ListTrunkingCountryParams, reqEditors ...client.RequestEditorFn) (*ListTrunkingCountryResponse, error)

	// FetchTrunkingCountry request
	FetchTrunkingCountry(ctx context.Context, isoCountry string, reqEditors ...client.RequestEditorFn) (*FetchTrunkingCountryResponse, error)

	// FetchTrunkingNumber request
	FetchTrunkingNumber(ctx context.Context, destinationNumber string, params *FetchTrunkingNumberParams, reqEditors ...client.RequestEditorFn) (*FetchTrunkingNumberResponse, error)

	// ListVoiceCountry request
	ListVoiceCountry(ctx context.Context, params *ListVoiceCountryParams, reqEditors ...client.RequestEditorFn) (*ListVoiceCountryResponse, error)

	// FetchVoiceCountry request
	FetchVoiceCountry(ctx context.Context, isoCountry string, reqEditors ...client.RequestEditorFn) (*FetchVoiceCountryResponse, error)

	// FetchVoiceNumber request
	FetchVoiceNumber(ctx context.Context, destinationNumber string, params *FetchVoiceNumberParams, reqEditors ...client.RequestEditorFn) (*FetchVoiceNumberResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// ListTrunkingCountry: GET /v2/Trunking/Countries

type ListTrunkingCountryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Countries *[]PricingV2TrunkingCountry `json:"countries,omitempty"`
		Meta      *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListTrunkingCountryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTrunkingCountryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListTrunkingCountryRequest generates requests for ListTrunkingCountry
func newListTrunkingCountryRequest(baseURL *url.URL, params *ListTrunkingCountryParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListTrunkingCountry)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListTrunkingCountry returns a parsed response.
// GET /v2/Trunking/Countries
func (c *Client) ListTrunkingCountry(ctx context.Context, params *ListTrunkingCountryParams, reqEditors ...client.RequestEditorFn) (*ListTrunkingCountryResponse, error) {
	req, err := newListTrunkingCountryRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListTrunkingCountryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Countries *[]PricingV2TrunkingCountry `json:"countries,omitempty"`
			Meta      *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchTrunkingCountry: GET /v2/Trunking/Countries/{IsoCountry}

type FetchTrunkingCountryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PricingV2TrunkingCountryInstance
}

// Status returns HTTPResponse.Status
func (r FetchTrunkingCountryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTrunkingCountryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchTrunkingCountryRequest generates requests for FetchTrunkingCountry
func newFetchTrunkingCountryRequest(baseURL *url.URL, isoCountry string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("IsoCountry", isoCountry)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchTrunkingCountryFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchTrunkingCountry returns a parsed response.
// GET /v2/Trunking/Countries/{IsoCountry}
func (c *Client) FetchTrunkingCountry(ctx context.Context, isoCountry string, reqEditors ...client.RequestEditorFn) (*FetchTrunkingCountryResponse, error) {
	req, err := newFetchTrunkingCountryRequest(c.BaseURL, isoCountry)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchTrunkingCountryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PricingV2TrunkingCountryInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchTrunkingNumber: GET /v2/Trunking/Numbers/{DestinationNumber}

type FetchTrunkingNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PricingV2TrunkingNumber
}

// Status returns HTTPResponse.Status
func (r FetchTrunkingNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTrunkingNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchTrunkingNumberRequest generates requests for FetchTrunkingNumber
func newFetchTrunkingNumberRequest(baseURL *url.URL, destinationNumber string, params *FetchTrunkingNumberParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("DestinationNumber", destinationNumber)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchTrunkingNumberFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.OriginationNumber != nil {
		if err := client.AddQueryParam(q, "OriginationNumber", *params.OriginationNumber); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchTrunkingNumber returns a parsed response.
// GET /v2/Trunking/Numbers/{DestinationNumber}
func (c *Client) FetchTrunkingNumber(ctx context.Context, destinationNumber string, params *FetchTrunkingNumberParams, reqEditors ...client.RequestEditorFn) (*FetchTrunkingNumberResponse, error) {
	req, err := newFetchTrunkingNumberRequest(c.BaseURL, destinationNumber, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchTrunkingNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PricingV2TrunkingNumber
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListVoiceCountry: GET /v2/Voice/Countries

type ListVoiceCountryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Countries *[]PricingV2VoiceVoiceCountry `json:"countries,omitempty"`
		Meta      *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListVoiceCountryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListVoiceCountryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListVoiceCountryRequest generates requests for ListVoiceCountry
func newListVoiceCountryRequest(baseURL *url.URL, params *ListVoiceCountryParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListVoiceCountry)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListVoiceCountry returns a parsed response.
// GET /v2/Voice/Countries
func (c *Client) ListVoiceCountry(ctx context.Context, params *ListVoiceCountryParams, reqEditors ...client.RequestEditorFn) (*ListVoiceCountryResponse, error) {
	req, err := newListVoiceCountryRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListVoiceCountryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Countries *[]PricingV2VoiceVoiceCountry `json:"countries,omitempty"`
			Meta      *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchVoiceCountry: GET /v2/Voice/Countries/{IsoCountry}

type FetchVoiceCountryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PricingV2VoiceVoiceCountryInstance
}

// Status returns HTTPResponse.Status
func (r FetchVoiceCountryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchVoiceCountryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchVoiceCountryRequest generates requests for FetchVoiceCountry
func newFetchVoiceCountryRequest(baseURL *url.URL, isoCountry string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("IsoCountry", isoCountry)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchVoiceCountryFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchVoiceCountry returns a parsed response.
// GET /v2/Voice/Countries/{IsoCountry}
func (c *Client) FetchVoiceCountry(ctx context.Context, isoCountry string, reqEditors ...client.RequestEditorFn) (*FetchVoiceCountryResponse, error) {
	req, err := newFetchVoiceCountryRequest(c.BaseURL, isoCountry)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchVoiceCountryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PricingV2VoiceVoiceCountryInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchVoiceNumber: GET /v2/Voice/Numbers/{DestinationNumber}

type FetchVoiceNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PricingV2VoiceVoiceNumber
}

// Status returns HTTPResponse.Status
func (r FetchVoiceNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchVoiceNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchVoiceNumberRequest generates requests for FetchVoiceNumber
func newFetchVoiceNumberRequest(baseURL *url.URL, destinationNumber string, params *FetchVoiceNumberParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("DestinationNumber", destinationNumber)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchVoiceNumberFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.OriginationNumber != nil {
		if err := client.AddQueryParam(q, "OriginationNumber", *params.OriginationNumber); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchVoiceNumber returns a parsed response.
// GET /v2/Voice/Numbers/{DestinationNumber}
func (c *Client) FetchVoiceNumber(ctx context.Context, destinationNumber string, params *FetchVoiceNumberParams, reqEditors ...client.RequestEditorFn) (*FetchVoiceNumberResponse, error) {
	req, err := newFetchVoiceNumberRequest(c.BaseURL, destinationNumber, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchVoiceNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PricingV2VoiceVoiceNumber
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}
