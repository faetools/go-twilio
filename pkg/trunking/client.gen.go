// Package trunking provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/faetools/devtool version (devel) DO NOT EDIT.
package trunking

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/faetools/client"
)

// operation paths

const (
	opPathDeleteTrunkFormat               = "./v1/Trunks/%s"
	opPathFetchTrunkFormat                = "./v1/Trunks/%s"
	opPathUpdateTrunkFormat               = "./v1/Trunks/%s"
	opPathListCredentialListFormat        = "./v1/Trunks/%s/CredentialLists"
	opPathCreateCredentialListFormat      = "./v1/Trunks/%s/CredentialLists"
	opPathDeleteCredentialListFormat      = "./v1/Trunks/%s/CredentialLists/%s"
	opPathFetchCredentialListFormat       = "./v1/Trunks/%s/CredentialLists/%s"
	opPathListIpAccessControlListFormat   = "./v1/Trunks/%s/IpAccessControlLists"
	opPathCreateIpAccessControlListFormat = "./v1/Trunks/%s/IpAccessControlLists"
	opPathDeleteIpAccessControlListFormat = "./v1/Trunks/%s/IpAccessControlLists/%s"
	opPathFetchIpAccessControlListFormat  = "./v1/Trunks/%s/IpAccessControlLists/%s"
	opPathListOriginationUrlFormat        = "./v1/Trunks/%s/OriginationUrls"
	opPathCreateOriginationUrlFormat      = "./v1/Trunks/%s/OriginationUrls"
	opPathDeleteOriginationUrlFormat      = "./v1/Trunks/%s/OriginationUrls/%s"
	opPathFetchOriginationUrlFormat       = "./v1/Trunks/%s/OriginationUrls/%s"
	opPathUpdateOriginationUrlFormat      = "./v1/Trunks/%s/OriginationUrls/%s"
	opPathListPhoneNumberFormat           = "./v1/Trunks/%s/PhoneNumbers"
	opPathCreatePhoneNumberFormat         = "./v1/Trunks/%s/PhoneNumbers"
	opPathDeletePhoneNumberFormat         = "./v1/Trunks/%s/PhoneNumbers/%s"
	opPathFetchPhoneNumberFormat          = "./v1/Trunks/%s/PhoneNumbers/%s"
	opPathFetchRecordingFormat            = "./v1/Trunks/%s/Recording"
	opPathUpdateRecordingFormat           = "./v1/Trunks/%s/Recording"
)

var (
	opPathListTrunk   = client.MustParseURL("./v1/Trunks")
	opPathCreateTrunk = client.MustParseURL("./v1/Trunks")
)

// ClientInterface interface specification for the client.
type ClientInterface interface {
	// ListTrunk request
	ListTrunk(ctx context.Context, params *ListTrunkParams, reqEditors ...client.RequestEditorFn) (*ListTrunkResponse, error)

	// CreateTrunk request with any body
	CreateTrunkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateTrunkResponse, error)

	// DeleteTrunk request
	DeleteTrunk(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteTrunkResponse, error)

	// FetchTrunk request
	FetchTrunk(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchTrunkResponse, error)

	// UpdateTrunk request with any body
	UpdateTrunkWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateTrunkResponse, error)

	// ListCredentialList request
	ListCredentialList(ctx context.Context, trunkSid string, params *ListCredentialListParams, reqEditors ...client.RequestEditorFn) (*ListCredentialListResponse, error)

	// CreateCredentialList request with any body
	CreateCredentialListWithBody(ctx context.Context, trunkSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCredentialListResponse, error)

	// DeleteCredentialList request
	DeleteCredentialList(ctx context.Context, trunkSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCredentialListResponse, error)

	// FetchCredentialList request
	FetchCredentialList(ctx context.Context, trunkSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchCredentialListResponse, error)

	// ListIpAccessControlList request
	ListIpAccessControlList(ctx context.Context, trunkSid string, params *ListIpAccessControlListParams, reqEditors ...client.RequestEditorFn) (*ListIpAccessControlListResponse, error)

	// CreateIpAccessControlList request with any body
	CreateIpAccessControlListWithBody(ctx context.Context, trunkSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateIpAccessControlListResponse, error)

	// DeleteIpAccessControlList request
	DeleteIpAccessControlList(ctx context.Context, trunkSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteIpAccessControlListResponse, error)

	// FetchIpAccessControlList request
	FetchIpAccessControlList(ctx context.Context, trunkSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchIpAccessControlListResponse, error)

	// ListOriginationUrl request
	ListOriginationUrl(ctx context.Context, trunkSid string, params *ListOriginationUrlParams, reqEditors ...client.RequestEditorFn) (*ListOriginationUrlResponse, error)

	// CreateOriginationUrl request with any body
	CreateOriginationUrlWithBody(ctx context.Context, trunkSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateOriginationUrlResponse, error)

	// DeleteOriginationUrl request
	DeleteOriginationUrl(ctx context.Context, trunkSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteOriginationUrlResponse, error)

	// FetchOriginationUrl request
	FetchOriginationUrl(ctx context.Context, trunkSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchOriginationUrlResponse, error)

	// UpdateOriginationUrl request with any body
	UpdateOriginationUrlWithBody(ctx context.Context, trunkSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateOriginationUrlResponse, error)

	// ListPhoneNumber request
	ListPhoneNumber(ctx context.Context, trunkSid string, params *ListPhoneNumberParams, reqEditors ...client.RequestEditorFn) (*ListPhoneNumberResponse, error)

	// CreatePhoneNumber request with any body
	CreatePhoneNumberWithBody(ctx context.Context, trunkSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreatePhoneNumberResponse, error)

	// DeletePhoneNumber request
	DeletePhoneNumber(ctx context.Context, trunkSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeletePhoneNumberResponse, error)

	// FetchPhoneNumber request
	FetchPhoneNumber(ctx context.Context, trunkSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchPhoneNumberResponse, error)

	// FetchRecording request
	FetchRecording(ctx context.Context, trunkSid string, reqEditors ...client.RequestEditorFn) (*FetchRecordingResponse, error)

	// UpdateRecording request with any body
	UpdateRecordingWithBody(ctx context.Context, trunkSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateRecordingResponse, error)
}

// Client definition

// compile time assert that it fulfils the interface
var _ ClientInterface = (*Client)(nil)

// Client conforms to the OpenAPI3 specification for this service.
type Client client.Client

// NewClient creates a new Client with reasonable defaults.
func NewClient(opts ...client.Option) (*Client, error) {
	c, err := client.NewClient(opts...)
	if err != nil {
		return nil, err
	}

	if c.BaseURL == nil {
		if err := client.WithBaseURL(DefaultServer)(c); err != nil {
			return nil, err
		}
	}

	return (*Client)(c), nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []client.RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}

	return nil
}

// ListTrunk: GET /v1/Trunks

type ListTrunkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		Trunks *[]TrunkingV1Trunk `json:"trunks,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListTrunkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTrunkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListTrunkRequest generates requests for ListTrunk
func newListTrunkRequest(baseURL *url.URL, params *ListTrunkParams) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathListTrunk)

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListTrunk returns a parsed response.
// GET /v1/Trunks
func (c *Client) ListTrunk(ctx context.Context, params *ListTrunkParams, reqEditors ...client.RequestEditorFn) (*ListTrunkResponse, error) {
	req, err := newListTrunkRequest(c.BaseURL, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListTrunkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			Trunks *[]TrunkingV1Trunk `json:"trunks,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateTrunk: POST /v1/Trunks

type CreateTrunkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TrunkingV1Trunk
}

// Status returns HTTPResponse.Status
func (r CreateTrunkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTrunkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateTrunkRequestWithBody generates requests for CreateTrunk with any type of body
func newCreateTrunkRequestWithBody(baseURL *url.URL, contentType string, body io.Reader) (*http.Request, error) {
	queryURL := baseURL.ResolveReference(opPathCreateTrunk)

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateTrunkWithBody returns a parsed response.
// POST /v1/Trunks
func (c *Client) CreateTrunkWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateTrunkResponse, error) {
	req, err := newCreateTrunkRequestWithBody(c.BaseURL, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateTrunkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TrunkingV1Trunk
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteTrunk: DELETE /v1/Trunks/{Sid}

type DeleteTrunkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTrunkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTrunkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteTrunkRequest generates requests for DeleteTrunk
func newDeleteTrunkRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteTrunkFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteTrunk returns a parsed response.
// DELETE /v1/Trunks/{Sid}
func (c *Client) DeleteTrunk(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*DeleteTrunkResponse, error) {
	req, err := newDeleteTrunkRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteTrunkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchTrunk: GET /v1/Trunks/{Sid}

type FetchTrunkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrunkingV1Trunk
}

// Status returns HTTPResponse.Status
func (r FetchTrunkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchTrunkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchTrunkRequest generates requests for FetchTrunk
func newFetchTrunkRequest(baseURL *url.URL, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchTrunkFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchTrunk returns a parsed response.
// GET /v1/Trunks/{Sid}
func (c *Client) FetchTrunk(ctx context.Context, sid string, reqEditors ...client.RequestEditorFn) (*FetchTrunkResponse, error) {
	req, err := newFetchTrunkRequest(c.BaseURL, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchTrunkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrunkingV1Trunk
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateTrunk: POST /v1/Trunks/{Sid}

type UpdateTrunkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrunkingV1Trunk
}

// Status returns HTTPResponse.Status
func (r UpdateTrunkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTrunkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateTrunkRequestWithBody generates requests for UpdateTrunk with any type of body
func newUpdateTrunkRequestWithBody(baseURL *url.URL, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateTrunkFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateTrunkWithBody returns a parsed response.
// POST /v1/Trunks/{Sid}
func (c *Client) UpdateTrunkWithBody(ctx context.Context, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateTrunkResponse, error) {
	req, err := newUpdateTrunkRequestWithBody(c.BaseURL, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateTrunkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrunkingV1Trunk
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListCredentialList: GET /v1/Trunks/{TrunkSid}/CredentialLists

type ListCredentialListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CredentialLists *[]TrunkingV1TrunkCredentialList `json:"credential_lists,omitempty"`
		Meta            *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCredentialListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCredentialListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListCredentialListRequest generates requests for ListCredentialList
func newListCredentialListRequest(baseURL *url.URL, trunkSid string, params *ListCredentialListParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrunkSid", trunkSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListCredentialListFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListCredentialList returns a parsed response.
// GET /v1/Trunks/{TrunkSid}/CredentialLists
func (c *Client) ListCredentialList(ctx context.Context, trunkSid string, params *ListCredentialListParams, reqEditors ...client.RequestEditorFn) (*ListCredentialListResponse, error) {
	req, err := newListCredentialListRequest(c.BaseURL, trunkSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListCredentialListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CredentialLists *[]TrunkingV1TrunkCredentialList `json:"credential_lists,omitempty"`
			Meta            *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateCredentialList: POST /v1/Trunks/{TrunkSid}/CredentialLists

type CreateCredentialListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TrunkingV1TrunkCredentialList
}

// Status returns HTTPResponse.Status
func (r CreateCredentialListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCredentialListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateCredentialListRequestWithBody generates requests for CreateCredentialList with any type of body
func newCreateCredentialListRequestWithBody(baseURL *url.URL, trunkSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrunkSid", trunkSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateCredentialListFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateCredentialListWithBody returns a parsed response.
// POST /v1/Trunks/{TrunkSid}/CredentialLists
func (c *Client) CreateCredentialListWithBody(ctx context.Context, trunkSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateCredentialListResponse, error) {
	req, err := newCreateCredentialListRequestWithBody(c.BaseURL, trunkSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateCredentialListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TrunkingV1TrunkCredentialList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteCredentialList: DELETE /v1/Trunks/{TrunkSid}/CredentialLists/{Sid}

type DeleteCredentialListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCredentialListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCredentialListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteCredentialListRequest generates requests for DeleteCredentialList
func newDeleteCredentialListRequest(baseURL *url.URL, trunkSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrunkSid", trunkSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteCredentialListFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteCredentialList returns a parsed response.
// DELETE /v1/Trunks/{TrunkSid}/CredentialLists/{Sid}
func (c *Client) DeleteCredentialList(ctx context.Context, trunkSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteCredentialListResponse, error) {
	req, err := newDeleteCredentialListRequest(c.BaseURL, trunkSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteCredentialListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchCredentialList: GET /v1/Trunks/{TrunkSid}/CredentialLists/{Sid}

type FetchCredentialListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrunkingV1TrunkCredentialList
}

// Status returns HTTPResponse.Status
func (r FetchCredentialListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchCredentialListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchCredentialListRequest generates requests for FetchCredentialList
func newFetchCredentialListRequest(baseURL *url.URL, trunkSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrunkSid", trunkSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchCredentialListFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchCredentialList returns a parsed response.
// GET /v1/Trunks/{TrunkSid}/CredentialLists/{Sid}
func (c *Client) FetchCredentialList(ctx context.Context, trunkSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchCredentialListResponse, error) {
	req, err := newFetchCredentialListRequest(c.BaseURL, trunkSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchCredentialListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrunkingV1TrunkCredentialList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListIpAccessControlList: GET /v1/Trunks/{TrunkSid}/IpAccessControlLists

type ListIpAccessControlListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IpAccessControlLists *[]TrunkingV1TrunkIpAccessControlList `json:"ip_access_control_lists,omitempty"`
		Meta                 *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListIpAccessControlListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIpAccessControlListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListIpAccessControlListRequest generates requests for ListIpAccessControlList
func newListIpAccessControlListRequest(baseURL *url.URL, trunkSid string, params *ListIpAccessControlListParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrunkSid", trunkSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListIpAccessControlListFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListIpAccessControlList returns a parsed response.
// GET /v1/Trunks/{TrunkSid}/IpAccessControlLists
func (c *Client) ListIpAccessControlList(ctx context.Context, trunkSid string, params *ListIpAccessControlListParams, reqEditors ...client.RequestEditorFn) (*ListIpAccessControlListResponse, error) {
	req, err := newListIpAccessControlListRequest(c.BaseURL, trunkSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListIpAccessControlListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IpAccessControlLists *[]TrunkingV1TrunkIpAccessControlList `json:"ip_access_control_lists,omitempty"`
			Meta                 *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateIpAccessControlList: POST /v1/Trunks/{TrunkSid}/IpAccessControlLists

type CreateIpAccessControlListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TrunkingV1TrunkIpAccessControlList
}

// Status returns HTTPResponse.Status
func (r CreateIpAccessControlListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIpAccessControlListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateIpAccessControlListRequestWithBody generates requests for CreateIpAccessControlList with any type of body
func newCreateIpAccessControlListRequestWithBody(baseURL *url.URL, trunkSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrunkSid", trunkSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateIpAccessControlListFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateIpAccessControlListWithBody returns a parsed response.
// POST /v1/Trunks/{TrunkSid}/IpAccessControlLists
func (c *Client) CreateIpAccessControlListWithBody(ctx context.Context, trunkSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateIpAccessControlListResponse, error) {
	req, err := newCreateIpAccessControlListRequestWithBody(c.BaseURL, trunkSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateIpAccessControlListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TrunkingV1TrunkIpAccessControlList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteIpAccessControlList: DELETE /v1/Trunks/{TrunkSid}/IpAccessControlLists/{Sid}

type DeleteIpAccessControlListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteIpAccessControlListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIpAccessControlListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteIpAccessControlListRequest generates requests for DeleteIpAccessControlList
func newDeleteIpAccessControlListRequest(baseURL *url.URL, trunkSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrunkSid", trunkSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteIpAccessControlListFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteIpAccessControlList returns a parsed response.
// DELETE /v1/Trunks/{TrunkSid}/IpAccessControlLists/{Sid}
func (c *Client) DeleteIpAccessControlList(ctx context.Context, trunkSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteIpAccessControlListResponse, error) {
	req, err := newDeleteIpAccessControlListRequest(c.BaseURL, trunkSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteIpAccessControlListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchIpAccessControlList: GET /v1/Trunks/{TrunkSid}/IpAccessControlLists/{Sid}

type FetchIpAccessControlListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrunkingV1TrunkIpAccessControlList
}

// Status returns HTTPResponse.Status
func (r FetchIpAccessControlListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchIpAccessControlListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchIpAccessControlListRequest generates requests for FetchIpAccessControlList
func newFetchIpAccessControlListRequest(baseURL *url.URL, trunkSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrunkSid", trunkSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchIpAccessControlListFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchIpAccessControlList returns a parsed response.
// GET /v1/Trunks/{TrunkSid}/IpAccessControlLists/{Sid}
func (c *Client) FetchIpAccessControlList(ctx context.Context, trunkSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchIpAccessControlListResponse, error) {
	req, err := newFetchIpAccessControlListRequest(c.BaseURL, trunkSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchIpAccessControlListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrunkingV1TrunkIpAccessControlList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListOriginationUrl: GET /v1/Trunks/{TrunkSid}/OriginationUrls

type ListOriginationUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		OriginationUrls *[]TrunkingV1TrunkOriginationUrl `json:"origination_urls,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListOriginationUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOriginationUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListOriginationUrlRequest generates requests for ListOriginationUrl
func newListOriginationUrlRequest(baseURL *url.URL, trunkSid string, params *ListOriginationUrlParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrunkSid", trunkSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListOriginationUrlFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListOriginationUrl returns a parsed response.
// GET /v1/Trunks/{TrunkSid}/OriginationUrls
func (c *Client) ListOriginationUrl(ctx context.Context, trunkSid string, params *ListOriginationUrlParams, reqEditors ...client.RequestEditorFn) (*ListOriginationUrlResponse, error) {
	req, err := newListOriginationUrlRequest(c.BaseURL, trunkSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListOriginationUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			OriginationUrls *[]TrunkingV1TrunkOriginationUrl `json:"origination_urls,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreateOriginationUrl: POST /v1/Trunks/{TrunkSid}/OriginationUrls

type CreateOriginationUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TrunkingV1TrunkOriginationUrl
}

// Status returns HTTPResponse.Status
func (r CreateOriginationUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOriginationUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreateOriginationUrlRequestWithBody generates requests for CreateOriginationUrl with any type of body
func newCreateOriginationUrlRequestWithBody(baseURL *url.URL, trunkSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrunkSid", trunkSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreateOriginationUrlFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreateOriginationUrlWithBody returns a parsed response.
// POST /v1/Trunks/{TrunkSid}/OriginationUrls
func (c *Client) CreateOriginationUrlWithBody(ctx context.Context, trunkSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreateOriginationUrlResponse, error) {
	req, err := newCreateOriginationUrlRequestWithBody(c.BaseURL, trunkSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreateOriginationUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TrunkingV1TrunkOriginationUrl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeleteOriginationUrl: DELETE /v1/Trunks/{TrunkSid}/OriginationUrls/{Sid}

type DeleteOriginationUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteOriginationUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOriginationUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeleteOriginationUrlRequest generates requests for DeleteOriginationUrl
func newDeleteOriginationUrlRequest(baseURL *url.URL, trunkSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrunkSid", trunkSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeleteOriginationUrlFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeleteOriginationUrl returns a parsed response.
// DELETE /v1/Trunks/{TrunkSid}/OriginationUrls/{Sid}
func (c *Client) DeleteOriginationUrl(ctx context.Context, trunkSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeleteOriginationUrlResponse, error) {
	req, err := newDeleteOriginationUrlRequest(c.BaseURL, trunkSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeleteOriginationUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchOriginationUrl: GET /v1/Trunks/{TrunkSid}/OriginationUrls/{Sid}

type FetchOriginationUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrunkingV1TrunkOriginationUrl
}

// Status returns HTTPResponse.Status
func (r FetchOriginationUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchOriginationUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchOriginationUrlRequest generates requests for FetchOriginationUrl
func newFetchOriginationUrlRequest(baseURL *url.URL, trunkSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrunkSid", trunkSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchOriginationUrlFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchOriginationUrl returns a parsed response.
// GET /v1/Trunks/{TrunkSid}/OriginationUrls/{Sid}
func (c *Client) FetchOriginationUrl(ctx context.Context, trunkSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchOriginationUrlResponse, error) {
	req, err := newFetchOriginationUrlRequest(c.BaseURL, trunkSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchOriginationUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrunkingV1TrunkOriginationUrl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateOriginationUrl: POST /v1/Trunks/{TrunkSid}/OriginationUrls/{Sid}

type UpdateOriginationUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrunkingV1TrunkOriginationUrl
}

// Status returns HTTPResponse.Status
func (r UpdateOriginationUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOriginationUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateOriginationUrlRequestWithBody generates requests for UpdateOriginationUrl with any type of body
func newUpdateOriginationUrlRequestWithBody(baseURL *url.URL, trunkSid string, sid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrunkSid", trunkSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateOriginationUrlFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateOriginationUrlWithBody returns a parsed response.
// POST /v1/Trunks/{TrunkSid}/OriginationUrls/{Sid}
func (c *Client) UpdateOriginationUrlWithBody(ctx context.Context, trunkSid string, sid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateOriginationUrlResponse, error) {
	req, err := newUpdateOriginationUrlRequestWithBody(c.BaseURL, trunkSid, sid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateOriginationUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrunkingV1TrunkOriginationUrl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// ListPhoneNumber: GET /v1/Trunks/{TrunkSid}/PhoneNumbers

type ListPhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta *struct {
			FirstPageUrl    *string `json:"first_page_url,omitempty"`
			Key             *string `json:"key,omitempty"`
			NextPageUrl     *string `json:"next_page_url,omitempty"`
			Page            *int    `json:"page,omitempty"`
			PageSize        *int    `json:"page_size,omitempty"`
			PreviousPageUrl *string `json:"previous_page_url,omitempty"`
			Url             *string `json:"url,omitempty"`
		} `json:"meta,omitempty"`
		PhoneNumbers *[]TrunkingV1TrunkPhoneNumber `json:"phone_numbers,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListPhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newListPhoneNumberRequest generates requests for ListPhoneNumber
func newListPhoneNumberRequest(baseURL *url.URL, trunkSid string, params *ListPhoneNumberParams) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrunkSid", trunkSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathListPhoneNumberFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	q := queryURL.Query()

	if params.PageSize != nil {
		if err := client.AddQueryParam(q, "PageSize", *params.PageSize); err != nil {
			return nil, err
		}
	}

	queryURL.RawQuery = q.Encode()

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ListPhoneNumber returns a parsed response.
// GET /v1/Trunks/{TrunkSid}/PhoneNumbers
func (c *Client) ListPhoneNumber(ctx context.Context, trunkSid string, params *ListPhoneNumberParams, reqEditors ...client.RequestEditorFn) (*ListPhoneNumberResponse, error) {
	req, err := newListPhoneNumberRequest(c.BaseURL, trunkSid, params)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &ListPhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta *struct {
				FirstPageUrl    *string `json:"first_page_url,omitempty"`
				Key             *string `json:"key,omitempty"`
				NextPageUrl     *string `json:"next_page_url,omitempty"`
				Page            *int    `json:"page,omitempty"`
				PageSize        *int    `json:"page_size,omitempty"`
				PreviousPageUrl *string `json:"previous_page_url,omitempty"`
				Url             *string `json:"url,omitempty"`
			} `json:"meta,omitempty"`
			PhoneNumbers *[]TrunkingV1TrunkPhoneNumber `json:"phone_numbers,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// CreatePhoneNumber: POST /v1/Trunks/{TrunkSid}/PhoneNumbers

type CreatePhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TrunkingV1TrunkPhoneNumber
}

// Status returns HTTPResponse.Status
func (r CreatePhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newCreatePhoneNumberRequestWithBody generates requests for CreatePhoneNumber with any type of body
func newCreatePhoneNumberRequestWithBody(baseURL *url.URL, trunkSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrunkSid", trunkSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathCreatePhoneNumberFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// CreatePhoneNumberWithBody returns a parsed response.
// POST /v1/Trunks/{TrunkSid}/PhoneNumbers
func (c *Client) CreatePhoneNumberWithBody(ctx context.Context, trunkSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*CreatePhoneNumberResponse, error) {
	req, err := newCreatePhoneNumberRequestWithBody(c.BaseURL, trunkSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &CreatePhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TrunkingV1TrunkPhoneNumber
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest
	}

	return response, nil
}

// DeletePhoneNumber: DELETE /v1/Trunks/{TrunkSid}/PhoneNumbers/{Sid}

type DeletePhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newDeletePhoneNumberRequest generates requests for DeletePhoneNumber
func newDeletePhoneNumberRequest(baseURL *url.URL, trunkSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrunkSid", trunkSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathDeletePhoneNumberFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodDelete, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// DeletePhoneNumber returns a parsed response.
// DELETE /v1/Trunks/{TrunkSid}/PhoneNumbers/{Sid}
func (c *Client) DeletePhoneNumber(ctx context.Context, trunkSid string, sid string, reqEditors ...client.RequestEditorFn) (*DeletePhoneNumberResponse, error) {
	req, err := newDeletePhoneNumberRequest(c.BaseURL, trunkSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &DeletePhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// FetchPhoneNumber: GET /v1/Trunks/{TrunkSid}/PhoneNumbers/{Sid}

type FetchPhoneNumberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrunkingV1TrunkPhoneNumber
}

// Status returns HTTPResponse.Status
func (r FetchPhoneNumberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchPhoneNumberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchPhoneNumberRequest generates requests for FetchPhoneNumber
func newFetchPhoneNumberRequest(baseURL *url.URL, trunkSid string, sid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrunkSid", trunkSid)
	if err != nil {
		return nil, err
	}

	pathParam1, err := client.GetPathParam("Sid", sid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchPhoneNumberFormat, pathParam0, pathParam1)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchPhoneNumber returns a parsed response.
// GET /v1/Trunks/{TrunkSid}/PhoneNumbers/{Sid}
func (c *Client) FetchPhoneNumber(ctx context.Context, trunkSid string, sid string, reqEditors ...client.RequestEditorFn) (*FetchPhoneNumberResponse, error) {
	req, err := newFetchPhoneNumberRequest(c.BaseURL, trunkSid, sid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchPhoneNumberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrunkingV1TrunkPhoneNumber
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// FetchRecording: GET /v1/Trunks/{TrunkSid}/Recording

type FetchRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TrunkingV1TrunkRecording
}

// Status returns HTTPResponse.Status
func (r FetchRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newFetchRecordingRequest generates requests for FetchRecording
func newFetchRecordingRequest(baseURL *url.URL, trunkSid string) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrunkSid", trunkSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathFetchRecordingFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodGet, queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// FetchRecording returns a parsed response.
// GET /v1/Trunks/{TrunkSid}/Recording
func (c *Client) FetchRecording(ctx context.Context, trunkSid string, reqEditors ...client.RequestEditorFn) (*FetchRecordingResponse, error) {
	req, err := newFetchRecordingRequest(c.BaseURL, trunkSid)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &FetchRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TrunkingV1TrunkRecording
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest
	}

	return response, nil
}

// UpdateRecording: POST /v1/Trunks/{TrunkSid}/Recording

type UpdateRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *TrunkingV1TrunkRecording
}

// Status returns HTTPResponse.Status
func (r UpdateRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// newUpdateRecordingRequestWithBody generates requests for UpdateRecording with any type of body
func newUpdateRecordingRequestWithBody(baseURL *url.URL, trunkSid string, contentType string, body io.Reader) (*http.Request, error) {
	pathParam0, err := client.GetPathParam("TrunkSid", trunkSid)
	if err != nil {
		return nil, err
	}

	opPath := fmt.Sprintf(opPathUpdateRecordingFormat, pathParam0)

	queryURL, err := baseURL.Parse(opPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add(client.ContentType, contentType)

	return req, nil
}

// UpdateRecordingWithBody returns a parsed response.
// POST /v1/Trunks/{TrunkSid}/Recording
func (c *Client) UpdateRecordingWithBody(ctx context.Context, trunkSid string, contentType string, body io.Reader, reqEditors ...client.RequestEditorFn) (*UpdateRecordingResponse, error) {
	req, err := newUpdateRecordingRequestWithBody(c.BaseURL, trunkSid, contentType, body)
	if err != nil {
		return nil, err
	}

	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}

	rsp, err := c.Client.Do(req)
	if err != nil {
		return nil, err
	}

	bodyBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	response := &UpdateRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TrunkingV1TrunkRecording
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest
	}

	return response, nil
}
